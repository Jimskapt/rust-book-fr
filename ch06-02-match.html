<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>La structure de contr√¥le match - Le langage de programmation Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer le jeu du plus ou du moins</a></li><li class="expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilit√©</a></li><li class="expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de donn√©es</a></li><li class="expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contr√¥le</a></li></ol></li><li class="expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les r√©f√©rences et l'emprunt</a></li><li class="expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des donn√©es apparent√©es</a></li><li><ol class="section"><li class="expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> D√©finir et instancier des structures</a></li><li class="expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des m√©thodes</a></li></ol></li><li class="expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les √©num√©rations et le filtrage par motif</a></li><li><ol class="section"><li class="expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> D√©finir une √©num√©ration</a></li><li class="expanded "><a href="ch06-02-match.html" class="active"><strong aria-hidden="true">6.2.</strong> La structure de contr√¥le match</a></li><li class="expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contr√¥le concise¬†: if let</a></li></ol></li><li class="expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> G√©rer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li><li class="expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> D√©finir des modules pour g√©rer la port√©e et la protection</a></li><li class="expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> D√©signer un √©l√©ment dans l'arborescence de modules</a></li><li class="expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Importer des chemins dans la port√©e via le mot-cl√© use</a></li><li class="expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> S√©parer les modules dans diff√©rents fichiers</a></li></ol></li><li class="expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Les collections standard</a></li><li><ol class="section"><li class="expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Stocker des listes de valeurs avec des vecteurs</a></li><li class="expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Stocker du texte encod√© en UTF-8 avec les Strings</a></li><li class="expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> üöß Stocker des cl√©s associ√©es √† des valeurs dans des tables de hachage</a></li></ol></li><li class="expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> üöß La gestion des erreurs</a></li><li><ol class="section"><li class="expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> üöß Les erreurs irr√©cup√©rables avec panic!</a></li><li class="expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> üöß Des erreurs r√©cup√©rables avec Result</a></li><li class="expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> üöß Paniquer ou ne pas paniquer, telle est la question ...</a></li></ol></li><li class="expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> üöß Les types g√©n√©riques, les traits et les dur√©es de vies</a></li><li><ol class="section"><li class="expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> üöß Les types de donn√©es g√©n√©riques</a></li><li class="expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> üöß D√©finir des comportements partag√©s avec les traits</a></li><li class="expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> üöß La conformit√© des r√©f√©rences avec les dur√©es de vies</a></li></ol></li><li class="expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> üöß Ecrire des tests automatis√©s</a></li><li><ol class="section"><li class="expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> üöß Comment √©crire des tests</a></li><li class="expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> üöß G√©rer l'ex√©cution des tests</a></li><li class="expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> üöß L'organisation des tests</a></li></ol></li><li class="expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> üöß Un projet d'entr√©e/sortie¬†: construire un programme en ligne de commande</a></li><li><ol class="section"><li class="expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> üöß R√©cup√©rer les arguments de la ligne de commande</a></li><li class="expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> üöß Lire un fichier</a></li><li class="expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> üöß Remanier le code pour am√©liorer sa modularit√© et la gestion des erreurs</a></li><li class="expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> üöß D√©velopper les fonctionnalit√©s de la biblioth√®que avec le TDD</a></li><li class="expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> üöß Travailler avec des variables d'environnement</a></li><li class="expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> üöß Ecrire les messages d'erreur sur la sortie d'erreurs standard au lieu de la sortie normale</a></li></ol></li><li class="expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Les fonctionnalit√©s des langages fonctionnels¬†: les it√©rateurs et les fermetures</a></li><li><ol class="section"><li class="expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Les fermetures¬†: fonctions anonymes qui peuvent utiliser leur environnement</a></li><li class="expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Traiter une s√©rie d'√©l√©ments avec un it√©rateur</a></li><li class="expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Am√©lioration de notre projet d'entr√©e/sortie</a></li><li class="expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparaison des performances¬†: les boucles et les it√©rateurs</a></li></ol></li><li class="expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> üöß En savoir plus sur cargo et crates.io</a></li><li><ol class="section"><li class="expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> üöß Personnaliser les compilations avec les profils de publication</a></li><li class="expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> üöß Publier une crate sur crates.io</a></li><li class="expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> üöß Les espaces de travail de cargo</a></li><li class="expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> üöß Installer des binaires √† partir de crates.io avec cargo install</a></li><li class="expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> üöß Etendre les fonctionnalit√©s de cargo avec des commandes personnalis√©es</a></li></ol></li><li class="expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> üöß Les pointeurs intelligents</a></li><li><ol class="section"><li class="expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> üöß Utiliser Box<T> pour pointer sur des donn√©es pr√©sentes sur le tas</a></li><li class="expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> üöß Consid√©rer les pointeurs intelligents comme des r√©f√©rences gr√¢ce au trait Deref</a></li><li class="expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> üöß Ex√©cuter du code au nettoyage avec le trait Drop</a></li><li class="expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> üöß Rc<T>, le pointeur intelligent qui compte les r√©f√©rences</a></li><li class="expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> üöß RefCell<T> et le motif de mutabilit√© interne</a></li><li class="expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> üöß Les boucles de r√©f√©rences qui peuvent provoquer des fuites de m√©moire</a></li></ol></li><li class="expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> üöß La concurrence sans craintes</a></li><li><ol class="section"><li class="expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> üöß Utiliser les t√¢ches pour ex√©cuter simultan√©ment du code</a></li><li class="expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> üöß Utiliser l'envoi de messages pour transf√©rer des donn√©es entre les t√¢ches</a></li><li class="expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> üöß Le partage d'√©tat en concurrence</a></li><li class="expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> üöß Etendre la concurrence avec les traits Sync et Send</a></li></ol></li><li class="expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Les fonctionnalit√©s orient√©es objet de Rust</a></li><li><ol class="section"><li class="expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> üöß Les caract√©ristiques des langages orient√©s objet</a></li><li class="expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> üöß Utiliser les objets traits qui permettent des valeurs de types diff√©rents</a></li><li class="expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> üöß Impl√©menter un patron de conception orient√©-objet</a></li></ol></li><li class="expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> üöß Les motifs et le filtrage par motif</a></li><li><ol class="section"><li class="expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> üöß Tous les endroits o√π les motifs peuvent √™tre utilis√©s</a></li><li class="expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> üöß La r√©futabilit√©¬†: lorsqu'un motif peut √©chouer √† correspondre</a></li><li class="expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> üöß La syntaxe des motifs</a></li></ol></li><li class="expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> üöß Les fonctionnalit√©s avanc√©es</a></li><li><ol class="section"><li class="expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> üöß Le Rust non s√©curis√© (unsafe)</a></li><li class="expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> üöß Les traits avanc√©s</a></li><li class="expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> üöß Les types avanc√©s</a></li><li class="expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> üöß Les fonctions et fermetures avanc√©es</a></li><li class="expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> üöß Les macros</a></li></ol></li><li class="expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> üöß Projet final : construire un serveur web multit√¢ches</a></li><li><ol class="section"><li class="expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> üöß D√©velopper un serveur web monot√¢che</a></li><li class="expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> üöß Transformer notre serveur monot√¢che en serveur multit√¢ches</a></li><li class="expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> üöß Arr√™t propre et nettoyage</a></li></ol></li><li class="expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> üöß Annexes</a></li><li><ol class="section"><li class="expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> üöß A - les mots-cl√©s</a></li><li class="expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> üöß B - les op√©rateurs et les symboles</a></li><li class="expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> üöß C - les traits d√©rivables</a></li><li class="expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> üöß D - Des outils de d√©veloppement utiles</a></li><li class="expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> üöß E - Les √©ditions</a></li><li class="expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> üöß F - Les traductions de ce livre</a></li><li class="expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> üöß G - Comment Rust est construit, et ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Le langage de programmation Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## The `match` Control Flow Operator
-->
<h2><a class="header" href="#la-structure-de-contr√¥le-match" id="la-structure-de-contr√¥le-match">La structure de contr√¥le <code>match</code></a></h2>
<!--
Rust has an extremely powerful control flow operator called `match` that allows
you to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 covers all the different
kinds of patterns and what they do. The power of `match` comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.
-->
<p>Rust a un op√©rateur de contr√¥le tr√®s puissant appel√© <code>match</code>, qui
vous permet de comparer une valeur avec une s√©rie de motifs et d'ex√©cuter du
code en fonction du motif qui correspond. Les motifs peuvent √™tre constitu√©s de
valeurs pures, de noms de variables, de jokers, parmi tant d'autres¬†; le
chapitre 18 va couvrir tous les diff√©rents types de motifs et ce qu'ils font. Ce
qui fait la puissance de <code>match</code> est l'expressivit√© des motifs et le fait que le
compilateur v√©rifie que tous les cas possibles sont bien g√©r√©s.</p>
<!--
Think of a `match` expression as being like a coin-sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a `match`, and at the first pattern the value ‚Äúfits,‚Äù
the value falls into the associated code block to be used during execution.
-->
<p>Consid√©rez l'expression <code>match</code> comme une machine √† trier les pi√®ces de
monnaie¬†: les pi√®ces descendent le long d'une piste avec des trous de taille
diff√©rente, et chaque pi√®ce tombe dans le premier trou qu'elle
rencontre √† sa taille. De mani√®re similaire, les valeurs parcourent tous les
motifs dans un <code>match</code>, et au premier motif auquel la valeur ‚Äúcorrespond‚Äù, la
valeur va descendre dans le bloc de code correspondant afin d'√™tre utilis√©e
pendant son ex√©cution.</p>
<!--
Because we just mentioned coins, let‚Äôs use them as an example using `match`! We
can write a function that can take an unknown United States coin and, in a
similar way as the counting machine, determine which coin it is and return its
value in cents, as shown here in Listing 6-3.
-->
<p>Comme nous venons de mentionner des pi√®ces, utilisons-les avec un exemple qui
utilise <code>match</code>¬†! Nous pouvons √©crire une fonction qui prend en param√®tre une
pi√®ce inconnue des Etats Unis d'Am√©rique (USA) et, de la m√™me mani√®re qu'une
machine √† trier, d√©terminer quelle pi√®ce c'est et retourner sa valeur en
centimes, comme ci-dessous dans l'encart 6-3.</p>
<!--
```rust
enum USACoin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valeur_en_centimes(piece: USACoin) -> u8 {
    match piece {
        USACoin::Penny => 1,
        USACoin::Nickel => 5,
        USACoin::Dime => 10,
        USACoin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playpen"><code class="language-rust">enum USACoin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valeur_en_centimes(piece: USACoin) -&gt; u8 {
    match piece {
        USACoin::Penny =&gt; 1,
        USACoin::Nickel =&gt; 5,
        USACoin::Dime =&gt; 10,
        USACoin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-3: An enum and a `match` expression that has
the variants of the enum as its patterns</span>
-->
<p><span class="caption">Encart 6-3¬†: Une √©num√©ration et une expression <code>match</code> qui
trie les variantes de l'√©num√©ration dans ses motifs</span></p>
<!--
Let‚Äôs break down the `match` in the `value_in_cents` function. First, we list
the `match` keyword followed by an expression, which in this case is the value
`coin`. This seems very similar to an expression used with `if`, but there‚Äôs a
big difference: with `if`, the expression needs to return a Boolean value, but
here, it can be any type. The type of `coin` in this example is the `Coin` enum
that we defined on line 1.
-->
<p>D√©composons le <code>match</code> dans la fonction <code>valeur_en_centimes</code>. En premier lieu,
nous utilisons le mot-cl√© <code>match</code> suivi par une expression, qui dans notre cas
est la valeur de <code>piece</code>. Cela ressemble beaucoup √† une expression utilis√©e avec
<code>if</code>, mais il y a une grosse diff√©rence¬†: avec <code>if</code>, l'expression doit retourner
un valeur bool√©enne, mais ici, elle peut retourner n'importe quel type. Dans cet
exemple, <code>piece</code> est de type <code>USACoin</code>, qui est l'√©num√©ration que nous avons
d√©finie √† la ligne 1.</p>
<!--
Next are the `match` arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value `Coin::Penny` and then the `=>`
operator that separates the pattern and the code to run. The code in this case
is just the value `1`. Each arm is separated from the next with a comma.
-->
<p>Ensuite, nous avons les branches du <code>match</code>. Une branche a deux parties¬†: un
motif et du code. La premi√®re branche a ici pour motif la valeur
<code>USACoin::Penny</code> et ensuite l'op√©rateur <code>=&gt;</code> qui s√©pare le motif et le code √†
ex√©cuter. Le code dans ce cas est uniquement la valeur <code>1</code>. Chaque branche est
s√©par√©e de la suivante par une virgule.</p>
<!--
When the `match` expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn‚Äôt match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our `match` has four arms.
-->
<p>Lorsqu'une expression <code>match</code> est ex√©cut√©e, elle compare la valeur de <code>piece</code>
avec le motif de chaque branche, dans l'ordre. Si un motif correspond √† la
valeur, le code correspondant √† ce motif est alors ex√©cut√©. Si ce motif ne
correspond pas √† la valeur, l'ex√©cution passe √† la prochaine branche, un peu
comme dans une machine de tri de pi√®ces. Nous pouvons avoir autant de branches
que nous avons besoin¬†: dans l'encart 6-3, notre <code>match</code> a quatre branches.</p>
<!--
The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire `match` expression.
-->
<p>Le code correspondant √† chaque branche est une expression, et la valeur qui
r√©sulte de l'expresssion dans la branche correspondante est la valeur qui sera
retourn√©e par l'expression <code>match</code>.</p>
<!--
Curly brackets typically aren‚Äôt used if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you can use curly brackets. For example, the
following code would print ‚ÄúLucky penny!‚Äù every time the method was called with
a `Coin::Penny` but would still return the last value of the block, `1`:
-->
<p>Les accolades ne sont g√©n√©ralement pas utilis√©es si le code de la branche
correspondante est court, comme est le cas dans l'encart 6-3 o√π chaque branche
retourne simplement une valeur. Si vous voulez ex√©cuter plusieures lignes de
code dans une branche d'un <code>match</code>, vous devez utiliser les accolades. Par
exemple, le code suivant va afficher ‚ÄúUn centime porte-bonheur¬†!‚Äù √† chaque fois
que la m√©thode est appell√©e avec une valeur <code>USACoin::Penny</code> mais va continuer
√† retourner la derni√®re valeur du bloc, <code>1</code>¬†:</p>
<!--
```rust
# enum USACoin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter,
# }
# 
fn valeur_en_centimes(piece: USACoin) -> u8 {
    match piece {
        USACoin::Penny => {
            println!("Un centime porte-bonheur¬†!");
            1
        },
        USACoin::Nickel => 5,
        USACoin::Dime => 10,
        USACoin::Quarter => 25,
    }
}
# 
# fn main() {}
```
-->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum USACoin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: USACoin) -&gt; u8 {
    match piece {
        USACoin::Penny =&gt; {
            println!(&quot;Un centime porte-bonheur¬†!&quot;);
            1
        },
        USACoin::Nickel =&gt; 5,
        USACoin::Dime =&gt; 10,
        USACoin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
### Patterns that Bind to Values
-->
<h3><a class="header" href="#des-motifs-reli√©s-√†-des-valeurs" id="des-motifs-reli√©s-√†-des-valeurs">Des motifs reli√©s √† des valeurs</a></h3>
<!--
Another useful feature of match arms is that they can bind to the parts of the
values that match the pattern. This is how we can extract values out of enum
variants.
-->
<p>Une autre fonctionnalit√© int√©ressante des branches de <code>match</code> est qu'elles
peuvent se lier aux valeurs qui correspondent au motif. C'est ainsi que nous
pouvons extraire les valeurs d'une variante d'√©num√©ration.</p>
<!--
As an example, let‚Äôs change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our `enum` by changing the `Quarter` variant to include a `UsState` value stored
inside it, which we‚Äôve done here in Listing 6-4.
-->
<p>En guise d'exemple, changeons une de nos variantes d'√©num√©ration pour stocker
une donn√©e √† l'int√©rieur. Entre 1999 et 2008, les Etats-Unis d'Am√©rique ont
frapp√© un c√¥t√© des pi√®ces de monnaie &quot;Quarter&quot; avec des d√©cors diff√©rents pour
chacun des 50 √©tats. Les autres pi√®ces n'ont pas eu de d√©cors d'√©tats, donc
seul le &quot;Quarter&quot; a cette valeur en plus. Nous pouvons ajouter cette information
√† notre <code>enum</code> en changeant la variante <code>Quarter</code> pour y ajouter une valeur
<code>USAState</code> qui y sera stock√©e √† l'int√©rieur, comme nous l'avons fait dans
l'encart 6-4.</p>
<!--
```rust
#[derive(Debug)] // pour pouvoir afficher l'√âtat
enum USAState {
    Alabama,
    Alaska,
    // -- partie masqu√©e ici --
}

enum USACoin {
    Penny,
    Nickel,
    Dime,
    Quarter(USAState),
}
# 
# fn main() {}
```
-->
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)] // pour pouvoir afficher l'√âtat
enum USAState {
    Alabama,
    Alaska,
    // -- partie masqu√©e ici --
}

enum USACoin {
    Penny,
    Nickel,
    Dime,
    Quarter(USAState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-4: A `Coin` enum in which the `Quarter` variant
also holds a `UsState` value</span>
-->
<p><span class="caption">Encart 6-4¬†: Une √©num√©ration <code>USACoin</code> dans laquelle la
variante <code>Quarter</code> stocke en plus une valeur de type <code>USAState</code></span></p>
<!--
Let‚Äôs imagine that a friend of ours is trying to collect all 50 state quarters.
While we sort our loose change by coin type, we‚Äôll also call out the name of
the state associated with each quarter so if it‚Äôs one our friend doesn‚Äôt have,
they can add it to their collection.
-->
<p>Imaginons qu'un de vos amis essaye de r√©cup√©rer tous les &quot;Quarter&quot; des 50 √©tats.
Pendant que nous trions notre monnaie en vrac par type de pi√®ce, nous
mentionnerons aussi le nom de l'√©tat correspondant √† chaque &quot;Quarter&quot; de sorte
que si notre ami ne l'a pas, il puisse l'ajouter √† sa collection.</p>
<!--
In the match expression for this code, we add a variable called `state` to the
pattern that matches values of the variant `Coin::Quarter`. When a
`Coin::Quarter` matches, the `state` variable will bind to the value of that
quarter‚Äôs state. Then we can use `state` in the code for that arm, like so:
-->
<p>Dans l'expression <code>match</code> de ce code, nous avons ajout√© une variable <code>etat</code> au
motif qui correspond √† la variante <code>USACoin::Quarter</code>. Quand on aura une
correspondance <code>USACoin::Quarter</code>, la variable <code>etat</code> sera li√©e √† la valeur de
l'√©tat de cette pi√®ce. Ensuite, nous pourrons utiliser <code>etat</code> dans le code de
cette branche, comme ceci¬†:</p>
<!--
```rust
# #[derive(Debug)]
# enum USAState {
#     Alabama,
#     Alaska,
#     // -- partie masqu√©e ici --
# }
# 
# enum USACoin {
#     Penny,
#     Nickel,
#     Dime,
#     Quarter(USAState),
# }
# 
fn valeur_en_centimes(piece: USACoin) -> u8 {
    match piece {
        USACoin::Penny => 1,
        USACoin::Nickel => 5,
        USACoin::Dime => 10,
        USACoin::Quarter(etat) => {
            println!("Il s'agit d'un Quarter de l'√©tat de {:?}¬†!", etat);
            25
        },
    }
}
# 
# fn main() {
#     valeur_en_centimes(USACoin::Quarter(USAState::Alaska));
# }
```
-->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum USAState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // -- partie masqu√©e ici --
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum USACoin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(USAState),
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: USACoin) -&gt; u8 {
    match piece {
        USACoin::Penny =&gt; 1,
        USACoin::Nickel =&gt; 5,
        USACoin::Dime =&gt; 10,
        USACoin::Quarter(etat) =&gt; {
            println!(&quot;Il s'agit d'un Quarter de l'√©tat de {:?}¬†!&quot;, etat);
            25
        },
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    valeur_en_centimes(USACoin::Quarter(USAState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<!--
If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin`
would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each
of the match arms, none of them match until we reach `Coin::Quarter(state)`. At
that point, the binding for `state` will be the value `UsState::Alaska`. We can
then use that binding in the `println!` expression, thus getting the inner
state value out of the `Coin` enum variant for `Quarter`.
-->
<p>Si nous appelons <code>valeur_en_centimes(USACoin::Quarter(USAState::Alaska))</code>,
<code>piece</code> vaudra <code>USACoin::Quarter(USAState::Alaska)</code>. Quand nous comparons cette
valeur avec toutes les branches du <code>match</code>, aucune d'entre elles ne
correspondront jusqu'√† ce qu'on arrive √† <code>USACoin::Quarter(etat)</code>. A partir de
ce moment, la variable <code>etat</code> aura la valeur <code>USAState::Alaska</code>. Nous pouvons
alors utiliser cette variable dans l'expression <code>println!</code>, ce qui nous permet
d'afficher la valeur de l'√©tat √† l'int√©rieur de la variante <code>Quarter</code> de la
l'√©num√©ration <code>USACoin</code>.</p>
<!--
### Matching with `Option<T>`
-->
<h3><a class="header" href="#utiliser-match-avec-optiont" id="utiliser-match-avec-optiont">Utiliser <code>match</code> avec <code>Option&lt;T&gt;</code></a></h3>
<!--
In the previous section, we wanted to get the inner `T` value out of the `Some`
case when using `Option<T>`; we can also handle `Option<T>` using `match` as we
did with the `Coin` enum! Instead of comparing coins, we‚Äôll compare the
variants of `Option<T>`, but the way that the `match` expression works remains
the same.
-->
<p>Dans la section pr√©c√©dente, nous voulions obtenir la valeur interne <code>T</code> dans le
cas de <code>Some</code> lorsqu'on utilisait <code>Option&lt;T&gt;</code>¬†; nous pouvons aussi g√©rer les
<code>Option&lt;T&gt;</code> en utilisant <code>match</code> comme nous l'avons fait avec l'√©num√©ration
<code>USACoin</code>¬†! Au lieu de comparer des pi√®ces, nous allons comparer les variantes
de <code>Option&lt;T&gt;</code>, mais la fa√ßon d'utiliser l'expression <code>match</code> reste la m√™me.</p>
<!--
Let‚Äôs say we want to write a function that takes an `Option<i32>` and, if
there‚Äôs a value inside, adds 1 to that value. If there isn‚Äôt a value inside,
the function should return the `None` value and not attempt to perform any
operations.
-->
<p>Disons que nous voulons √©crire une fonction qui prend une <code>Option&lt;i32&gt;</code> et, si
il y a une valeur √† l'int√©rieur, ajouter 1 √† cette valeur. S'il n'y pas de
valeur √† l'int√©rieur, la fonction retournera la valeur <code>None</code> et ne va rien
faire de plus.</p>
<!--
This function is very easy to write, thanks to `match`, and will look like
Listing 6-5.
-->
<p>Cette fonction est tr√®s facile √† √©crire, gr√¢ce √† <code>match</code>, et ressemblera √†
l'encart 6-5.</p>
<!--
```rust
# fn main() {
    fn plus_un(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let cinq = Some(5);
    let six = plus_un(cinq);
    let none = plus_un(None);
# }
```
-->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let cinq = Some(5);
    let six = plus_un(cinq);
    let none = plus_un(None);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-5: A function that uses a `match` expression on
an `Option<i32>`</span>
-->
<p><span class="caption">Encart 6-5¬†: Une fonction qui utilise une expression
<code>match</code> sur une <code>Option&lt;i32&gt;</code></span></p>
<!--
Let‚Äôs examine the first execution of `plus_one` in more detail. When we call
`plus_one(five)`, the variable `x` in the body of `plus_one` will have the
value `Some(5)`. We then compare that against each match arm.
-->
<p>Examinons la premi√®re ex√©cution de <code>plus_un</code> en d√©tail. Lorsque nous appellons
<code>plus_un(cinq)</code>, la variable <code>x</code> dans le corps de <code>plus_un</code> aura la valeur
<code>Some(5)</code>. Ensuite, nous comparons cela √† chaque branche du <code>match</code>.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_un(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let cinq = Some(5);
#     let six = plus_un(cinq);
#     let none = plus_un(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
The `Some(5)` value doesn‚Äôt match the pattern `None`, so we continue to the
next arm.
-->
<p>La valeur <code>Some(5)</code> ne correspond pas au motif <code>None</code>, donc nous continuons √† la
prochaine branche.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_un(x: Option<i32>) -> Option<i32> {
#         match x {
#             None => None,
            Some(i) => Some(i + 1),
#         }
#     }
# 
#     let cinq = Some(5);
#     let six = plus_un(cinq);
#     let none = plus_un(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
Does `Some(5)` match `Some(i)`? Why yes it does! We have the same variant. The
`i` binds to the value contained in `Some`, so `i` takes the value `5`. The
code in the match arm is then executed, so we add 1 to the value of `i` and
create a new `Some` value with our total `6` inside.
-->
<p>Est-ce que <code>Some(5)</code> correspond au <code>Some(i)</code>¬†? Bien s√ªr¬†! Nous avons la
m√™me variante. Le <code>i</code> va prendre la valeur contenue dans le <code>Some</code>, donc <code>i</code>
prend la valeur <code>5</code>. La code dans la branche du <code>match</code> est ex√©cut√©, donc nous
ajoutons 1 √† la valeur de <code>i</code> et nous cr√©ons une nouvelle valeur <code>Some</code> avec
notre r√©sultat <code>6</code> √† l'int√©rieur.</p>
<!--
Now let‚Äôs consider the second call of `plus_one` in Listing 6-5, where `x` is
`None`. We enter the `match` and compare to the first arm.
-->
<p>Maintenant, regardons le second appel √† <code>plus_un</code> dans l'encart 6-5, o√π <code>x</code> vaut
<code>None</code>. Nous entrons dans le <code>match</code> et nous le comparons √† la premi√®re branche.</p>
<!--
```rust,ignore
# fn main() {
#     fn plus_un(x: Option<i32>) -> Option<i32> {
#         match x {
            None => None,
#             Some(i) => Some(i + 1),
#         }
#     }
# 
#     let cinq = Some(5);
#     let six = plus_un(cinq);
#     let none = plus_un(None);
# }
```
-->
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
It matches! There‚Äôs no value to add to, so the program stops and returns the
`None` value on the right side of `=>`. Because the first arm matched, no other
arms are compared.
-->
<p>Cela correspond¬†! Il n'y a pas de valeur √† additionner, donc le programmme
s'arr√™te et retourne la valeur <code>None</code> qui est dans le c√¥t√© droit du <code>=&gt;</code>. Comme
la premi√®re branche correspond, les autres branches ne sont pas compar√©es.</p>
<!--
Combining `match` and enums is useful in many situations. You‚Äôll see this
pattern a lot in Rust code: `match` against an enum, bind a variable to the
data inside, and then execute code based on it. It‚Äôs a bit tricky at first, but
once you get used to it, you‚Äôll wish you had it in all languages. It‚Äôs
consistently a user favorite.
-->
<p>La combinaison de <code>match</code> et des √©num√©rations est utile dans de nombreuses
situations. Vous allez revoir de nombreuses fois ce sch√©ma dans du code Rust¬†:
utiliser <code>match</code> sur une √©num√©ration, r√©cup√©rer la valeur qu'elle renferme, et
ex√©cuter du code en fonction de sa valeur. C'est un peu d√©licat au d√©but, mais
une fois que vous vous y √™tes habitu√©, vous regretterez de ne pas l'avoir dans
les autres langages. Cela devient toujours l'outil pr√©f√©r√© de ses utilisateurs.</p>
<!--
### Matches Are Exhaustive
-->
<h3><a class="header" href="#les-match-sont-toujours-exhaustifs" id="les-match-sont-toujours-exhaustifs">Les <code>match</code> sont toujours exhaustifs</a></h3>
<!--
There‚Äôs one other aspect of `match` we need to discuss. Consider this version
of our `plus_one` function that has a bug and won‚Äôt compile:
-->
<p>Il y a un autre point de <code>match</code> que nous devons aborder. Admettons que cette
version de notre fonction <code>plus_un</code> a un bogue et ne va pas se compiler¬†:</p>
<!--
```rust,ignore,does_not_compile
# fn main() {
    fn plus_un(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }
# 
#     let cinq = Some(5);
#     let six = plus_un(cinq);
#     let none = plus_un(None);
# }
```
-->
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let cinq = Some(5);
</span><span class="boring">    let six = plus_un(cinq);
</span><span class="boring">    let none = plus_un(None);
</span><span class="boring">}
</span></code></pre>
<!--
We didn‚Äôt handle the `None` case, so this code will cause a bug. Luckily, it‚Äôs
a bug Rust knows how to catch. If we try to compile this code, we‚Äôll get this
error:
-->
<p>Nous n'avons pas g√©r√© le cas du <code>None</code>, donc ce code va g√©n√©rer un bogue.
Heureusement, c'est un bogue que Rust sait g√©rer. Si nous essayons de compiler
ce code, nous allons obtenir cette erreur¬†:</p>
<!--
```text
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --> src/main.rs:3:15
<p>|
3 |         match x {
|               ^ pattern <code>None</code> not covered
|
= help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms</p>
<p>error: aborting due to previous error</p>
<p>For more information about this error, try <code>rustc --explain E0004</code>.
error: could not compile <code>enums</code>.</p>
<p>To learn more, run the command again with --verbose.</p>
<pre><code>--&gt;

```text
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Rust knows that we didn‚Äôt cover every possible case and even knows which
pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
`Option<T>`, when Rust prevents us from forgetting to explicitly handle the
`None` case, it protects us from assuming that we have a value when we might
have null, thus making the billion-dollar mistake discussed earlier impossible.
-->
<p>Rust sait que nous n'avons pas couvert toutes les possibilit√©s et sait m√™me quel
motif nous avons oubli√©¬†! Les <code>match</code> de Rust sont <em>exhaustifs</em>¬†: nous devons
traiter toutes les possibilit√©s afin que le code soit valide. Dans notre cas de
<code>Option&lt;T&gt;</code>, quand Rust nous emp√™che d'oublier de g√©rer explicitement le cas de
<code>None</code>, il nous prot√®ge d'une situation o√π nous supposons que nous avons une
valeur alors que nous pourrions avoir null, ce qui rend impossible l'erreur aux
milliards de dollars que nous avons vu pr√©c√©demment.</p>
<!--
### The `_` Placeholder
-->
<h3><a class="header" href="#le-caract√®re-r√©serv√©-_" id="le-caract√®re-r√©serv√©-_">Le caract√®re r√©serv√© <code>_</code></a></h3>
<!--
Rust also has a pattern we can use when we don‚Äôt want to list all possible
values. For example, a `u8` can have valid values of 0 through 255. If we only
care about the values 1, 3, 5, and 7, we don‚Äôt want to have to list out 0, 2,
4, 6, 8, 9 all the way up to 255. Fortunately, we don‚Äôt have to: we can use the
special pattern `_` instead:
-->
<p>Rust a aussi un motif que nous pouvons utliser quand nous ne voulons pas traiter
toutes les valeurs possibles. Par exemple, un <code>u8</code> peut √™tre valide entre 0
et 255. Si nous n'avons besoin que des valeurs 1, 3, 5 et 7, nous ne voulons pas
traiter 0, 2, 4, 6, 7, 8, 9 et ainsi de suite jusqu'√† 255. Heureusement, nous
n'avons pas √† le faire¬†: nous pouvons utiliser le motif sp√©cial <code>_</code>¬†:</p>
<!--
```rust
# fn main() {
    let une_valeur_u8 = 0u8;
    match une_valeur_u8 {
        1 => println!("un"),
        3 => println!("trois"),
        5 => println!("cinq"),
        7 => println!("sept"),
        _ => (),
    }
# }
```
-->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span>    let une_valeur_u8 = 0u8;
    match une_valeur_u8 {
        1 =&gt; println!(&quot;un&quot;),
        3 =&gt; println!(&quot;trois&quot;),
        5 =&gt; println!(&quot;cinq&quot;),
        7 =&gt; println!(&quot;sept&quot;),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
The `_` pattern will match any value. By putting it after our other arms, the
`_` will match all the possible cases that aren‚Äôt specified before it. The `()`
is just the unit value, so nothing will happen in the `_` case. As a result, we
can say that we want to do nothing for all the possible values that we don‚Äôt
list before the `_` placeholder.
-->
<p>Le motif <code>_</code> va correspondre √† toutes les valeurs. En l'ajoutant √† la fin de nos
branches, le <code>_</code> va correspondre √† tous les autres cas qui ne sont pas list√©s
avant. Au final, nous avons pu dire que nous ne voulons rien faire pour les
valeurs possibles que nous ne traitons pas avant le caract√®re r√©serv√© <code>_</code>.</p>
<!--
However, the `match` expression can be a bit wordy in a situation in which we
care about only *one* of the cases. For this situation, Rust provides `if let`.
-->
<p>Cependant, l'expression <code>match</code> peut √™tre un peu lourde dans une situation o√π
nous nous pr√©occupons uniquement <em>d'un seul</em> cas. Pour ce cas, Rust nous propose
d'utiliser une autre structure, <code>if let</code>.</p>
<!--
More about patterns, and matching can be found in [chapter 18][ch18-00-patterns].
-->
<p>Vous pouvez en apprendre plus sur les motifs et le filtrage par motif au
<a href="ch18-00-patterns.html">chapter 18</a>.</p>
<!--
[ch18-00-patterns]:
ch18-00-patterns.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch06-01-defining-an-enum.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch06-03-if-let.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch06-01-defining-an-enum.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch06-03-if-let.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        
        <script type="text/javascript" src="github-button.js"></script>
        

        

    </body>
</html>
