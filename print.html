<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Le langage de programmation Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../ferris.css">
        
        <link rel="stylesheet" href="../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="title-page.html">Le langage de programmation Rust</a></li><li class="expanded affix "><a href="foreword.html">Avant-propos</a></li><li class="expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="expanded affix "><a href="translation-terms.html">Traduction des termes</a></li><li class="expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Prise en main</a></li><li><ol class="section"><li class="expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li class="expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programmer un jeu de devinettes</a></li><li class="expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Les concepts courants de programmation</a></li><li><ol class="section"><li class="expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Les variables et la mutabilité</a></li><li class="expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Les types de données</a></li><li class="expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Les fonctions</a></li><li class="expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Les commentaires</a></li><li class="expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Les structures de contrôle</a></li></ol></li><li class="expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendre la possession</a></li><li><ol class="section"><li class="expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qu'est-ce que la possession ?</a></li><li class="expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Les références et l'emprunt</a></li><li class="expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Le type slice</a></li></ol></li><li class="expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Utiliser les structures pour structurer des données apparentées</a></li><li><ol class="section"><li class="expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Définir et instancier des structures</a></li><li class="expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un exemple de programme qui utilise des structures</a></li><li class="expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> La syntaxe des méthodes</a></li></ol></li><li class="expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Les énumérations et le filtrage par motif</a></li><li><ol class="section"><li class="expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Définir une énumération</a></li><li class="expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> La structure de contrôle match</a></li><li class="expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Une structure de contrôle concise : if let</a></li></ol></li><li class="expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Gérer des projets grandissants avec les paquets, crates et modules</a></li><li><ol class="section"><li class="expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Les paquets et les crates</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Le langage de programmation Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# The Rust Programming Language
-->
<h1><a class="header" href="#le-langage-de-programmation-rust" id="le-langage-de-programmation-rust">Le langage de programmation Rust</a></h1>
<!--
*by Steve Klabnik and Carol Nichols, with contributions from the Rust Community*
-->
<p><em>par Steve Klabnik et Carol Nichols, avec la participation de la Communauté
Rust</em></p>
<!--
This version of the text assumes you’re using Rust 1.37.0 or later with
`edition="2018"` in *Cargo.toml* of all projects to use Rust 2018 Edition
idioms. See the [“Installation” section of Chapter 1][install]<!-- ignore -- >
to install or update Rust, and see the new [Appendix E][editions]<!-- ignore
-- > for information on editions.
-->
<p>Cette version du document suppose que vous utilisez Rust 1.37.0 ou ultérieur
avec <code>edition=&quot;2018&quot;</code> dans <em>Cargo.toml</em> de tous les projets afin d'utiliser les
expressions idiomatiques de l'édition 2018 de Rust.
Voir la <a href="ch01-01-installation.html">section “Installation” du chapitre 1</a><!-- ignore -->
pour installer ou mettre à jour Rust, et
voir la nouvelle <a href="appendix-05-editions.html">annexe E</a><!-- ignore --> pour plus d'informations
sur les éditions.</p>
<!--
The 2018 Edition of the Rust language includes a number of improvements that
make Rust more ergonomic and easier to learn. This iteration of the book
contains a number of changes to reflect those improvements:
-->
<p>L'édition 2018 du langage Rust apporte quelques améliorations qui rendent Rust
plus ergonomique et plus facile à apprendre. Cette version du livre comprend un
certain nombre de changements pour refléter ces améliorations :</p>
<!--
- Chapter 7, “Managing Growing Projects with Packages, Crates, and Modules,”
  has been mostly rewritten. The module system and the way paths work in the
  2018 Edition were made more consistent.
- Chapter 10 has new sections titled “Traits as Parameters” and “Returning
  Types that Implement Traits” that explain the new `impl Trait` syntax.
- Chapter 11 has a new section titled “Using `Result<T, E>` in Tests” that
  shows how to write tests that use the `?` operator.
- The “Advanced Lifetimes” section in Chapter 19 was removed because compiler
  improvements have made the constructs in that section even rarer.
- The previous Appendix D, “Macros,” has been expanded to include procedural
  macros and was moved to the “Macros” section in Chapter 19.
- Appendix A, “Keywords,” also explains the new raw identifiers feature that
  enables code written in the 2015 Edition and the 2018 Edition to interoperate.
- Appendix D is now titled “Useful Development Tools” and covers recently
  released tools that help you write Rust code.
- We fixed a number of small errors and imprecise wording throughout the book.
  Thank you to the readers who reported them!
-->
<ul>
<li>Le chapitre 7 a été réécrit en grande partie. Le système de modules et le
fonctionnement des chemins dans l'édition 2018 ont été rendus plus cohérents.</li>
<li>Le chapitre 10 a deux nouvelles parties qui expliquent la nouvelle syntaxe
<code>impl Trait</code>.</li>
<li>Le chapitre 11 a une nouvelle partie qui montre comment écrire des tests qui
utilisent l'opérateur <code>?</code>.</li>
<li>La partie &quot;Durée de vie avancée&quot; du chapitre 19 a été retirée, car les
améliorations du compilateur ont rendu encore plus rare les concepts de cette
section.</li>
<li>L'ancienne Annexe D a été complétée pour couvrir les macros procédurales et a
été déplacée dans la section &quot;Macros&quot; du chapitre 19.</li>
<li>L'annexe A explique aussi la nouvelle fonctionnalité d'identificateurs bruts
qui rend du code écrit avec l'édition 2015 interopérable avec l'édition 2018.</li>
<li>L'annexe D a été renommée et couvre les nouveaux outils ajoutés récemment
pour vous aider à écrire du code Rust.</li>
<li>Nous avons corrigé quelques petites erreurs et certaines formulations floues
dans tout le livre. Merci aux lecteurs qui nous les ont signalées !</li>
</ul>
<!--
Note that any code in earlier iterations of *The Rust Programming Language*
that compiled will continue to compile without `edition="2018"` in the
project’s *Cargo.toml*, even as you update the Rust compiler version you’re
using. That’s Rust’s backward compatibility guarantees at work!
-->
<p>Veuillez noter que tout le code dans les versions précédentes du livre
<em>Le langage de programmation Rust</em> qui se compilait va continuer à compiler sans
<code>edition=&quot;2018&quot;</code> dans le <em>Cargo.toml</em> du projet, même si vous mettez à jour le
compilateur Rust que vous utilisez. C'est la garantie de la rétrocompatibilité
de Rust qui est à l'œuvre ici !</p>
<!--
The HTML format is available online at
[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
and offline with installations of Rust made with `rustup`; run `rustup docs
--book` to open.
-->
<p>Le format HTML de la version anglaise est disponible en ligne à l'adresse
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
et en hors-ligne avec l'installation de Rust qui a été effectuée avec <code>rustup</code> ;
vous pouvez lancer <code>rustup docs --book</code> pour l'ouvrir.</p>
<!--
This text is available in [paperback and ebook format from No Starch
Press][nsprust].
-->
<p>La version anglaise de ce livre est disponible
<a href="https://nostarch.com/rust">au format papier et e-book chez No Starch Press</a>.</p>
<!--
# Foreword
-->
<h1><a class="header" href="#avant-propos" id="avant-propos">Avant-propos</a></h1>
<!--
It wasn’t always so clear, but the Rust programming language is fundamentally
about *empowerment*: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.
-->
<p>Cela n'a pas toujours été aussi évident, mais le langage de programmation Rust
apporte avant tout plus de <em>puissance</em> : peu importe le type de code que vous
écrivez en ce moment, Rust vous permet d'aller plus loin et de
programmer en toute confiance dans une plus grande diversité de domaines
qu'auparavant.</p>
<!--
Take, for example, “systems-level” work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.
-->
<p>Prenez par exemple la gestion des éléments au “niveau système” qui traite de
détails bas niveau de gestion de mémoire, de modèles de données, et de
concurrence. Traditionnellement, ce domaine de la programmation est jugé
ésotérique, compréhensible uniquement par une poignée de personnes qui ont
consacré des années d'apprentissage à en déjouer les pièges infâmes.
Et même ceux qui travaillent dans ce domaine le font avec beaucoup de prudence,
de crainte que leur code soit soumis à des failles ou des plantages,
ou qu'il soit corrompu.</p>
<!--
Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to “dip down” into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.
-->
<p>Rust fait tomber ces obstacles en éliminant les vieux pièges et en apportant un
ensemble d'outils soignés et conviviaux pour vous aider sur votre chemin.
Les développeurs qui ont besoin de &quot;se plonger&quot; dans le contrôle de plus
bas niveau peuvent ainsi le faire avec Rust, sans prendre le risque habituel
de plantages ou de failles de sécurité, et sans avoir à apprendre les subtilités
d'un enchevêtrement d'outils capricieux. Encore mieux, le langage est conçu pour
vous guider naturellement vers un code fiable et efficace en termes de rapidité
d'exécution et d'utilisation de la mémoire.</p>
<!--
Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you won’t accidentally introduce crashes or vulnerabilities.
-->
<p>Les développeurs qui travaillent déjà avec du code bas niveau peuvent utiliser
Rust pour accroître leurs ambitions. Par exemple, introduire du parallélisme en
Rust est une opération à faible risque : le compilateur va détecter les erreurs
classiques pour vous. Et vous pourrez vous lancer dans des améliorations plus
agressives de votre code avec la certitude que vous n'introduirez pas
accidentellement des causes de plantage ou des vulnérabilités.</p>
<!--
But Rust isn’t limited to low-level systems programming. It’s expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write — you’ll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.
-->
<p>Mais Rust n'est pas cantonné à la programmation de bas niveau. C'est un langage
suffisamment expressif et ergonomique pour rendre les applications en ligne
de commande, les serveurs web et bien d'autres types de code agréables à écrire
— vous trouverez plus tard des exemples simples de chacun dans ce livre.
Travailler avec Rust vous permet d'acquérir des compétences qui sont
transposables d'un domaine à un autre ; vous pouvez apprendre Rust en écrivant
une application web, puis appliquer les mêmes notions pour les utiliser avec
votre Raspberry Pi.</p>
<!--
This book fully embraces the potential of Rust to empower its users. It’s a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learn—and welcome to the Rust community!
-->
<p>Ce livre exploite pleinement le potentiel de Rust pour permettre à ses
utilisateurs de se développer. C'est une documentation conviviale et accessible
destinée à améliorer vos connaissances en Rust, mais aussi à améliorer vos
capacités et votre assurance en tant que développeur en général. Alors foncez,
et préparez-vous à apprendre — et bienvenue dans la communauté Rust !</p>
<!--
— Nicholas Matsakis and Aaron Turon
-->
<p>— Nicholas Matsakis et Aaron Turon</p>
<!--
# Introduction
-->
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<!--
> Note: This edition of the book is the same as [The Rust Programming
> Language][nsprust] available in print and ebook format from [No Starch
> Press][nsp].
-->
<blockquote>
<p>Note : la version anglaise de ce livre est disponible au format papier et
ebook chez <a href="https://nostarch.com/">No Starch Press</a> à cette adresse :
<a href="https://nostarch.com/rust">The Rust Programming Language</a></p>
</blockquote>
<!--
Welcome to *The Rust Programming Language*, an introductory book about Rust.
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.
-->
<p>Bienvenue sur <em>Le langage de programmation Rust</em>, un livre d'initiation à Rust.
Le langage de programmation Rust vous aide à écrire plus rapidement des
logiciels plus fiables. L'ergonomie de haut-niveau et la maîtrise de bas-niveau
sont souvent en opposition dans la conception des langages de programmation ;
Rust remet en cause ce conflit. Grâce à l'équilibre entre ses puissantes
capacités techniques et une bonne ergonomie de développement, Rust vous donne
la possibilité de contrôler les détails de bas-niveau (comme l'utilisation de
la mémoire) sans tous les soucis traditionnellement associés à ce genre de
pratique.</p>
<!--
## Who Rust Is For
-->
<h2><a class="header" href="#À-qui-sadresse-rust" id="À-qui-sadresse-rust">À qui s'adresse Rust</a></h2>
<!--
Rust is ideal for many people for a variety of reasons. Let’s look at a few of
the most important groups.
-->
<p>Rust est idéal pour de nombreuses personnes pour diverses raisons. Analysons
quelques-uns des groupes les plus importants.</p>
<!--
### Teams of Developers
-->
<h3><a class="header" href="#Équipes-de-développeurs" id="Équipes-de-développeurs">Équipes de développeurs</a></h3>
<!--
Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to a variety of subtle bugs, which in most other languages can be
caught only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the program’s
logic rather than chasing down bugs.
-->
<p>Rust se révèle être un outil productif pour la collaboration entre de grandes
équipes de développeurs ayant différents niveaux de connaissances en
programmation système. Le code de bas-niveau est sujet à une multitude de bogues
subtils, qui, dans la plupart des autres langages, ne peuvent être prévenus
qu'au moyen de campagnes de test étendues et de minutieuses revues de
code menées par des développeurs chevronnés. Avec Rust, le compilateur joue le
rôle de gardien en refusant de compiler du code qui comprend ces bogues
discrets et vicieux, y compris les bogues de concurrence. En travaillant avec
le compilateur, l'équipe peut se concentrer sur la logique du programme plutôt
que de traquer les bogues.</p>
<!--
Rust also brings contemporary developer tools to the systems programming world:
-->
<p>Rust offre aussi des outils de développement modernes au monde de la
programmation système :</p>
<!--
* Cargo, the included dependency manager and build tool, makes adding,
  compiling, and managing dependencies painless and consistent across the Rust
  ecosystem.
* Rustfmt ensures a consistent coding style across developers.
* The Rust Language Server powers Integrated Development Environment (IDE)
  integration for code completion and inline error messages.
-->
<ul>
<li>Cargo, l'outil intégré de gestion de dépendances et de compilation, qui
uniformise et facilite l'ajout, la compilation, et la gestion des dépendances
dans l'écosystème Rust.</li>
<li>Rustfmt, qui assure une cohérence de style de codage pour tous les
développeurs.</li>
<li>Le <em>Rust Langage Server</em> alimente les environnements de développement
intégrés (IDE) pour la complétion du code et l'affichage direct des messages
d'erreur.</li>
</ul>
<!--
By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.
-->
<p>En utilisant ces outils ainsi que d'autres dans l'écosystème Rust, les
développeurs peuvent être plus productifs quand ils écrivent du code système.</p>
<!--
### Students
-->
<h3><a class="header" href="#Étudiants" id="Étudiants">Étudiants</a></h3>
<!--
Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.
-->
<p>Rust est conçu pour les étudiants et ceux qui s'intéressent à l'apprentissage
des concepts système. En utilisant Rust, de nombreuses personnes ont appris
des domaines comme le développement de systèmes d'exploitation. La communauté
est très accueillante et répond volontiers aux questions des étudiants. Grâce à
des initiatives comme ce livre, les équipes de Rust veulent rendre les notions
système accessibles au plus grand nombre, particulièrement à ceux qui débutent
dans la programmation.</p>
<!--
### Companies
-->
<h3><a class="header" href="#entreprises" id="entreprises">Entreprises</a></h3>
<!--
Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.
-->
<p>Des centaines d'entreprises, petites et grosses, utilisent Rust en production
pour différentes missions. Ils l'utilisent pour des outils en ligne de commande,
des services web, des outils DevOps, des systèmes embarqués, de l'analyse et de
la conversion audio et vidéo, des cryptomonnaies, de la bio-informatique, des
moteurs de recherche, de l'internet des objets <em>(IoT)</em>, de l'apprentissage
automatique <em>(marchine learning)</em>, et même des parties importantes du navigateur
internet Firefox.</p>
<!--
### Open Source Developers
-->
<h3><a class="header" href="#développeurs-de-logiciel-libre" id="développeurs-de-logiciel-libre">Développeurs de logiciel libre</a></h3>
<!--
Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. We’d love to have you contribute to the Rust
language.
-->
<p>Rust est ouvert aux personnes qui veulent développer le langage de programmation
Rust, la communauté, les outils de développement et les bibliothèques. Nous
serions ravis que vous contribuiez au langage Rust.</p>
<!--
### People Who Value Speed and Stability
-->
<h3><a class="header" href="#les-personnes-qui-recherchent-la-rapidité-et-la-stabilité" id="les-personnes-qui-recherchent-la-rapidité-et-la-stabilité">Les personnes qui recherchent la rapidité et la stabilité</a></h3>
<!--
Rust is for people who crave speed and stability in a language. By speed, we
mean the speed of the programs that you can create with Rust and the speed at
which Rust lets you write them. The Rust compiler’s checks ensure stability
through feature additions and refactoring. This is in contrast to the brittle
legacy code in languages without these checks, which developers are often
afraid to modify. By striving for zero-cost abstractions, higher-level features
that compile to lower-level code as fast as code written manually, Rust
endeavors to make safe code be fast code as well.
-->
<p>Rust est une solution pour les personnes qui chérissent la rapidité et la
stabilité dans un langage. Par rapidité, nous entendons la vitesse des
programmes que vous pouvez créer avec Rust et la rapidité avec laquelle Rust
vous permet de les écrire. Les vérifications du compilateur de Rust assurent la
stabilité durant l'ajout de fonctionnalités ou le remaniement du code. Cela
le démarque des langages qui ne font pas ces contrôles sur du code instable que
le programme a hérité avec le temps, et que bien souvent les développeurs ont
peur de modifier. En s'efforçant de mettre en place des abstractions sans coût,
des fonctionnalités de haut-niveau qui compilent vers du code bas-niveau aussi
rapide que s'il avait été écrit à la main, Rust fait en sorte que le
code sûr soit aussi du code rapide.</p>
<!--
The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rust’s greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety *and* productivity, speed *and* ergonomics. Give
Rust a try and see if its choices work for you.
-->
<p>Le langage Rust espère aider beaucoup d'autres utilisateurs ; ceux cités ici ne
font partie que d'un univers bien plus grand. Globalement, la plus grande
ambition de Rust est d'éradiquer les compromis auxquels les développeurs
se soumettaient depuis des décennies en leur apportant sécurité <em>et</em>
productivité, rapidité <em>et</em> ergonomie. Essayez Rust et vérifiez si ses décisions
vous conviennent.</p>
<!--
## Who This Book Is For
-->
<h2><a class="header" href="#À-qui-est-destiné-ce-livre" id="À-qui-est-destiné-ce-livre">À qui est destiné ce livre</a></h2>
<!--
This book assumes that you’ve written code in another programming language but
doesn’t make any assumptions about which one. We’ve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
don’t spend a lot of time talking about what programming *is* or how to think
about it. If you’re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.
-->
<p>Ce livre suppose que vous avez écrit du code dans un autre langage de
programmation mais ne suppose pas lequel. Nous avons essayé de rendre son
contenu le plus accessible au plus grand nombre d'expériences de programmation
possible. Nous ne nous évertuons pas à nous questionner sur <em>ce qu'est</em> la
programmation ou comment l'envisager. Si vous êtes débutant en programmation,
vous seriez mieux avisé en lisant un livre qui vous initie à la programmation.</p>
<!--
## How to Use This Book
-->
<h2><a class="header" href="#comment-utiliser-ce-livre" id="comment-utiliser-ce-livre">Comment utiliser ce livre</a></h2>
<!--
In general, this book assumes that you’re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.
-->
<p>Globalement, ce livre est prévu pour être lu dans l'ordre. Les chapitres
suivants s'appuient sur les notions abordées dans les chapitres précédents, et
lorsque les chapitres précédents ne peuvent pas approfondir un sujet, ce sera
généralement fait dans un chapitre suivant.</p>
<!--
You’ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you’ll learn about an aspect of Rust. In project
chapters, we’ll build small programs together, applying what you’ve learned so
far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters.
-->
<p>Vous allez rencontrer deux différents types de chapitres dans ce livre : les
chapitres théoriques et les chapitres de projet. Dans les chapitres théoriques,
vous allez apprendre un sujet à propos de Rust. Dans un chapitre de projet, nous
allons construire ensemble des petits programmes, pour appliquer ce que vous
avez appris précédemment. Les chapitres 2, 12 et 20 sont des chapitres de
projet ; les autres sont des chapitres théoriques.</p>
<!--
Chapter 1 explains how to install Rust, how to write a “Hello, world!” program,
and how to use Cargo, Rust’s package manager and build tool. Chapter 2 is a
hands-on introduction to the Rust language. Here we cover concepts at a high
level, and later chapters will provide additional detail. If you want to get
your hands dirty right away, Chapter 2 is the place for that. At first, you
might even want to skip Chapter 3, which covers Rust features similar to those
of other programming languages, and head straight to Chapter 4 to learn about
Rust’s ownership system. However, if you’re a particularly meticulous learner
who prefers to learn every detail before moving on to the next, you might want
to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when
you’d like to work on a project applying the details you’ve learned.
-->
<p>Le chapitre 1 explique comment installer Rust, comment écrire un programme
&quot;Hello, world!&quot; et comment utiliser Cargo, le gestionnaire de paquets et outil
de compilation. Le chapitre 2 est une initiation pratique au langage Rust. Nous
y aborderons des concepts de haut-niveau, et les chapitres suivants apporteront
plus de détails. Si vous voulez vous <em>salir les mains</em> tout de suite,
le chapitre 2 est l'endroit pour cela. Au début, vous pouvez même sauter le
chapitre 3, qui aborde les fonctionnalités de Rust semblables aux autres
langages de programmation, et passer directement au chapitre 4 pour en savoir
plus sur le système de possession <em>(ownership)</em> de Rust. Toutefois, si vous êtes
un apprenti particulièrement minutieux qui préfère apprendre chaque
particularité avant de passer à la suivante, vous pouvez sauter le chapitre 2 et
passer directement au chapitre 3, puis revenir au chapitre 2 lorsque vous
souhaitez travailler sur un projet en appliquant les notions que vous avez
apprises.</p>
<!--
Chapter 5 discusses structs and methods, and Chapter 6 covers enums, `match`
expressions, and the `if let` control flow construct. You’ll use structs and
enums to make custom types in Rust.
-->
<p>Le chapitre 5 traite des structures et des méthodes, et le chapitre 6 couvre les
énumérations, les expressions <code>match</code>, et la structure de contrôle <code>if let</code>.
Vous emploierez les structures et les énumérations pour créer des types
personnalisés avec Rust.</p>
<!--
In Chapter 7, you’ll learn about Rust’s module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rust’s error-handling philosophy and techniques.
-->
<p>Au chapitre 7, vous apprendrez le système de modules de Rust et les règles de
visibilité, afin d'organiser votre code et son interface de programmation
applicative (API) publique. Le chapitre 8 traitera des structures de collections
de données usuelles fournies par la bibliothèque standard, comme les vecteurs,
les chaînes de caractères et les tables de hachage <em>(hash maps)</em>. Le chapitre 9
explorera la philosophie et les techniques de gestion d'erreurs de Rust.</p>
<!--
Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rust’s safety guarantees is necessary to ensure your program’s
logic is correct. In Chapter 12, we’ll build our own implementation of a subset
of functionality from the `grep` command line tool that searches for text
within files. For this, we’ll use many of the concepts we discussed in the
previous chapters.
-->
<p>Le chapitre 10 nous plongera dans la généricité, les <em>traits</em> et
les durées de vie, qui vous donneront la capacité de créer du code qui s'adapte
à différents types. Le chapitre 11 traitera des techniques de test, qui restent
nécessaires malgré les garanties de sécurité de Rust, pour s'assurer que
la logique de votre programme est valide. Au chapitre 12, nous écrirons
notre propre implémentation d'un sous-ensemble des fonctionnalités du programme
en ligne de commande <code>grep</code>, qui recherche du texte dans des fichiers.
Pour ce faire, nous utiliserons de nombreuses notions abordées dans les
chapitres précédents.</p>
<!--
Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, we’ll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.
-->
<p>Le chapitre 13 explorera les fermetures <em>(closures)</em> et itérateurs : ce sont les
fonctionnalités de Rust inspirées des langages de programmation fonctionnels.
Au chapitre 14, nous explorerons plus en profondeur Cargo et les bonnes
pratiques pour partager vos propres bibliothèques avec les autres. Le chapitre
15 parlera de pointeurs intelligents qu'apporte la bibliothèque standard et des
<em>traits</em> qui activent leurs fonctionnalités.</p>
<!--
In Chapter 16, we’ll walk through different models of concurrent programming
and talk about how Rust helps you to program in multiple threads fearlessly.
Chapter 17 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with.
-->
<p>Au chapitre 16, nous passerons en revue les différents modes de programmation
concurrente et comment Rust nous aide à développer dans des processus parallèles
sans crainte. Le chapitre 17 comparera les fonctionnalités de Rust aux
principes de programmation orientée objet, que vous connaissez peut-être.</p>
<!--
Chapter 18 is a reference on patterns and pattern matching, which are powerful
ways of expressing ideas throughout Rust programs. Chapter 19 contains a
smorgasbord of advanced topics of interest, including unsafe Rust, macros, and
more about lifetimes, traits, types, functions, and closures.
-->
<p>Le chapitre 18 est une référence sur les motifs et le filtrage de motif
<em>(pattern matching)</em>, qui sont des moyens puissants permettant de communiquer
des idées dans les programmes Rust. Le chapitre 19 contient une foultitude de
sujets avancés intéressants, comme le code Rust non sécurisé <em>(unsafe)</em>, les
macros et plus de détails sur les durées de vie, les <em>traits</em>, les types, les
fonctions et les fermetures <em>(closures)</em>.</p>
<!--
In Chapter 20, we’ll complete a project in which we’ll implement a low-level
multithreaded web server!
-->
<p>Au chapitre 20, nous terminerons un projet dans lequel nous allons
implémenter en bas-niveau un serveur web multi-processus !</p>
<!--
Finally, some appendixes contain useful information about the language in a
more reference-like format. Appendix A covers Rust’s keywords, Appendix B
covers Rust’s operators and symbols, Appendix C covers derivable traits
provided by the standard library, Appendix D covers some useful development
tools, and Appendix E explains Rust editions.
-->
<p>Et finalement, quelques annexes qui contiennent des informations utiles sur le
langage sous forme de référentiels qui renvoient à d'autres documents. L'annexe
A liste les mots-clés de Rust, l'annexe B couvre les opérateurs et symboles de
Rust, l'annexe C parle des <em>traits</em> dérivables qu'apporte la bibliothèque
standard, l'annexe D référence certains outils de développement utiles, et
l'annexe E explique les différentes éditions de Rust.</p>
<!--
There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.
-->
<p>Il n'y a pas de mauvaise manière de lire ce livre : si vous voulez sauter des
étapes, allez-y !
Vous devrez alors peut-être revenir sur les chapitres précédents si vous
éprouvez des difficultés. Mais faites comme bon vous semble.</p>
<p><span id="ferris"></span></p>
<!--
An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we’ll provide many examples that don’t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you’re trying to run is meant to
error. Ferris will also help you distinguish code that isn’t meant to work:
-->
<p>Une composante importante du processus d'apprentissage de Rust est de comprendre
comment lire les messages d'erreur qu'affiche le compilateur : ils vous
guideront vers du code correct.
Ainsi, nous citerons de nombreux exemples qui ne compilent pas, avec le message
d'erreur que le compilateur devrait vous afficher dans chaque cas. C'est donc
normal que dans certains cas, si vous copiez et exécutez un exemple au hasard,
il ne compile pas ! Assurez-vous d'avoir lu le texte autour pour savoir si
l'exemple que vous tentez de compiler doit échouer. Ferris va aussi vous aider
à identifier du code qui ne devrait pas fonctionner :</p>
<!-- markdownlint-disable -->
<!--
| Ferris                                                                 | Meaning                                          |
|------------------------------------------------------------------------|--------------------------------------------------|
| <img src="img/ferris/does_not_compile.svg" class="ferris-explain"/>    | This code does not compile!                      |
| <img src="img/ferris/panics.svg" class="ferris-explain"/>              | This code panics!                                |
| <img src="img/ferris/unsafe.svg" class="ferris-explain"/>              | This code block contains unsafe code.            |
| <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/>| This code does not produce the desired behavior. |
-->
<!-- markdownlint-restore -->
<table><thead><tr><th>Ferris</th><th>Signification</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>Ce code ne compile pas !</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>Ce code panique !</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>Ce bloc de code contient du code non sécurisé.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>Ce code ne se comporte pas comme voulu.</td></tr>
</tbody></table>
<!--
In most situations, we’ll lead you to the correct version of any code that
doesn’t compile.
-->
<p>Dans la plupart des cas, nous vous guiderons vers la version du code qui devrait
fonctionner.</p>
<!--
## Source Code
-->
<h2><a class="header" href="#code-source" id="code-source">Code source</a></h2>
<!--
The source files from which this book is generated can be found on
[GitHub][book].
-->
<p>Les fichiers du code source qui a généré ce livre en anglais sont disponibles
sur <a href="https://github.com/rust-lang/book/tree/master/src">GitHub</a>.</p>
<p>La version française est aussi disponible sur <a href="https://github.com/Jimskapt/rust-book-fr">GitHub</a>.</p>
<h1><a class="header" href="#traduction-des-termes" id="traduction-des-termes">Traduction des termes</a></h1>
<p>Voici les principaux termes techniques qui ont été traduits de l'anglais vers le
français.</p>
<table><thead><tr><th>Anglais</th><th>Français</th><th>Remarques</th></tr></thead><tbody>
<tr><td>ahead-of-time compilation</td><td>compilation anticipée</td><td>sigle : AOT</td></tr>
<tr><td>allocated</td><td>alloué</td><td>-</td></tr>
<tr><td>annotate</td><td>indiquer</td><td>-</td></tr>
<tr><td>Appendix</td><td>annexe</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>Application Programming Interface (API)</td><td>interface de programmation applicative (API)</td><td>-</td></tr>
<tr><td>assign</td><td>assigner</td><td>-</td></tr>
<tr><td>argument</td><td>argument / paramètre</td><td>-</td></tr>
<tr><td>arm</td><td>branche</td><td>dans une expression <code>match</code></td></tr>
<tr><td>array</td><td>tableau</td><td>-</td></tr>
<tr><td>artifact</td><td>artéfact</td><td>-</td></tr>
<tr><td>associated function</td><td>fonction associée</td><td>-</td></tr>
<tr><td>attributes</td><td>attributs</td><td>-</td></tr>
<tr><td>binary crate</td><td>crate binaire</td><td>s'utilise au féminin</td></tr>
<tr><td><em>n</em>-bit number</td><td>nombre encodé sur <em>n</em> bits</td><td>-</td></tr>
<tr><td>blob</td><td>blob</td><td>-</td></tr>
<tr><td>boilerplate code</td><td>code standard</td><td>-</td></tr>
<tr><td>boolean</td><td>booléen</td><td>-</td></tr>
<tr><td>borrow</td><td>emprunt(er)</td><td>-</td></tr>
<tr><td>bug</td><td>bogue</td><td>-</td></tr>
<tr><td>build system</td><td>système de compilation</td><td>-</td></tr>
<tr><td>byte</td><td>octet</td><td>-</td></tr>
<tr><td>Cargo</td><td>Cargo</td><td>-</td></tr>
<tr><td>catchall value</td><td>valeur passe-partout</td><td>-</td></tr>
<tr><td>Chapter</td><td>chapitre</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>closure</td><td>fermeture</td><td>-</td></tr>
<tr><td>code review</td><td>revue de code</td><td>-</td></tr>
<tr><td>collection</td><td>collection</td><td>-</td></tr>
<tr><td>command</td><td>commande</td><td>dans un terminal</td></tr>
<tr><td>commit</td><td>commit</td><td>-</td></tr>
<tr><td>compound</td><td>composé</td><td>-</td></tr>
<tr><td>concept chapter</td><td>chapitre théorique</td><td>-</td></tr>
<tr><td>concurrency</td><td>concurrence</td><td>-</td></tr>
<tr><td>concurrent</td><td>concurrent</td><td>-</td></tr>
<tr><td>conditional</td><td>structure conditionnelle</td><td>-</td></tr>
<tr><td>constant</td><td>constant / constante</td><td>-</td></tr>
<tr><td>construct</td><td>instruction</td><td>-</td></tr>
<tr><td>control flow construct</td><td>structure de contrôle</td><td>-</td></tr>
<tr><td>core of the error</td><td>message d'erreur</td><td>-</td></tr>
<tr><td>corruption</td><td>corruption / être corrompu</td><td>-</td></tr>
<tr><td>CPU</td><td>processeur</td><td>-</td></tr>
<tr><td>crash</td><td>plantage</td><td>-</td></tr>
<tr><td>crate</td><td>crate</td><td>nom féminin (une <em>crate</em>)</td></tr>
<tr><td>curly bracket</td><td>accolade</td><td>-</td></tr>
<tr><td>dangling</td><td>pendouillant</td><td>-</td></tr>
<tr><td>data race</td><td>accès concurrent</td><td>-</td></tr>
<tr><td>data representation</td><td>modèle de données</td><td>-</td></tr>
<tr><td>deallocate</td><td>désalloué</td><td>-</td></tr>
<tr><td>debug</td><td>déboguer</td><td>-</td></tr>
<tr><td>debugging</td><td>débogage</td><td>-</td></tr>
<tr><td>deep copy</td><td>copie en profondeur</td><td>-</td></tr>
<tr><td>dependency</td><td>dépendance</td><td>-</td></tr>
<tr><td>dereferencing</td><td>déréférencement</td><td>-</td></tr>
<tr><td>destructure</td><td>déstructurer</td><td>-</td></tr>
<tr><td>DevOps</td><td>DevOps</td><td>-</td></tr>
<tr><td>directory</td><td>dossier</td><td>-</td></tr>
<tr><td>dot notation</td><td>la notation avec un point</td><td>-</td></tr>
<tr><td>double free</td><td>double libération</td><td>-</td></tr>
<tr><td>enum</td><td>énumération</td><td>-</td></tr>
<tr><td>enumeration</td><td>énumération</td><td>-</td></tr>
<tr><td>enum’s variant</td><td>variante d'énumération</td><td>-</td></tr>
<tr><td>exploit</td><td>faille</td><td>-</td></tr>
<tr><td>expression</td><td>expression</td><td>-</td></tr>
<tr><td>field</td><td>champ</td><td>d'une structure</td></tr>
<tr><td>Figure</td><td>Illustration</td><td>-</td></tr>
<tr><td>flag</td><td>drapeau</td><td>pour les programmes en ligne de commande</td></tr>
<tr><td>float</td><td>nombre à virgule flottante</td><td>-</td></tr>
<tr><td>floating-point number</td><td>nombre à virgule flottante</td><td>-</td></tr>
<tr><td>function</td><td>fonction</td><td>-</td></tr>
<tr><td>functional programming</td><td>programmation fonctionnelle</td><td>-</td></tr>
<tr><td>garbage collector</td><td>ramasse-miettes</td><td>-</td></tr>
<tr><td>generics</td><td>génériques / généricité</td><td>-</td></tr>
<tr><td>generic type parameter</td><td>paramètre de type générique</td><td>-</td></tr>
<tr><td>global scope</td><td>portée globale</td><td>-</td></tr>
<tr><td>guessing game</td><td>jeu de devinettes</td><td>-</td></tr>
<tr><td>handle</td><td>référence abstraite</td><td>-</td></tr>
<tr><td>hash</td><td>hash / relatif au hachage</td><td>-</td></tr>
<tr><td>hash map</td><td>table de hachage</td><td>-</td></tr>
<tr><td>heap</td><td>tas</td><td>-</td></tr>
<tr><td>Hello, world!</td><td>Hello, world!</td><td>-</td></tr>
<tr><td>high-level</td><td>haut niveau</td><td>-</td></tr>
<tr><td>identifier</td><td>identificateur</td><td>-</td></tr>
<tr><td>immutability</td><td>immuabilité</td><td>-</td></tr>
<tr><td>immutable</td><td>immuable</td><td>-</td></tr>
<tr><td>index</td><td>indice</td><td>-</td></tr>
<tr><td>indexing</td><td>indexation</td><td>-</td></tr>
<tr><td>input/output</td><td>entrée/sortie</td><td>sigle : IO</td></tr>
<tr><td>instance</td><td>instance</td><td>-</td></tr>
<tr><td>instantiate</td><td>instancier</td><td>créer une instance</td></tr>
<tr><td>integer literal</td><td>littéral d'entiers</td><td>-</td></tr>
<tr><td>integer overflow</td><td>dépassement d'entier</td><td>-</td></tr>
<tr><td>Integrated Development Environment (IDE)</td><td>environnement de développement intégré (IDE)</td><td>-</td></tr>
<tr><td>interrupt signal</td><td>signal d'arrêt</td><td>-</td></tr>
<tr><td>invalidate</td><td>neutraliser</td><td>-</td></tr>
<tr><td>IOT</td><td>internet des objets (IOT)</td><td>-</td></tr>
<tr><td>iterator</td><td>itérateur</td><td>-</td></tr>
<tr><td>just-in-time compilation</td><td>compilation à la volée</td><td>sigle : JIT</td></tr>
<tr><td>keyword</td><td>mot-clé</td><td>-</td></tr>
<tr><td>legacy code</td><td>code instable que le programme a hérité avec le temps</td><td>-</td></tr>
<tr><td>library</td><td>bibliothèque</td><td>-</td></tr>
<tr><td>library crate</td><td>crate de bibliothèque</td><td>s'utilise au féminin</td></tr>
<tr><td>lifetime</td><td>durée de vie</td><td>-</td></tr>
<tr><td>linker</td><td>linker</td><td>-</td></tr>
<tr><td>literal value</td><td>valeur litérale</td><td>-</td></tr>
<tr><td>Listing</td><td>encart</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>loop</td><td>boucle</td><td>-</td></tr>
<tr><td>low-level</td><td>bas niveau</td><td>-</td></tr>
<tr><td>machine learning</td><td>apprentissage automatique</td><td>-</td></tr>
<tr><td>macro</td><td>macro</td><td>-</td></tr>
<tr><td>main</td><td>main</td><td>-</td></tr>
<tr><td>memory management</td><td>gestion de mémoire</td><td>-</td></tr>
<tr><td>method</td><td>méthode</td><td>-</td></tr>
<tr><td>modern</td><td>récent</td><td>-</td></tr>
<tr><td>module</td><td>module</td><td>-</td></tr>
<tr><td>module system</td><td>système de modules</td><td>-</td></tr>
<tr><td>move</td><td>déplacement</td><td>-</td></tr>
<tr><td>mutability</td><td>mutabilité</td><td>-</td></tr>
<tr><td>mutable</td><td>mutable</td><td>modifiable</td></tr>
<tr><td>mutate</td><td>muter</td><td>-</td></tr>
<tr><td>namespace</td><td>espace de nom</td><td>-</td></tr>
<tr><td>Note</td><td>remarque</td><td>tout en minuscule (sauf en début de phrase)</td></tr>
<tr><td>numerical characters</td><td>chiffres</td><td>-</td></tr>
<tr><td>object-oriented language</td><td>langage orienté objet</td><td>-</td></tr>
<tr><td>operating system</td><td>système d'exploitation</td><td>-</td></tr>
<tr><td>owner</td><td>propriétaire</td><td>-</td></tr>
<tr><td>ownership</td><td>possession</td><td>-</td></tr>
<tr><td>package manager</td><td>système de gestion de paquets</td><td>-</td></tr>
<tr><td>panic</td><td>panique(r)</td><td>-</td></tr>
<tr><td>parallelism</td><td>parallélisme</td><td>-</td></tr>
<tr><td>parameter</td><td>paramètre</td><td>-</td></tr>
<tr><td>PATH</td><td>PATH</td><td>-</td></tr>
<tr><td>pattern</td><td>motif</td><td>-</td></tr>
<tr><td>pattern-matching</td><td>filtrage par motif</td><td>-</td></tr>
<tr><td>placeholder</td><td>espace réservé</td><td><code>{}</code> pour <code>fmt</code></td></tr>
<tr><td>pointer</td><td>pointeur</td><td>-</td></tr>
<tr><td>popping off the stack</td><td>dépiler</td><td>-</td></tr>
<tr><td>prelude</td><td>étape préliminaire</td><td>-</td></tr>
<tr><td>privacy</td><td>protection</td><td>explication de la protection des éléments d'un module</td></tr>
<tr><td>procedural macro</td><td>macro procédurale</td><td>-</td></tr>
<tr><td>project chapter</td><td>chapitre de projet</td><td>-</td></tr>
<tr><td>race condition</td><td>situation de concurrence</td><td>-</td></tr>
<tr><td>pushing onto the stack</td><td>empiler</td><td>-</td></tr>
<tr><td>raw identifier</td><td>identificateur brut</td><td>-</td></tr>
<tr><td>README</td><td>README</td><td>-</td></tr>
<tr><td>refactoring</td><td>remaniement</td><td>-</td></tr>
<tr><td>reference</td><td>référence</td><td>-</td></tr>
<tr><td>registry</td><td>registre</td><td>-</td></tr>
<tr><td>regression</td><td>régression</td><td>-</td></tr>
<tr><td>remainder</td><td>modulo</td><td>opération <code>%</code></td></tr>
<tr><td>reproducible build</td><td>compilation reproductible</td><td>-</td></tr>
<tr><td>Resource Acquisition Is Initialization (RAII)</td><td>l'acquisition d'une ressource est une initialisation (RAII)</td><td>-</td></tr>
<tr><td>return</td><td>retourner</td><td>-</td></tr>
<tr><td>run</td><td>exécuter</td><td>pour les programmes</td></tr>
<tr><td>Rustacean</td><td>Rustacé</td><td>-</td></tr>
<tr><td>section header</td><td>entête de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version sémantique</td><td>-</td></tr>
<tr><td>scalar</td><td>scalaire</td><td>-</td></tr>
<tr><td>scope</td><td>portée</td><td>-</td></tr>
<tr><td>script</td><td>script</td><td>-</td></tr>
<tr><td>section header</td><td>en-tête de section</td><td>-</td></tr>
<tr><td>semantic version</td><td>version sémantique</td><td>-</td></tr>
<tr><td>semantic versioning</td><td>versionnage sémantique</td><td>abréviation : SemVer</td></tr>
<tr><td>shadow</td><td>masquer</td><td>remplacer une variable par une autre de même nom</td></tr>
<tr><td>shadowing</td><td>masquage</td><td>-</td></tr>
<tr><td>shallow copy</td><td>copie superficielle</td><td>-</td></tr>
<tr><td>shell</td><td>terminal / invite de commande</td><td>-</td></tr>
<tr><td>shorthand</td><td>abréviation</td><td>-</td></tr>
<tr><td>sidebar</td><td>volet latéral</td><td>-</td></tr>
<tr><td>signature</td><td>signature</td><td>d'une fonction</td></tr>
<tr><td>signed</td><td>signé</td><td>-</td></tr>
<tr><td>slash</td><td>barre oblique</td><td>-</td></tr>
<tr><td>slice</td><td>slice</td><td>-</td></tr>
<tr><td>smart pointer</td><td>pointeur intelligent</td><td>-</td></tr>
<tr><td>snake case</td><td>snake case</td><td>-</td></tr>
<tr><td>snip</td><td>partie masquée ici</td><td>dans un encart</td></tr>
<tr><td>space</td><td>espace</td><td>ce mot est féminin quand on parle du caractère typographique</td></tr>
<tr><td>square brackets</td><td>crochets</td><td>-</td></tr>
<tr><td>stack</td><td>pile</td><td>-</td></tr>
<tr><td>standard</td><td>standard <em>(adj. inv.)</em> / norme <em>(n.f.)</em></td><td>-</td></tr>
<tr><td>standard error</td><td>erreur standard</td><td>-</td></tr>
<tr><td>standard input</td><td>entrée standard</td><td>-</td></tr>
<tr><td>standard library</td><td>bibliothèque standard</td><td>-</td></tr>
<tr><td>standard output</td><td>sortie standard</td><td>-</td></tr>
<tr><td>statement</td><td>instruction</td><td>-</td></tr>
<tr><td>statically typed</td><td>statiquement typé</td><td>-</td></tr>
<tr><td>string</td><td>chaîne de caractères</td><td>-</td></tr>
<tr><td>string literal</td><td>un littéral de chaîne de caractères</td><td>-</td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td>nom féminin (une <code>String</code>)</td></tr>
<tr><td>struct</td><td>structure</td><td>-</td></tr>
<tr><td>submodule</td><td>sous-module</td><td>-</td></tr>
<tr><td>syntax sugar</td><td>sucre syntaxique</td><td>-</td></tr>
<tr><td>systems concept</td><td>notion système</td><td>-</td></tr>
<tr><td>systems-level</td><td>niveau système</td><td>-</td></tr>
<tr><td>systems-level code</td><td>code système</td><td>-</td></tr>
<tr><td>terminal</td><td>terminal</td><td>-</td></tr>
<tr><td>trait</td><td>trait</td><td>-</td></tr>
<tr><td>tree</td><td>arborescence</td><td>-</td></tr>
<tr><td>troubleshooting</td><td>dépannage</td><td>-</td></tr>
<tr><td>tuple</td><td>tuple</td><td>-</td></tr>
<tr><td>tuple struct</td><td>structure tuple</td><td>-</td></tr>
<tr><td>type</td><td>type</td><td>-</td></tr>
<tr><td>type annotation</td><td>annotation de type</td><td>-</td></tr>
<tr><td>type inference</td><td>inférence de types</td><td>-</td></tr>
<tr><td>two’s complement</td><td>complément à deux</td><td>-</td></tr>
<tr><td>two’s complement wrapping</td><td>rebouclage du complément à deux</td><td>-</td></tr>
<tr><td>underlying operating system</td><td>système d'exploitation sous-jacent</td><td>-</td></tr>
<tr><td>underscore</td><td>tiret bas</td><td>le caractère <code>_</code></td></tr>
<tr><td>unit-like struct</td><td>structure unité</td><td>-</td></tr>
<tr><td>unit type</td><td>type unité</td><td>-</td></tr>
<tr><td>unit value</td><td>valeur unité</td><td>-</td></tr>
<tr><td>unsafe</td><td>non sécurisé</td><td>-</td></tr>
<tr><td>unsigned</td><td>sans signe (toujours positif)</td><td>-</td></tr>
<tr><td>unsigned</td><td>non signé</td><td>-</td></tr>
<tr><td>user input</td><td>saisie utilisateur</td><td>-</td></tr>
<tr><td>variable</td><td>variable</td><td>-</td></tr>
<tr><td>variant</td><td>variante</td><td>d'une énumération</td></tr>
<tr><td>vector</td><td>vecteur</td><td>-</td></tr>
<tr><td>version control system (VCS)</td><td>système de gestion de versions (VCS)</td><td>-</td></tr>
<tr><td>warning</td><td>avertissement</td><td>-</td></tr>
<tr><td>wildcard</td><td>joker</td><td>-</td></tr>
<tr><td>zero-cost abstraction</td><td>abstraction sans coût</td><td>-</td></tr>
</tbody></table>
<!--
# Getting Started
-->
<h1><a class="header" href="#prise-en-main" id="prise-en-main">Prise en main</a></h1>
<!--
Let’s start your Rust journey! There’s a lot to learn, but every journey starts
somewhere. In this chapter, we’ll discuss:
-->
<p>Démarrons notre périple avec Rust ! Il y a beaucoup à apprendre, mais chaque
aventure doit commencer quelque part. Dans ce chapitre, nous allons aborder :</p>
<!--
* Installing Rust on Linux, macOS, and Windows
* Writing a program that prints `Hello, world!`
* Using `cargo`, Rust’s package manager and build system
-->
<ul>
<li>L'installation de Rust sur Linux, macOS et Windows</li>
<li>L'écriture d'un programme qui affiche <code>Hello, world!</code></li>
<li>L'utilisation de <code>cargo</code>, le gestionnaire de paquets et système de compilation
de Rust</li>
</ul>
<!--
## Installation
-->
<h2><a class="header" href="#installation" id="installation">Installation</a></h2>
<!--
The first step is to install Rust. We’ll download Rust through `rustup`, a
command line tool for managing Rust versions and associated tools. You’ll need
an internet connection for the download.
-->
<p>La première étape consiste à installer Rust. Nous allons télécharger Rust via
<code>rustup</code>, un outil en ligne de commande conçu pour gérer les versions de Rust et
les outils qui leur sont associés. Vous allez avoir besoin d'une connexion
Internet pour le téléchargement.</p>
<!--
> Note: If you prefer not to use `rustup` for some reason, please see [the Rust
> installation page](https://www.rust-lang.org/tools/install) for other options.
-->
<blockquote>
<p>Note : si vous préférez ne pas utiliser <code>rustup</code> pour une raison ou une autre,
vous pouvez vous référer à
<a href="https://www.rust-lang.org/tools/install">la page d'installation de Rust</a>
pour d'autres méthodes d'installation.</p>
</blockquote>
<!--
The following steps install the latest stable version of the Rust compiler.
Rust’s stability guarantees ensure that all the examples in the book that
compile will continue to compile with newer Rust versions. The output might
differ slightly between versions, because Rust often improves error messages
and warnings. In other words, any newer, stable version of Rust you install
using these steps should work as expected with the content of this book.
-->
<p>L'étape suivante est d'installer la dernière version stable du compilateur Rust.
La garantie de stabilité de Rust assurera que tous les exemples dans le livre
qui se compilent bien vont continuer à se compiler avec les nouvelles versions
de Rust. La sortie peut varier légèrement d'une version à une autre, car Rust
améliore souvent les messages d'erreur et les avertissements. En résumé, toute
nouvelle version stable de Rust que vous installez de cette manière devrait
fonctionner en cohérence avec le contenu de ce livre.</p>
<!--
> ### Command Line Notation
>
> In this chapter and throughout the book, we’ll show some commands used in the
> terminal. Lines that you should enter in a terminal all start with `$`. You
> don’t need to type in the `$` character; it indicates the start of each
> command. Lines that don’t start with `$` typically show the output of the
> previous command. Additionally, PowerShell-specific examples will use `>`
> rather than `$`.
-->
<blockquote>
<h3><a class="header" href="#la-notation-en-ligne-de-commande" id="la-notation-en-ligne-de-commande">La notation en ligne de commande</a></h3>
<p>Dans ce chapitre et les suivants dans le livre, nous allons montrer quelques
commandes tapées dans le terminal. Les lignes que vous devrez écrire dans le
terminal commencent toutes par <code>$</code>. Vous n'avez pas besoin d'écrire le
caractère <code>$</code>; il marque le début de chaque commande. Les lignes qui ne
commencent pas par <code>$</code> montrent généralement le résultat de la commande
précédente. De plus, les exemples propres à PowerShell utiliseront
<code>&gt;</code> plutôt que <code>$</code>.</p>
</blockquote>
<!--
### Installing `rustup` on Linux or macOS
-->
<h3><a class="header" href="#installer-rustup-sur-linux-ou-macos" id="installer-rustup-sur-linux-ou-macos">Installer <code>rustup</code> sur Linux ou macOS</a></h3>
<!--
If you’re using Linux or macOS, open a terminal and enter the following command:
-->
<p>Si vous utilisez Linux ou macOS, ouvrez un terminal et écrivez la commande
suivante :</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<!--
The command downloads a script and starts the installation of the `rustup`
tool, which installs the latest stable version of Rust. You might be prompted
for your password. If the install is successful, the following line will appear:
-->
<p>Cette commande télécharge un script et lance l'installation de l'outil <code>rustup</code>,
qui va installer la dernière version stable de Rust. Il est possible que l'on
vous demande votre mot de passe. Si l'installation se déroule bien, vous
devriez voir la ligne suivante s'afficher :</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<!--
If you prefer, feel free to download the script and inspect it before running
it.
-->
<p>Si vous préférez, vous pouvez télécharger le script et l'examiner avant de le
lancer.</p>
<!--
The installation script automatically adds Rust to your system PATH after your
next login. If you want to start using Rust right away instead of restarting
your terminal, run the following command in your shell to add Rust to your
system PATH manually:
-->
<p>Le script d'installation va ajouter automatiquement Rust dans la variable
<em>PATH</em> de votre système après votre prochaine connexion utilisateur.
Si vous préférez utiliser Rust tout de suite au lieu de redémarrer votre
terminal, lancez la commande suivante dans votre terminal pour ajouter Rust dans
le <em>PATH</em> de votre système manuellement :</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<!--
Alternatively, you can add the following line to your *~/.bash_profile*:
-->
<p>Vous pouvez aussi ajouter la ligne suivante dans votre <em>~/.bash_profile</em> :</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<!--
Additionally, you’ll need a linker of some kind. It’s likely one is already
installed, but when you try to compile a Rust program and get errors indicating
that a linker could not execute, that means a linker isn’t installed on your
system and you’ll need to install one manually. C compilers usually come with
the correct linker. Check your platform’s documentation for how to install a C
compiler. Also, some common Rust packages depend on C code and will need a C
compiler. Therefore, it might be worth installing one now.
-->
<p>De plus, vous aurez peut-être besoin d'un <em>linker</em> quelconque. Il est probable
qu'il y en ait déjà un d'installé, mais si vous essayez de compiler un
programme Rust et que vous avez des erreurs qui disent que le <em>linker</em> ne peut
pas être exécuté, cela veut dire qu'il n'y a pas de <em>linker</em> d'installé sur
votre système et que vous devrez en installer un manuellement. Les
compilateurs C sont généralement livrés avec un bon <em>linker</em>. Référez-vous à la
documentation de votre plateforme pour savoir comment installer un compilateur
C. De plus, certains paquets Rust communs nécessitent du code C et auront
besoin d'un compilateur C. C'est pourquoi cela vaut la peine d'en installer un
dès maintenant.</p>
<!--
### Installing `rustup` on Windows
-->
<h3><a class="header" href="#installer-rustup-sous-windows" id="installer-rustup-sous-windows">Installer <code>rustup</code> sous Windows</a></h3>
<!--
On Windows, go to [https://www.rust-lang.org/tools/install][install] and follow
the instructions for installing Rust. At some point in the installation, you’ll
receive a message explaining that you’ll also need the C++ build tools for
Visual Studio 2013 or later. The easiest way to acquire the build tools is to
install [Build Tools for Visual Studio 2019][visualstudio]. The tools are in
the Other Tools and Frameworks section.
-->
<p>Sous Windows, il faut aller sur
<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> et suivre les instructions
pour installer Rust. À un moment donné durant l'installation, vous aurez un
message vous expliquant qu'il va vous falloir l'outil de compilation C++
pour Visual Studio 2013 ou plus récent. La méthode la plus facile pour obtenir
les outils de compilation est d'installer
<a href="https://www.visualstudio.com/fr/downloads/#build-tools-for-visual-studio-2019">Build Tools pour Visual Studio 2019</a>.</p>
<!-- markdownlint-disable -->
<!--
[install]: https://www.rust-lang.org/tools/install
[visualstudio]: https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019
FR translation: the website redirects to French version, we lose the "id" link.
Fix is directly below:
-->
<!-- markdownlint-restore -->
<!--
The rest of this book uses commands that work in both *cmd.exe* and PowerShell.
If there are specific differences, we’ll explain which to use.
-->
<p>La suite de ce livre utilisera des commandes qui fonctionnent à la fois dans
<em>cmd.exe</em> et PowerShell. S'il y a des différences particulières, nous vous
expliquerons lesquelles utiliser.</p>
<!--
### Updating and Uninstalling
-->
<h3><a class="header" href="#mettre-à-jour-et-désinstaller" id="mettre-à-jour-et-désinstaller">Mettre à jour et désinstaller</a></h3>
<!--
After you’ve installed Rust via `rustup`, updating to the latest version is
easy. From your shell, run the following update script:
-->
<p>Après avoir installé Rust avec <code>rustup</code>, la mise à jour vers la dernière version
est facile. Dans votre terminal, lancez le script de mise à jour suivant :</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<!--
To uninstall Rust and `rustup`, run the following uninstall script from your
shell:
-->
<p>Pour désinstaller Rust et <code>rustup</code>, exécutez le script de désinstallation
suivant dans votre terminal :</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<!--
### Troubleshooting
-->
<h3><a class="header" href="#dépannage" id="dépannage">Dépannage</a></h3>
<!--
To check whether you have Rust installed correctly, open a shell and enter this
line:
-->
<p>Pour vérifier si Rust est correctement installé, ouvrez un terminal et entrez
cette ligne :</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<!--
You should see the version number, commit hash, and commit date for the latest
stable version that has been released in the following format:
-->
<p>Vous devriez voir le numéro de version, le <em>hash</em> de <em>commit</em>,
et la date de <em>commit</em> de la dernière version stable qui a été publiée,
au format suivant :</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<!--
If you see this information, you have installed Rust successfully! If you don’t
see this information and you’re on Windows, check that Rust is in your `%PATH%`
system variable. If that’s all correct and Rust still isn’t working, there are
a number of places you can get help. The easiest is the #beginners channel on
[the official Rust Discord][discord]. There, you can chat with other Rustaceans
(a silly nickname we call ourselves) who can help you out. Other great
resources include [the Users forum][users] and [Stack Overflow][stackoverflow].
-->
<p>Si vous voyez cette information, c'est que vous avez installé Rust avec succès !
Si vous ne voyez pas cette information et que vous êtes sous Windows, vérifiez
que Rust est présent dans votre variable d'environnement système <code>%PATH%</code>. Si
tout est correct et que Rust ne fonctionne toujours pas, il y a quelques
endroits où vous pourrez trouver de l'aide. Le plus accessible est le
canal #beginners sur le <a href="https://discord.gg/rust-lang">Discord officiel de Rust</a>. Là-bas, vous pouvez
dialoguer en ligne avec d'autres <em>Rustacés</em> (un surnom ridicule que nous nous
donnons entre nous) qui pourront vous aider. D'autres bonnes sources de données
sont <a href="https://users.rust-lang.org/">le forum d'utilisateurs</a> et <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<!--
### Local Documentation
-->
<h3><a class="header" href="#documentation-en-local" id="documentation-en-local">Documentation en local</a></h3>
<!--
The installation of Rust also includes a copy of the documentation locally, so
you can read it offline. Run `rustup doc` to open the local documentation in
your browser.
-->
<p>L'installation de Rust embarque aussi une copie de la documentation en local
pour que vous puissiez la lire hors ligne. Lancez <code>rustup doc</code> afin d'ouvrir la
documentation locale dans votre navigateur.</p>
<!--
Any time a type or function is provided by the standard library and you’re not
sure what it does or how to use it, use the application programming interface
(API) documentation to find out!
-->
<p>À chaque fois que vous n'êtes pas sûr de ce que fait un type ou une fonction
fournie par la bibliothèque standard ou que vous ne savez pas comment
l'utiliser, utilisez cette documentation de l'interface de programmation
applicative <em>(API)</em> pour le savoir !</p>
<!--
## Hello, World!
-->
<h2><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h2>
<!--
Now that you’ve installed Rust, let’s write your first Rust program. It’s
traditional when learning a new language to write a little program that prints
the text `Hello, world!` to the screen, so we’ll do the same here!
-->
<p>Maintenant que vous avez installé Rust, écrivons notre premier programme Rust.
Lorsqu'on apprend un nouveau langage, il est de tradition d'écrire un petit
programme qui écrit le texte &quot;Hello, world!&quot; à l'écran, donc c'est ce que nous
allons faire !</p>
<!--
> Note: This book assumes basic familiarity with the command line. Rust makes
> no specific demands about your editing or tooling or where your code lives, so
> if you prefer to use an integrated development environment (IDE) instead of
> the command line, feel free to use your favorite IDE. Many IDEs now have some
> degree of Rust support; check the IDE’s documentation for details. Recently,
> the Rust team has been focusing on enabling great IDE support, and progress
> has been made rapidly on that front!
-->
<blockquote>
<p>Note : ce livre part du principe que vous êtes familier avec la ligne de
commande. Rust n'impose pas d'exigences sur votre éditeur, vos outils ou
l'endroit où vous mettez votre code, donc si vous préférez utiliser un
environnement de développement intégré (IDE) au lieu de la ligne de commande,
vous êtes libre d'utiliser votre IDE favori. De nombreux IDE prennent en
charge Rust à des degrés divers ; consultez la documentation de
l'IDE pour plus d'informations. Récemment, l'équipe Rust s'est attelée à
améliorer l'intégration dans les IDE et des progrès ont rapidement été faits
dans ce domaine !</p>
</blockquote>
<!--
### Creating a Project Directory
-->
<h3><a class="header" href="#créer-un-dossier-projet" id="créer-un-dossier-projet">Créer un dossier projet</a></h3>
<!--
You’ll start by making a directory to store your Rust code. It doesn’t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a *projects* directory in your home directory and keeping all
your projects there.
-->
<p>Nous allons commencer par créer un dossier pour y ranger le code Rust. Là où
vous mettez votre code n'est pas important pour Rust, mais pour les exercices et
projets de ce livre, nous vous suggérons de créer un dossier <em>projects</em> dans
votre dossier utilisateur et de ranger tous vos projets là-dedans.</p>
<!--
Open a terminal and enter the following commands to make a *projects* directory
and a directory for the “Hello, world!” project within the *projects* directory.
-->
<p>Ouvrez un terminal et écrivez les commandes suivantes pour créer un
dossier <em>projects</em> et un dossier pour le projet “Hello, world!” à l'intérieur
de ce dossier <em>projects</em>.</p>
<!--
For Linux, macOS, and PowerShell on Windows, enter this:
-->
<p>Sous Linux, macOS et PowerShell sous Windows, écrivez ceci :</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<!--
For Windows CMD, enter this:
-->
<p>Avec CMD sous Windows, écrivez ceci :</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!--
### Writing and Running a Rust Program
-->
<h3><a class="header" href="#Écrire-et-exécuter-un-programme-rust" id="Écrire-et-exécuter-un-programme-rust">Écrire et exécuter un programme Rust</a></h3>
<!--
Next, make a new source file and call it *main.rs*. Rust files always end with
the *.rs* extension. If you’re using more than one word in your filename, use
an underscore to separate them. For example, use *hello_world.rs* rather than
*helloworld.rs*.
-->
<p>Ensuite, créez un nouveau fichier source et appelez-le <em>main.rs</em>. Les fichiers
Rust se terminent toujours par l'extension <em>.rs</em>. Si vous utilisez plusieurs
mots dans votre nom de fichier, utilisez un tiret bas (<code>_</code>) pour
les séparer. Par exemple, vous devriez utiliser <em>hello_world.rs</em> au lieu de
<em>helloworld.rs</em>.</p>
<!--
Now open the *main.rs* file you just created and enter the code in Listing 1-1.
-->
<p>Maintenant, ouvrez le fichier <em>main.rs</em> que vous venez de créer et entrez le
code de l'encart 1-1.</p>
<!--
<span class="filename">Filename: main.rs</span>
-->
<p><span class="filename">Fichier : main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 1-1: A program that prints `Hello, world!`</span>
-->
<p><span class="caption">Encart 1-1 : Un programme qui affiche <code>Hello, world!</code>
</span></p>
<!--
Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:
-->
<p>Enregistrez le fichier et retournez dans votre terminal. Sur Linux
ou macOS, écrivez les commandes suivantes pour compiler et exécuter le fichier :</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<!--
On Windows, enter the command `.\main.exe` instead of `./main`:
-->
<p>Sur Windows, écrivez la commande <code>.\main.exe</code> à la place de <code>.\main</code> :</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<!--
Regardless of your operating system, the string `Hello, world!` should print to
the terminal. If you don’t see this output, refer back to the
[“Troubleshooting”][troubleshooting]<!-- ignore -- > part of the Installation
section for ways to get help.
-->
<p>Peu importe votre système d'exploitation, la chaîne de caractères
<code>Hello, world!</code> devrait s'écrire dans votre terminal. Si cela ne s'affiche pas,
référez-vous à la partie <a href="ch01-01-installation.html#troubleshooting">&quot;Dépannage&quot;</a><!-- ignore --> du
chapitre d'installation pour vous aider.</p>
<!--
If `Hello, world!` did print, congratulations! You’ve officially written a Rust
program. That makes you a Rust programmer—welcome!
-->
<p>Si <code>Hello, world!</code> s'affiche, félicitations ! Vous avez officiellement écrit un
programme Rust. Cela fait de vous un développeur Rust — bienvenue !</p>
<!--
### Anatomy of a Rust Program
-->
<h3><a class="header" href="#structure-dun-programme-rust" id="structure-dun-programme-rust">Structure d'un programme Rust</a></h3>
<!--
Let’s review in detail what just happened in your “Hello, world!” program.
Here’s the first piece of the puzzle:
-->
<p>Regardons en détail ce qui s'est passé dans votre programme “Hello, world!”.
Voici le premier morceau du puzzle :</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<!--
These lines define a function in Rust. The `main` function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named `main` that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, `()`.
-->
<p>Ces lignes définissent une fonction dans Rust. La fonction <code>main</code> est spéciale :
c'est toujours le premier code qui est exécuté dans tous les programmes
en Rust. La première ligne déclare une fonction qui s'appelle <code>main</code>, qui n'a
pas de paramètre et qui ne retourne aucune valeur. S'il y avait des paramètres,
ils seraient placés entre les parenthèses <code>()</code>.</p>
<!--
Also, note that the function body is wrapped in curly brackets, `{}`. Rust
requires these around all function bodies. It’s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.
-->
<p>À noter en outre que le corps de la fonction est placé entre des accolades
<code>{}</code>. Rust en a besoin autour du corps de chaque fonction. C'est une
bonne pratique d'insérer l'accolade ouvrante sur la même ligne que la
déclaration de la fonction, en ajoutant une espace entre les deux.</p>
<!--
At the time of this writing, an automatic formatter tool called `rustfmt` is
under development. If you want to stick to a standard style across Rust
projects, `rustfmt` will format your code in a particular style. The Rust team
plans to eventually include this tool with the standard Rust distribution, like
`rustc`. So depending on when you read this book, it might already be installed
on your computer! Check the online documentation for more details.
-->
<p>Pendant que nous écrivons ces lignes, un outil de formatage automatique de code
appelé <code>rustfmt</code> est en cours de développement.
Si vous voulez standardiser le style de votre code Rust dans vos projets,
<code>rustfmt</code> va formater votre code de manière bien définie.
L'équipe Rust envisage d'intégrer cet outil dans la distribution
standard de Rust, comme <code>rustc</code>. Donc, selon le moment où vous lirez ce livre,
il se peut qu'il soit déjà installé sur votre ordinateur ! Consultez la
documentation en ligne pour en savoir plus.</p>
<!--
Inside the `main` function is the following code:
-->
<p>À l'intérieur de la fonction <code>main</code>, nous avons le code suivant :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here. First, Rust style is
to indent with four spaces, not a tab.
-->
<p>Cette ligne fait tout le travail dans ce petit programme : il écrit le texte à
l'écran. Il y a quatre détails importants à noter ici. Premièrement, le style de
Rust est d'indenter avec quatre espaces, et non pas avec une tabulation.</p>
<!--
Second, `println!` calls a Rust macro. If it called a function instead, it
would be entered as `println` (without the `!`). We’ll discuss Rust macros in
more detail in Chapter 19. For now, you just need to know that using a `!`
means that you’re calling a macro instead of a normal function.
-->
<p>Deuxièmement, <code>println!</code> fait appel à une macro Rust. S'il appelait une
fonction à la place, cela serait écrit <code>println</code> (sans le <code>!</code>). Nous aborderons
les macros Rust plus en détail dans le chapitre 19. Pour l'instant, vous avez
juste à savoir qu'utiliser un <code>!</code> signifie que vous utilisez une macro plutôt
qu'une fonction classique.</p>
<!--
Third, you see the `"Hello, world!"` string. We pass this string as an argument
to `println!`, and the string is printed to the screen.
-->
<p>Troisièmement, vous voyez la chaîne de caractères <code>&quot;Hello, world!&quot;</code>. Nous
envoyons cette chaîne en argument à <code>println!</code> et cette chaîne est affichée
à l'écran.</p>
<!--
Fourth, we end the line with a semicolon (`;`), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon.
-->
<p>Quatrièmement, nous terminons la ligne avec un point-virgule (<code>;</code>), qui indique
que cette expression est terminée et que la suivante est prête à commencer. La
plupart des lignes de Rust se terminent avec un point-virgule.</p>
<!--
### Compiling and Running Are Separate Steps
-->
<h3><a class="header" href="#la-compilation-et-lexécution-sont-des-étapes-séparées" id="la-compilation-et-lexécution-sont-des-étapes-séparées">La compilation et l'exécution sont des étapes séparées</a></h3>
<!--
You’ve just run a newly created program, so let’s examine each step in the
process.
-->
<p>Vous venez de lancer un nouveau programme fraîchement créé, donc penchons-nous
sur chaque étape du processus.</p>
<!--
Before running a Rust program, you must compile it using the Rust compiler by
entering the `rustc` command and passing it the name of your source file, like
this:
-->
<p>Avant de lancer un programme Rust, vous devez le compiler en utilisant le
compilateur Rust en entrant la commande <code>rustc</code> et en lui passant le nom de
votre fichier source, comme ceci :</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<!--
If you have a C or C++ background, you’ll notice that this is similar to `gcc`
or `clang`. After compiling successfully, Rust outputs a binary executable.
-->
<p>Si vous avez de l'expérience en C ou en C++, vous observerez des similarités
avec <code>gcc</code> ou <code>clang</code>.
Après avoir compilé avec succès, Rust produit un binaire exécutable.</p>
<!--
On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the `ls` command in your shell. On Linux and macOS, you’ll see two
files. With PowerShell on Windows, you’ll see the same three files that you
would see using CMD.
-->
<p>Avec Linux, macOS et PowerShell sous Windows, vous pouvez voir l'exécutable en
utilisant la commande <code>ls</code> dans votre terminal. Avec Linux et macOS,
vous devriez voir deux fichiers. Avec PowerShell sous Windows, vous devriez voir
les trois mêmes fichiers que vous verriez en utilisant CMD.</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<!--
With CMD on Windows, you would enter the following:
-->
<p>Avec CMD sous Windows, vous devez saisir la commande suivante :</p>
<!--
```cmd
> dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
```
-->
<pre><code class="language-cmd">&gt; dir /B %= l'option /B demande à n'afficher que les noms de fichiers =%
main.exe
main.pdb
main.rs
</code></pre>
<!--
This shows the source code file with the *.rs* extension, the executable file
(*main.exe* on Windows, but *main* on all other platforms), and, when using
Windows, a file containing debugging information with the *.pdb* extension.
From here, you run the *main* or *main.exe* file, like this:
-->
<p>Ceci affiche le fichier de code source avec l'extension <em>.rs</em>, le fichier
exécutable (<em>main.exe</em> sous Windows, mais <em>main</em> sur toutes les autres
plateformes) et, quand on utilise Windows, un fichier qui contient des
informations de débogage avec l'extension <em>.pdb</em>. Dans ce dossier, vous pouvez
exécuter le fichier <em>main</em> ou <em>main.exe</em> comme ceci :</p>
<!--
```text
$ ./main # or .\main.exe on Windows
```
-->
<pre><code class="language-text">$ ./main # ou .\main.exe sous Windows
</code></pre>
<!--
If *main.rs* was your “Hello, world!” program, this line would print `Hello,
world!` to your terminal.
-->
<p>Si <em>main.rs</em> était votre programme “Hello, world!”, cette ligne devrait afficher
<code>Hello, world!</code> dans votre terminal.</p>
<!--
If you’re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an *ahead-of-time compiled* language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a *.rb*, *.py*, or
*.js* file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.
-->
<p>Si vous connaissez un langage dynamique, comme Ruby, Python, ou JavaScript, vous
n'avez peut-être pas l'habitude de compiler puis lancer votre programme dans des
étapes séparées.
Rust est un langage à <em>compilation anticipée</em>, ce qui veut dire que
vous pouvez compiler le programme et le donner à quelqu'un d'autre, et il peut
l'exécuter sans avoir Rust d'installé. Si vous donnez à quelqu'un un fichier
<em>.rb</em>, <em>.py</em> ou <em>.js</em>, il a besoin d'avoir respectivement un interpréteur Ruby,
Python, ou Javascript d'installé. Cependant, avec ces langages, vous n'avez
besoin que d'une seule commande pour compiler et exécuter votre programme.
Dans la conception d'un langage, tout est une question de compromis.</p>
<!--
Just compiling with `rustc` is fine for simple programs, but as your project
grows, you’ll want to manage all the options and make it easy to share your
code. Next, we’ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.
-->
<p>Compiler avec <code>rustc</code> peut suffire pour de petits programmes, mais au fur et à
mesure que votre programme grandit, vous allez avoir besoin de régler plus
d'options et faciliter le partage de votre code. À la page suivante, nous allons
découvrir l'outil Cargo, qui va vous aider à écrire des programmes Rust à
l'épreuve de la réalité.</p>
<!--
## Hello, Cargo!
-->
<h2><a class="header" href="#hello-cargo" id="hello-cargo">Hello, Cargo!</a></h2>
<!--
Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call libraries your code needs *dependencies*.)
-->
<p>Cargo est le système de compilation et de gestion de paquets de Rust. La plupart
des Rustacés utilisent cet outil pour gérer les projets Rust, car Cargo
s'occupe de nombreuses tâches pour vous, comme compiler votre code, télécharger
les bibliothèques dont votre code dépend, et compiler ces bibliothèques. (On
appelle <em>dépendance</em> une bibliothèque nécessaire pour votre code.)</p>
<!--
The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. So if we had built the “Hello, world!” project with Cargo, it
would only use the part of Cargo that handles building your code. As you write
more complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.
-->
<p>Des programmes Rust très simples, comme le petit que nous avons précédemment,
n'ont pas de dépendance. Donc si nous avions compilé le projet “Hello, world!”
avec Cargo, cela n'aurait fait appel qu'à la fonctionnalité de Cargo qui
s'occupe de la compilation de votre code. Quand vous écrirez des programmes Rust
plus complexes, vous ajouterez des dépendances, et si vous créez un projet en
utilisant Cargo, l'ajout des dépendances sera plus facile à faire.</p>
<!--
Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
[“Installation”][installation]<!-- ignore -- > section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following into your terminal:
-->
<p>Comme la large majorité des projets Rust utilisent Cargo, la suite de ce livre
va supposer que vous utilisez aussi Cargo. Cargo s'installe avec Rust si vous
avez utilisé l'installateur officiel présenté dans la section
<a href="ch01-01-installation.html#installation">“Installation”</a><!-- ignore -->. Si vous avez installé Rust
autrement, vérifiez que Cargo est installé en utilisant la commande suivante
dans votre terminal :</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<!--
If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.
-->
<p>Si vous voyez un numéro de version, c'est qu'il est installé ! Si vous voyez une
erreur comme <code>Commande non trouvée</code> (ou <code>command not found</code>), alors consultez la
documentation de votre méthode d'installation pour savoir comment installer
séparément Cargo.</p>
<!--
### Creating a Project with Cargo
-->
<h3><a class="header" href="#créer-un-projet-avec-cargo" id="créer-un-projet-avec-cargo">Créer un projet avec Cargo</a></h3>
<!--
Let’s create a new project using Cargo and look at how it differs from our
original “Hello, world!” project. Navigate back to your *projects* directory (or
wherever you decided to store your code). Then, on any operating system, run
the following:
-->
<p>Créons un nouveau projet en utilisant Cargo et analysons les différences avec
notre projet initial “Hello, world!”. Retournez dans votre dossier <em>projects</em>
(ou là où vous avez décidé d'enregistrer votre code). Ensuite, sur n'importe
quel système d'exploitation, lancez les commandes suivantes :</p>
<pre><code class="language-text">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<!--
The first command creates a new directory called *hello_cargo*. We’ve named
our project *hello_cargo*, and Cargo creates its files in a directory of the
same name.
-->
<p>La première commande crée un nouveau dossier appelé <em>hello_cargo</em>. Nous avons
appelé notre projet <em>hello_cargo</em>, et Cargo crée ses fichiers dans un dossier
avec le même nom.</p>
<!--
Go into the *hello_cargo* directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside. It has also initialized a new Git
repository along with a *.gitignore* file.
-->
<p>Rendez-vous dans le dossier <em>hello_cargo</em> et afficher la liste des fichiers.
Vous constaterez que Cargo a généré deux fichiers et un dossier pour nous : un
fichier <em>Cargo.toml</em> et un dossier <em>src</em> avec un fichier <em>main.rs</em> à
l'intérieur. Il a aussi créé un nouveau dépôt Git ainsi qu'un fichier
<em>.gitignore</em>.</p>
<!--
> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.
-->
<blockquote>
<p>Note : Git est un système de gestion de versions très répandu. Vous pouvez
changer <code>cargo new</code> pour utiliser un autre système de gestion de versions
ou ne pas en utiliser du tout en écrivant le drapeau <code>--vcs</code>.
Lancez <code>cargo new --help</code> pour en savoir plus sur les options disponibles.</p>
</blockquote>
<!--
Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2.
-->
<p>Ouvrez <em>Cargo.toml</em> dans votre éditeur de texte favori. Son contenu devrait
être similaire au code dans l'encart 1-2.</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<!--
<span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span>
-->
<p><span class="caption">Encart 1-2 : Contenu de <em>Cargo.toml</em> généré par <code>cargo new</code></span></p>
<!--
This file is in the [*TOML*][toml]<!-- ignore -- > (*Tom’s Obvious, Minimal
Language*) format, which is Cargo’s configuration format.
-->
<p>Ce fichier est au format <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (<em>Tom’s Obvious, Minimal
Language</em>), qui est le format de configuration de Cargo.</p>
<!--
The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.
-->
<p>La première ligne, <code>[package]</code>, est un en-tête de section qui indique que les
instructions suivantes configurent un paquet. Au fur et à mesure que nous
ajouterons plus de détails à ce fichier, nous ajouterons des sections
supplémentaires.</p>
<!--
The next four lines set the configuration information Cargo needs to compile
your program: the name, the version, who wrote it, and the edition of Rust to
use. Cargo gets your name and email information from your environment, so if
that information is not correct, fix the information now and then save the
file. We’ll talk about the `edition` key in Appendix E.
-->
<p>Les quatre lignes suivantes définissent les informations de configuration dont
Cargo a besoin pour compiler votre programme : le nom, la version, l'auteur et
l'édition de Rust à utiliser. Cargo récupère votre nom et votre courriel à
partir de votre environnement, donc si ces informations sont erronées, vous
pouvez les corriger dès maintenant et ensuite enregistrer le fichier. Nous
aborderons la clé <code>edition</code> dans l'annexe E.</p>
<!--
The last line, `[dependencies]`, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
*crates*. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.
-->
<p>La dernière ligne, <code>[dependencies]</code>, est le début d'une section qui vous permet
de lister les dépendances de votre projet. Dans Rust, les paquets de code sont
désignés sous le nom de <em>crates</em>. Nous n'allons pas utiliser de <em>crate</em> pour ce
projet, mais nous le ferons pour le premier projet au chapitre 2 ; nous
utiliserons alors cette section à ce moment-là.</p>
<!--
Now open *src/main.rs* and take a look:
-->
<p>Maintenant, ouvrez <em>src/main.rs</em> et jetez-y un coup d'œil :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Cargo has generated a “Hello, world!” program for you, just like the one we
wrote in Listing 1-1! So far, the differences between our previous project and
the project Cargo generates are that Cargo placed the code in the *src*
directory, and we have a *Cargo.toml* configuration file in the top directory.
-->
<p>Cargo a généré un programme “Hello, world!” pour vous, exactement comme celui
que nous avons écrit dans l'encart 1-1 ! Pour le moment, les seules différences
entre notre projet précédent et le projet que Cargo a généré sont que Cargo a
placé le code dans le dossier <em>src</em>, et que nous avons un fichier de
configuration <em>Cargo.toml</em> à la racine du dossier projet.</p>
<!--
Cargo expects your source files to live inside the *src* directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.
-->
<p>Cargo prévoit de stocker vos fichiers sources dans le dossier <em>src</em>. Le dossier
parent est là uniquement pour les fichiers README, pour les informations à
propos de la licence, pour les fichiers de configuration et tout ce qui n'est
pas directement relié à votre code. Utiliser Cargo vous aide à structurer vos
projets. Il y a un endroit pour tout, et tout est à sa place.</p>
<!--
If you started a project that doesn’t use Cargo, as we did with the “Hello,
world!” project, you can convert it to a project that does use Cargo. Move the
project code into the *src* directory and create an appropriate *Cargo.toml*
file.
-->
<p>Si vous commencez un projet sans utiliser Cargo, comme nous l'avons fait avec
le projet “Hello, world!”, vous pouvez le transformer en projet qui
utilise Cargo. Déplacez le code de votre projet dans un dossier <em>src</em> et créez
un fichier <em>Cargo.toml</em> adéquat.</p>
<!--
### Building and Running a Cargo Project
-->
<h3><a class="header" href="#compiler-et-exécuter-un-projet-cargo" id="compiler-et-exécuter-un-projet-cargo">Compiler et exécuter un projet Cargo</a></h3>
<!--
Now let’s look at what’s different when we build and run the “Hello, world!”
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command:
-->
<p>Maintenant, regardons ce qu'il y a de différent quand nous compilons et
exécutons le programme “Hello, world!” avec Cargo ! À l'intérieur de votre
dossier <em>hello_cargo</em>, compilez votre projet en utilisant la commande suivante :</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<!--
This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. You can run the executable with this command:
-->
<p>Cette commande crée un fichier exécutable dans <em>target/debug/hello_cargo</em> (ou
<em>target\debug\hello_cargo.exe</em> sous Windows) plutôt que de le déposer dans votre
dossier courant. Vous pouvez lancer l'exécutable avec cette commande :</p>
<!--
```text
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```
-->
<pre><code class="language-text">$ ./target/debug/hello_cargo # ou .\target\debug\hello_cargo.exe sous Windows
Hello, world!
</code></pre>
<!--
If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.
-->
<p>Si tout s'est bien passé, <code>Hello, world!</code> devrait s'afficher dans le terminal.
Lancer <code>cargo build</code> pour la première fois devrait aussi mener Cargo à créer
un nouveau fichier à la racine du dossier projet : <em>Cargo.lock</em>. Ce fichier
garde une trace des versions exactes des dépendances de votre
projet. Ce projet n'a pas de dépendance, donc le fichier est un peu vide. Vous
n'aurez jamais besoin de changer ce fichier manuellement ; Cargo va gérer son
contenu pour vous.</p>
<!--
We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resulting executable all in one command:
-->
<p>Nous venons de compiler un projet avec <code>cargo build</code> avant de l'exécuter avec
<code>./target/debug/hello_cargo</code>, mais nous pouvons aussi utiliser <code>cargo run</code> pour
compiler le code et ensuite lancer l'exécutable dans une seule et même
commande :</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn’t changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output:
-->
<p>Notez que cette fois-ci, nous ne voyons pas de messages indiquant que Cargo a
compilé <code>hello_cargo</code>. Cargo a détecté que les fichiers n'avaient pas changé,
donc il a juste exécuté le binaire. Si vous aviez modifié votre code source,
Cargo aurait recompilé le projet avant de le lancer, et vous auriez eu les
messages suivants :</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:
-->
<p>Cargo fournit aussi une commande appelée <code>cargo check</code>. Elle vérifie rapidement
votre code pour s'assurer qu'il est compilable, mais ne produit pas
d'exécutable :</p>
<pre><code class="language-text">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<!--
Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build`, because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using `cargo check` will
speed up the process! As such, many Rustaceans run `cargo check` periodically
as they write their program to make sure it compiles. Then they run `cargo
build` when they’re ready to use the executable.
-->
<p>Dans quel cas n'aurions-nous pas besoin d'un exécutable ? Parfois, <code>cargo check</code>
est bien plus rapide que <code>cargo build</code>, car il saute l'étape de création de
l'exécutable. Si vous vérifiez votre travail continuellement pendant que vous
écrivez votre code, utiliser <code>cargo check</code> accélèrera le processus ! C'est
pourquoi de nombreux Rustacés utilisent périodiquement <code>cargo check</code> quand ils
écrivent leur programme afin de s'assurer qu'il compile. Ensuite, ils lancent
<code>cargo build</code> quand ils sont prêts à utiliser l'exécutable.</p>
<!--
Let’s recap what we’ve learned so far about Cargo:
-->
<p>Récapitulons ce que nous avons appris sur Cargo :</p>
<!--
* We can build a project using `cargo build` or `cargo check`.
* We can build and run a project in one step using `cargo run`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory.
-->
<ul>
<li>Nous pouvons compiler un projet en utilisant <code>cargo build</code> ou <code>cargo check</code></li>
<li>Nous pouvons compiler puis exécuter un projet en une seule fois en utilisant
<code>cargo run</code>.</li>
<li>Au lieu d'enregistrer le résultat de la compilation dans le même dossier que
votre code, Cargo l'enregistre dans le dossier <em>target/debug</em>.</li>
</ul>
<!--
An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.
-->
<p>Un autre avantage d'utiliser Cargo est que les commandes sont les mêmes peu
importe le système d'exploitation que vous utilisez.
Donc à partir de maintenant, nous n'allons plus faire d'opérations spécifiques
à Linux et macOS par rapport à Windows.</p>
<!--
### Building for Release
-->
<h3><a class="header" href="#compiler-pour-diffuser" id="compiler-pour-diffuser">Compiler pour diffuser</a></h3>
<!--
When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*.
-->
<p>Quand votre projet est finalement prêt à être diffusé, vous pouvez utiliser
<code>cargo build --release</code> pour le compiler en l'optimisant. Cette commande va
créer un exécutable dans <em>target/release</em> au lieu de <em>target/debug</em>. Ces
optimisations rendent votre code Rust plus rapide à exécuter, mais l'utiliser
rallonge le temps de compilation de votre programme. C'est pourquoi il y a deux
différents profils : un pour le développement, quand vous voulez recompiler
rapidement et souvent, et un autre pour compiler le programme final qui sera
livré à un utilisateur, qui n'aura pas besoin d'être recompilé à plusieurs
reprises et qui s'exécutera aussi vite que possible. Si vous évaluez le temps
d'exécution de votre code, assurez-vous de lancer <code>cargo build --release</code> et
d'utiliser l'exécutable dans <em>target/release</em> pour vos bancs de test.</p>
<!--
### Cargo as Convention
-->
<h3><a class="header" href="#cargo-comme-convention" id="cargo-comme-convention">Cargo comme convention</a></h3>
<!--
With simple projects, Cargo doesn’t provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, it’s much easier to let
Cargo coordinate the build.
-->
<p>Pour des projets simples, Cargo n'apporte pas grand-chose par rapport à <code>rustc</code>,
mais il vous montrera son intérêt au fur et à mesure
que vos programmes deviendront plus complexes. Avec des projets complexes
composés de plusieurs <em>crates</em>, il est plus facile de laisser Cargo prendre en
charge la coordination de la compilation.</p>
<!--
Even though the `hello_cargo` project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:
-->
<p>Même si le projet <code>hello_cargo</code> est simple, il utilise maintenant une grande
partie de l'outillage que vous rencontrerez dans votre carrière avec Rust. En
effet, pour travailler sur n'importe quel projet Rust existant, vous n'avez
qu'à saisir les commandes suivantes pour télécharger le code avec Git, vous
déplacer dans le dossier projet et compiler :</p>
<!--
```text
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```
-->
<pre><code class="language-text">$ git clone example.com/projet_quelconque
$ cd projet_quelconque
$ cargo build
</code></pre>
<!--
For more information about Cargo, check out [its documentation].
-->
<p>Pour plus d'informations à propos de Cargo, vous pouvez consulter <a href="https://doc.rust-lang.org/cargo/">sa
documentation</a>.</p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé" id="résumé">Résumé</a></h2>
<!--
You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:
-->
<p>Vous êtes déjà bien lancé dans votre périple avec Rust ! Dans ce chapitre, vous
avez appris comment :</p>
<!--
* Install the latest stable version of Rust using `rustup`
* Update to a newer Rust version
* Open locally installed documentation
* Write and run a “Hello, world!” program using `rustc` directly
* Create and run a new project using the conventions of Cargo
-->
<ul>
<li>Installer la dernière version stable de Rust en utilisant <code>rustup</code></li>
<li>Mettre à jour Rust vers une nouvelle version</li>
<li>Ouvrir la documentation installée en local</li>
<li>Écrire et exécuter un programme “Hello, world!” en utilisant directement
<code>rustc</code></li>
<li>Créer et exécuter un nouveau projet en utilisant les conventions de Cargo</li>
</ul>
<!--
This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.
-->
<p>C'est le moment idéal pour construire un programme plus ambitieux pour
s'habituer à lire et écrire du code Rust. Donc, au chapitre 2, nous allons
écrire un programme de <em>jeu de devinettes</em>.
Si vous préférez commencer par apprendre comment les principes de programmation
de base fonctionnent avec Rust, rendez-vous au chapitre 3, puis revenez au
chapitre 2.</p>
<!--
# Programming a Guessing Game
-->
<h1><a class="header" href="#programmer-un-jeu-de-devinettes" id="programmer-un-jeu-de-devinettes">Programmer un jeu de devinettes</a></h1>
<!--
Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about `let`, `match`, methods, associated
functions, using external crates, and more! The following chapters will explore
these ideas in more detail. In this chapter, you’ll practice the fundamentals.
-->
<p>Entrons dans le vif du sujet en travaillant ensemble sur un projet concret !
Ce chapitre présente quelques concepts couramment utilisés en Rust en vous
montrant comment les utiliser dans un véritable programme. Nous aborderons
notamment les instructions <code>let</code> et <code>match</code>, les méthodes et fonctions
associées, l'utilisation des <em>crates</em>, et bien plus encore ! Dans les chapitres
suivants, nous approfondirons ces notions. Dans ce chapitre, vous n'allez
exercer que les principes de base.</p>
<!--
We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.
-->
<p>Nous allons coder un programme fréquemment réalisé par les débutants en
programmation : un jeu de devinettes. Le principe de ce jeu est le suivant :
le programme va tirer au sort un nombre entre 1 et 100. Il invitera ensuite le
joueur à saisir un nombre qu'il pense deviner. Après la saisie, le programme
indiquera si le nombre saisi par le joueur est trop grand ou trop petit. Si le
nombre saisi est le bon, le jeu affichera un message de félicitations et se
fermera.</p>
<!--
## Setting Up a New Project
-->
<h2><a class="header" href="#mise-en-place-dun-nouveau-projet" id="mise-en-place-dun-nouveau-projet">Mise en place d'un nouveau projet</a></h2>
<!--
To set up a new project, go to the *projects* directory that you created in
Chapter 1 and make a new project using Cargo, like so:
-->
<p>Pour créer un nouveau projet, rendez-vous dans le dossier <em>projects</em> que
vous avez créé au chapitre 1 et utilisez Cargo pour créer votre projet, comme
ceci :</p>
<pre><code class="language-text">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<!--
The first command, `cargo new`, takes the name of the project (`guessing_game`)
as the first argument. The second command changes to the new project’s
directory.
-->
<p>La première commande, <code>cargo new</code>, prend comme premier argument le nom de notre
projet (<code>guessing_game</code>). La seconde commande nous déplace dans le dossier de
notre nouveau projet créé par Cargo.</p>
<!--
Look at the generated *Cargo.toml* file:
-->
<p>Regardons le fichier <em>Cargo.toml</em> qui a été généré :</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<!--
If the author information that Cargo obtained from your environment is not
correct, fix that in the file and save it again.
-->
<p>Si le nom de l'auteur que Cargo a déduit de votre environnement est incorrect,
vous pouvez le changer dans ce fichier et le sauvegarder.</p>
<!--
As you saw in Chapter 1, `cargo new` generates a “Hello, world!” program for
you. Check out the *src/main.rs* file:
-->
<p>Comme vous l'avez expérimenté dans le chapitre 1, <code>cargo new</code> génère un
programme <em>“Hello, world!”</em> pour vous. Ouvrez le fichier <em>src/main.rs</em> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Now let’s compile this “Hello, world!” program and run it in the same step
using the `cargo run` command:
-->
<p>Maintenant, lançons la compilation de ce programme “Hello, world!” et
son exécution en une seule commande avec <code>cargo run</code> :</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<!--
The `run` command comes in handy when you need to rapidly iterate on a project,
as we’ll do in this game, quickly testing each iteration before moving on to
the next one.
-->
<p>Cette commande <code>run</code> est très pratique lorsqu'on souhaite itérer rapidement
sur un projet, comme c'est le cas ici, pour tester rapidement chaque
modification avant de passer à la suivante.</p>
<!--
Reopen the *src/main.rs* file. You’ll be writing all the code in this file.
-->
<p>Ouvrez à nouveau le fichier <em>src/main.rs</em>. C'est dans ce fichier que nous
écrirons la totalité de notre code.</p>
<!--
## Processing a Guess
-->
<h2><a class="header" href="#traitement-dun-nombre-saisi" id="traitement-dun-nombre-saisi">Traitement d'un nombre saisi</a></h2>
<!--
The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
*src/main.rs*.
-->
<p>La première partie du programme consiste à demander au joueur de saisir du
texte, à traiter cette saisie, et à vérifier que la saisie correspond au format
attendu.
Commençons par permettre au joueur de saisir son nombre. Entrez le
code de l'encart 2-1 dans le fichier <em>src/main.rs</em>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Devinez le nombre !&quot;);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin().read_line(&amp;mut supposition)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

    println!(&quot;Votre nombre : {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-1: Code that gets a guess from the user and
prints it</span>
-->
<p><span class="caption">Encart 2-1 : Code permettant de récupérer une saisie
utilisateur et de l'afficher</span></p>
<!--
This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
`io` (input/output) library into scope. The `io` library comes from the
standard library (which is known as `std`):
-->
<p>Ce code contient beaucoup d'informations, nous allons donc l'analyser petit
à petit. Pour obtenir la saisie utilisateur et ensuite l'afficher, nous avons
besoin d'importer la bibliothèque <code>io</code> (pour <em>input/output</em>, entrée/sortie) afin
de pouvoir l'utiliser. La bibliothèque <code>io</code> provient de la bibliothèque standard
(qui est aussi connue sous le nom de <code>std</code>).</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<!--
By default, Rust brings only a few types into the scope of every program in
[the *prelude*][prelude]<!-- ignore -- >. If a type you want to use isn’t in the
prelude, you have to bring that type into scope explicitly with a `use`
statement. Using the `std::io` library provides you with a number of useful
features, including the ability to accept user input.
-->
<p>Par défaut, Rust n'importe que très peu de types dans les programmes, qui sont
présents dans <a href="https://doc.rust-lang.org/std/prelude/index.html"><em>l'étape préliminaire (the prelude)</em></a><!-- ignore -->. Si
vous voulez utiliser un type qui ne s'y trouve pas, vous devrez l'importer
explicitement avec l'instruction <code>use</code>. L'utilisation de la bibliothèque
<code>std::io</code> vous apporte de nombreuses fonctionnalités utiles, comme ici la
possibilité de récupérer une saisie utilisateur.</p>
<!-- [prelude]: ../std/prelude/index.html -->
<!--
As you saw in Chapter 1, the `main` function is the entry point into the
program:
-->
<p>Comme vous l'avez vu au chapitre 1, la fonction <code>main</code> est le point d'entrée
du programme :</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<!--
The `fn` syntax declares a new function, the parentheses, `()`, indicate there
are no parameters, and the curly bracket, `{`, starts the body of the function.
-->
<p>Le mot clé <code>fn</code> déclare une nouvelle fonction, les parenthèses <code>()</code> indiquent
que cette fonction n'accepte aucun paramètre, et l'accolade ouvrante <code>{</code> marque
le début du corps de la fonction.</p>
<!--
As you also learned in Chapter 1, `println!` is a macro that prints a string to
the screen:
-->
<p>Comme vous l'avez également appris au chapitre 1, <code>println!</code> est une macro qui
affiche une chaîne de caractères à l'écran :</p>
<!--
```rust,ignore
println!("Guess the number!");

println!("Please input your guess.");
```
-->
<pre><code class="language-rust ignore">println!(&quot;Devinez le nombre !&quot;);

println!(&quot;Veuillez entrer un nombre.&quot;);
</code></pre>
<!--
This code is printing a prompt stating what the game is and requesting input
from the user.
-->
<p>Ce code affiche du texte qui indique le titre de notre jeu, et un autre qui
demande au joueur d'entrer un nombre.</p>
<!--
### Storing Values with Variables
-->
<h3><a class="header" href="#enregistrer-des-données-dans-des-variables" id="enregistrer-des-données-dans-des-variables">Enregistrer des données dans des variables</a></h3>
<!--
Next, we’ll create a place to store the user input, like this:
-->
<p>Ensuite, on crée un endroit où stocker la saisie de l'utilisateur, comme ceci :</p>
<!--
```rust,ignore
let mut guess = String::new();
```
-->
<pre><code class="language-rust ignore">let mut supposition = String::new();
</code></pre>
<!--
Now the program is getting interesting! There’s a lot going on in this little
line. Notice that this is a `let` statement, which is used to create a
*variable*. Here’s another example:
-->
<p>Le programme commence à devenir intéressant ! Il se passe beaucoup de choses
dans cette petite ligne. Vous remarquerez qu'elle commence par le mot-clé <code>let</code>,
qui sert à créer une <em>variable</em>. Voici un autre exemple :</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<!--
This line creates a new variable named `foo` and binds it to the value of the
`bar` variable. In Rust, variables are immutable by default. We’ll be
discussing this concept in detail in the [“Variables and
Mutability”][variables-and-mutability]<!-- ignore -- > section in Chapter 3.
The following example shows how to use `mut` before the variable name to make
a variable mutable:
-->
<p>Cette ligne permet de créer une nouvelle variable nommée <code>foo</code> et à lui
assigner la valeur de <code>bar</code>. Par défaut en Rust, les variables sont immuables.
Nous aborderons plus en détail cette notion dans la section <a href="ch03-01-variables-and-mutability.html">“Variables et
Mutabilité”</a><!-- ignore --> au chapitre 3. L'exemple
suivant montre comment utiliser le mot-clé <code>mut</code> avant le nom de la variable
pour rendre une variable mutable <em>(c'est-à-dire modifiable)</em> :</p>
<!--
```rust,ignore
let foo = 5; // immutable
let mut bar = 5; // mutable
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let foo = 5; // immuable
let mut bar = 5; // mutable, modifiable
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: The `//` syntax starts a comment that continues until the end of the
> line. Rust ignores everything in comments, which are discussed in more detail
> in Chapter 3.
-->
<blockquote>
<p>Remarque : La syntaxe <code>//</code> permet de commencer un commentaire qui s'étend
jusqu'à la fin de la ligne. Rust ignore tout ce qu'il y a dans un commentaire,
ceci sera développé plus en détail dans le chapitre 3.</p>
</blockquote>
<!--
Let’s return to the guessing game program. You now know that `let mut guess`
will introduce a mutable variable named `guess`. On the other side of the equal
sign (`=`) is the value that `guess` is bound to, which is the result of
calling `String::new`, a function that returns a new instance of a `String`.
[`String`][string]<!-- ignore -- > is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.
-->
<p>Mais revenons à notre jeu de devinettes. Vous comprenez donc maintenant que la
ligne <code>let mut supposition</code> permet de créer une variable mutable nommée
<code>supposition</code>. De l'autre côté du signe égal (<code>=</code>) se trouve la valeur de cette
variable, et il s'agit ici du résultat de l'utilisation de <code>String::new</code>, qui
est une fonction qui retourne une nouvelle instance de <code>String</code>.
<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> est un type de chaîne de caractères fourni
par la bibliothèque standard, qui est une portion de texte encodée en UTF-8 et
dont la longueur peut augmenter.</p>
<!-- [string]: ../std/string/struct.String.html -->
<!--
The `::` syntax in the `::new` line indicates that `new` is an *associated
function* of the `String` type. An associated function is implemented on a type,
in this case `String`, rather than on a particular instance of a `String`. Some
languages call this a *static method*.
-->
<p>La syntaxe <code>::</code> dans <code>String::new()</code> indique que <code>new</code> est une
<em>fonction associée</em> au type <code>String</code>. Une fonction associée est implémentée sur
un type, ici <code>String</code>, plutôt que sur une instance de <code>String</code>. Ce concept est
parfois appelé une <em>méthode statique</em> dans d'autres langages.</p>
<!--
This `new` function creates a new, empty string. You’ll find a `new` function
on many types, because it’s a common name for a function that makes a new value
of some kind.
-->
<p>Cette fonction <code>new</code> crée une nouvelle chaîne de caractères vide, une nouvelle
<code>String</code>. Vous trouverez fréquemment une fonction <code>new</code> sur d'autres types, car
c'est un nom souvent donné à une fonction qui crée une nouvelle valeur ou
instance d'un type.</p>
<!--
To summarize, the `let mut guess = String::new();` line has created a mutable
variable that is currently bound to a new, empty instance of a `String`. Whew!
-->
<p>Pour résumer, la ligne <code>let mut supposition = String::new();</code> crée une nouvelle
variable mutable qui contient une nouvelle chaîne de caractères vide, une
instance de <code>String</code>. Ouf !</p>
<!--
Recall that we included the input/output functionality from the standard
library with `use std::io;` on the first line of the program. Now we’ll call
the `stdin` function from the `io` module:
-->
<p>Rappelez-vous que nous avons importé les fonctionnalités d'entrée/sortie de la
bibliothèque standard avec <code>use std::io;</code> à la première ligne de notre
programme. Nous allons maintenant appeler la fonction <code>stdin</code> du
module <code>io</code> :</p>
<!--
```rust,ignore
io::stdin().read_line(&mut guess)
    .expect("Failed to read line");
```
-->
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut supposition)
    .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</code></pre>
<!--
If we hadn’t put the `use std::io` line at the beginning of the program, we
could have written this function call as `std::io::stdin`. The `stdin` function
returns an instance of [`std::io::Stdin`][iostdin]<!-- ignore -- >, which is a
type that represents a handle to the standard input for your terminal.
-->
<p>Si la ligne <code>use std::io</code> n'était pas présente au début du programme, on aurait
dû écrire l'appel à la fonction de cette manière : <code>std::io::stdin</code>. La fonction
<code>stdin</code> retourne une instance de <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, qui
est un type qui représente une référence abstraite <em>(handle)</em> vers l'entrée
standard du terminal dans lequel vous avez lancé le programme.</p>
<!-- [iostdin]: ../std/io/struct.Stdin.html -->
<!--
The next part of the code, `.read_line(&mut guess)`, calls the
[`read_line`][read_line]<!-- ignore -- > method on the standard input handle to
get input from the user. We’re also passing one argument to `read_line`: `&mut
guess`.
-->
<p>La partie suivante du code, <code>.read_line(&amp;mut supposition)</code>, appelle la méthode
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> sur l'entrée standard afin d'obtenir
la saisie utilisateur. De plus, on passe à cette méthode l'argument
<code>&amp;mut supposition</code>.</p>
<!-- [read_line]: ../std/io/struct.Stdin.html#method.read_line -->
<!--
The job of `read_line` is to take whatever the user types into standard input
and place that into a string, so it takes that string as an argument. The
string argument needs to be mutable so the method can change the string’s
content by adding the user input.
-->
<p>Le rôle de <code>read_line</code> est de récupérer tout ce que l'utilisateur écrit dans
l'entrée standard et de le stocker dans une chaîne de caractères ; c'est
pourquoi cette méthode prend une <code>String</code> comme argument. Cet argument doit être
mutable pour que <code>read_line</code> puisse en modifier le contenu en y ajoutant
la saisie de l'utilisateur.</p>
<!--
The `&` indicates that this argument is a *reference*, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write `&mut guess` rather than
`&guess` to make it mutable. (Chapter 4 will explain references more
thoroughly.)
-->
<p>Le <code>&amp;</code> indique que cet argument est une <em>référence</em>, ce qui permet de laisser
plusieurs morceaux de votre code accéder à une même donnée sans avoir besoin
de copier ces données dans la mémoire plusieurs fois. Les références sont une
fonctionnalité complexe, et un des avantages majeurs de Rust est qu'il rend sûr
et simple l'utilisation des références. Il n'est pas nécessaire de trop
s'apesantir sur les références pour terminer ce programme.
Pour l'instant, tout ce que vous devez savoir est que comme les variables, les
références sont immuables par défaut.
D'où la nécessité d'écrire <code>&amp;mut supposition</code> au lieu de <code>&amp;supposition</code> pour la
rendre mutable. (Le chapitre 4 expliquera plus en détail les références.)</p>
<!--
### Handling Potential Failure with the `Result` Type
-->
<h3><a class="header" href="#gérer-les-erreurs-potentielles-avec-le-type-result" id="gérer-les-erreurs-potentielles-avec-le-type-result">Gérer les erreurs potentielles avec le type <code>Result</code></a></h3>
<!--
We’re not quite done with this line of code. Although what we’ve discussed so
far is a single line of text, it’s only the first part of the single logical
line of code. The second part is this method:
-->
<p>Nous n'en avons pas tout à fait fini avec cette ligne de code.
Nous avons abordé jusqu'ici une seule ligne de texte, mais ce n'est que la
première partie de la ligne de code.
La deuxième partie est cette méthode :</p>
<!--
```rust,ignore
.expect("Failed to read line");
```
-->
<pre><code class="language-rust ignore">.expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</code></pre>
<!--
When you call a method with the `.foo()` syntax, it’s often wise to introduce a
newline and other whitespace to help break up long lines. We could have
written this code as:
-->
<p>Lorsque l'on appelle une méthode avec la syntaxe <code>.foo()</code>, il est généralement
préférable d'ajouter un retour à la ligne puis d'indenter à l'aide d'espaces
pour décomposer les longues lignes de code.
Nous aurions pu écrire ce code de cette manière :</p>
<!--
```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```
-->
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut supposition).expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);
</code></pre>
<!--
However, one long line is difficult to read, so it’s best to divide it: two
lines for two method calls. Now let’s discuss what this line does.
-->
<p>Cependant, une longue ligne de code n'est pas toujours facile à lire, c'est donc
une bonne pratique de la diviser : deux lignes de texte pour deux appels de
méthodes. Mais maintenant, voyons à quoi sert cette ligne.</p>
<!--
As mentioned earlier, `read_line` puts what the user types into the string
we’re passing it, but it also returns a value—in this case, an
[`io::Result`][ioresult]<!-- ignore -- >. Rust has a number of types named
`Result` in its standard library: a generic [`Result`][result]<!-- ignore -- >
as well as specific versions for submodules, such as `io::Result`.
-->
<p>Comme expliqué précédemment, <code>read_line</code> stocke ce que l'utilisateur a saisi
dans la variable qu'on lui passe en argument, mais cette fonction retourne
aussi une valeur − dans notre cas, de type
<a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Il existe plusieurs types nommés
<code>Result</code> dans la bibliothèque standard de Rust : un type générique
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> ainsi que des déclinaisons spécifiques à
des sous-modules, comme <code>io::Result</code>.</p>
<!-- [ioresult]: ../std/io/type.Result.html -->
<!-- [result]: ../std/result/enum.Result.html -->
<!--
The `Result` types are [*enumerations*][enums]<!-- ignore -- >, often referred
to as *enums*. An enumeration is a type that can have a fixed set of values,
and those values are called the enum’s *variants*. Chapter 6 will cover enums
in more detail.
-->
<p>Les types <code>Result</code> sont des <a href="ch06-00-enums.html"><em>énumérations</em></a><!-- ignore -->, aussi
appelées <em>enums</em>. Une énumération est un type qui peut avoir un certain nombre
de valeurs prédéfinies, et ces valeurs sont appelées des <em>variantes</em>
d'énumération. Le chapitre 6 explorera les énumérations plus en détail.</p>
<!--
For `Result`, the variants are `Ok` or `Err`. The `Ok` variant indicates the
operation was successful, and inside `Ok` is the successfully generated value.
The `Err` variant means the operation failed, and `Err` contains information
about how or why the operation failed.
-->
<p>Avec <code>Result</code>, les variantes sont <code>Ok</code> ou <code>Err</code>. La variante <code>Ok</code> signifie que
l'opération a fonctionné, et à l'intérieur de <code>Ok</code> se trouve la valeur générée
avec succès. La variante <code>Err</code> signifie que l'opération a échoué, et <code>Err</code>
contient les informations décrivant comment ou pourquoi l'opération a échoué.</p>
<!--
The purpose of these `Result` types is to encode error-handling information.
Values of the `Result` type, like values of any type, have methods defined on
them. An instance of `io::Result` has an [`expect` method][expect]<!-- ignore
-- > that you can call. If this instance of `io::Result` is an `Err` value,
`expect` will cause the program to crash and display the message that you
passed as an argument to `expect`. If the `read_line` method returns an `Err`,
it would likely be the result of an error coming from the underlying operating
system. If this instance of `io::Result` is an `Ok` value, `expect` will take
the return value that `Ok` is holding and return just that value to you so you
can use it. In this case, that value is the number of bytes in what the user
entered into standard input.
-->
<p>L'objectif de ces types <code>Result</code> est d'encoder des informations utiles à la
gestion des erreurs.
Les valeurs du type <code>Result</code>, comme pour tous les types, ont des méthodes
qui leur sont associées. Par exemple, une instance de <code>io::Result</code> a une
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">méthode <code>expect</code></a><!-- ignore --> que vous pouvez utiliser. Si cette
instance de <code>io::Result</code> a pour valeur la variante <code>Err</code>, l'appel à <code>expect</code>
fera planter le programme et affichera le message que vous avez passé en
argument de <code>expect</code>. Si l'appel à <code>read_line</code> retourne une variante <code>Err</code>, ce
sera probablement dû à une erreur du système d'exploitation. Si en revanche
<code>read_line</code> a pour valeur la variante <code>Ok</code>, <code>expect</code> récupèrera le
contenu du <code>Ok</code>, qui est le résultat de l'opération, et vous le retournera afin
que vous puissiez l'utiliser. Dans notre exemple, ce résultat est le nombre
d'octets que l'utilisateur a saisi dans l'entrée standard.</p>
<!-- [expect]: ../std/result/enum.Result.html#method.expect -->
<!--
If you don’t call `expect`, the program will compile, but you’ll get a warning:
-->
<p>Si on n'appelle pas <code>expect</code>, le programme compilera, mais avec un
avertissement :</p>
<!--
```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  -- > src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
```
-->
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  -- &gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut supposition);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<!--
Rust warns that you haven’t used the `Result` value returned from `read_line`,
indicating that the program hasn’t handled a possible error.
-->
<p>Rust nous prévient que l'on ne fait rien du <code>Result</code> que nous fournit
<code>read_line</code>, et que par conséquent notre programme ne gère pas une erreur
potentielle.</p>
<!--
The right way to suppress the warning is to actually write error handling, but
because you just want to crash this program when a problem occurs, you can use
`expect`. You’ll learn about recovering from errors in Chapter 9.
-->
<p>La meilleure façon de masquer cet avertissement est de réellement écrire le
code permettant de gérer l'erreur, mais dans notre cas on a seulement besoin de
faire planter le programme si un problème survient, on utilise donc <code>expect</code>.
Nous verrons dans le chapitre 9 comment gérer correctement les erreurs.</p>
<!--
### Printing Values with `println!` Placeholders
-->
<h3><a class="header" href="#afficher-des-valeurs-grâce-aux-espaces-réservés-de-println" id="afficher-des-valeurs-grâce-aux-espaces-réservés-de-println">Afficher des valeurs grâce aux espaces réservés de <code>println!</code></a></h3>
<!--
Aside from the closing curly brackets, there’s only one more line to discuss in
the code added so far, which is the following:
-->
<p>Mis à part l'accolade fermante, il ne nous reste plus qu'une seule ligne à
étudier dans le code que nous avons pour l'instant :</p>
<!--
```rust,ignore
println!("You guessed: {}", guess);
```
-->
<pre><code class="language-rust ignore">println!(&quot;Votre nombre : {}&quot;, supposition);
</code></pre>
<!--
This line prints the string we saved the user’s input in. The set of curly
brackets, `{}`, is a placeholder: think of `{}` as little crab pincers that
hold a value in place. You can print more than one value using curly brackets:
the first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to `println!` would look like this:
-->
<p>Cette ligne affiche la chaîne de caractères où est stocké ce que l'utilisateur
a saisi. La paire d'accolades <code>{}</code> représente un espace réservé : imaginez
qu'il s'agit de pinces de crabes qui gardent la place d'une valeur. Vous pouvez
afficher plusieurs valeurs en utilisant des accolades : la première paire
d'accolades affichera la première valeur listée après la chaîne de formatage,
la deuxième paire d'accolades affichera la deuxième valeur, et ainsi de suite.
Pour afficher plusieurs valeurs en appelant <code>println!</code> une seule fois, on ferait
comme ceci :</p>
<!--
```rust
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} et y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
This code would print `x = 5 and y = 10`.
-->
<p>Ce code afficherait <code>x = 5 et y = 10</code>.</p>
<!--
### Testing the First Part
-->
<h3><a class="header" href="#test-de-la-première-partie" id="test-de-la-première-partie">Test de la première partie</a></h3>
<!--
Let’s test the first part of the guessing game. Run it using `cargo run`:
-->
<p>Pour tester notre début de programme, lançons-le à l'aide de la commande
<code>cargo run</code> :</p>
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```
-->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Devinez le nombre !
Veuillez entrer un nombre.
6
Votre nombre : 6
</code></pre>
<!--
At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.
-->
<p>À ce stade, la première partie de notre programme est terminée : nous avons
récupéré la saisie du clavier et nous l'affichons à l'écran.</p>
<!--
## Generating a Secret Number
-->
<h2><a class="header" href="#générer-le-nombre-secret" id="générer-le-nombre-secret">Générer le nombre secret</a></h2>
<!--
Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. Let’s use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a [`rand` crate][randcrate].
-->
<p>Maintenant, il nous faut générer un nombre secret que notre joueur va devoir
deviner. Ce nombre devra être différent à chaque fois pour qu'on puisse
s'amuser à y jouer plusieurs fois. Tirons au sort un nombre compris entre
1 et 100 pour que le jeu ne soit pas trop difficile. Rust n'embarque pas pour
l'instant de fonctionnalité de génération de nombres aléatoires dans sa
bibliothèque standard. Cependant, l'équipe de Rust propose une
<a href="https://crates.io/crates/rand"><em>crate</em> <code>rand</code></a>.</p>
<!--
### Using a Crate to Get More Functionality
-->
<h3><a class="header" href="#Étendre-les-fonctionnalités-de-rust-avec-une-crate" id="Étendre-les-fonctionnalités-de-rust-avec-une-crate">Étendre les fonctionnalités de Rust avec une <em>crate</em></a></h3>
<!--
Remember that a crate is a collection of Rust source code files.
The project we’ve been building is a *binary crate*, which is an executable.
The `rand` crate is a *library crate*, which contains code intended to be
used in other programs.
-->
<p>Souvenez-vous, une <em>crate</em> est un ensemble de fichiers de code source Rust.
Le projet sur lequel nous travaillons est une <em>crate</em> binaire, qui est un
programme exécutable.
La <em>crate</em> <code>rand</code> est une <em>crate de bibliothèque</em>, qui contient du
code qui peut être utilisé dans d'autres programmes.</p>
<!--
Cargo’s use of external crates is where it really shines. Before we can write
code that uses `rand`, we need to modify the *Cargo.toml* file to include the
`rand` crate as a dependency. Open that file now and add the following line to
the bottom beneath the `[dependencies]` section header that Cargo created for
you:
-->
<p>L'utilisation des <em>crates</em> externes est un domaine dans lequel Cargo excelle.
Avant d'écrire le code qui utilisera <code>rand</code>, il nous faut éditer le fichier
<em>Cargo.toml</em> pour y spécifier <code>rand</code> en tant que dépendance. Ouvrez donc
maintenant ce fichier et ajoutez la ligne suivante à la fin, en dessous de
l'en-tête de section <code>[dependencies]</code> que Cargo a créé pour vous :</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">Fichier : Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.5.5&quot;
</code></pre>
<!--
In the *Cargo.toml* file, everything that follows a header is part of a section
that continues until another section starts. The `[dependencies]` section is
where you tell Cargo which external crates your project depends on and which
versions of those crates you require. In this case, we’ll specify the `rand`
crate with the semantic version specifier `0.5.5`. Cargo understands [Semantic
Versioning][semver]<!-- ignore -- > (sometimes called *SemVer*), which is a
standard for writing version numbers. The number `0.5.5` is actually shorthand
for `^0.5.5`, which means “any version that has a public API compatible with
version 0.5.5.”
-->
<p>Dans le fichier <em>Cargo.toml</em>, tout ce qui suit une en-tête fait partie de cette
section, et ce jusqu'à ce qu'une autre section débute. La section
<code>[dependencies]</code> permet d'indiquer à Cargo de quelles <em>crates</em> externes votre
projet dépend, et de quelle version de ces <em>crates</em> vous avez besoin.
Dans notre cas, on ajoute comme dépendance la crate <code>rand</code> avec la version
sémantique <code>0.5.5</code>. Cargo arrive à interpréter le
<a href="http://semver.org">versionnage sémantique</a><!-- ignore --> (aussi appelé <em>SemVer</em>), qui
est une convention d'écriture de numéros de version. En réalité, <code>0.5.5</code> est
une abréviation pour <code>^0.5.5</code>, ce qui signifie “toute version qui propose une
API publique compatible avec la version 0.5.5”.</p>
<!--
Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.
-->
<p>Maintenant, sans apporter le moindre changement au code, lançons une compilation
du projet, comme dans l'encart 2-2 :</p>
<pre><code class="language-text">$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
  Downloaded libc v0.2.62
  Downloaded rand_core v0.2.2
  Downloaded rand_core v0.3.1
  Downloaded rand_core v0.4.2
   Compiling rand_core v0.4.2
   Compiling libc v0.2.62
   Compiling rand_core v0.3.1
   Compiling rand_core v0.2.2
   Compiling rand v0.5.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 s
</code></pre>
<!--
<span class="caption">Listing 2-2: The output from running `cargo build` after
adding the rand crate as a dependency</span>
-->
<p><span class="caption">Encart 2-2 : Résultat du lancement de <code>cargo build</code> après
avoir ajouté la <em>crate</em> <code>rand</code> comme dépendance</span></p>
<!--
You may see different version numbers (but they will all be compatible with
the code, thanks to SemVer!), and the lines may be in a different order.
-->
<p>Il est possible que vous ne voyiez pas exactement les mêmes numéros de version,
(mais ils seront compatibles avec votre code, grâce au <em>versionnage
sémantique</em> !), et les lignes ne seront pas forcément affichées dans le même
ordre.</p>
<!--
Now that we have an external dependency, Cargo fetches the latest versions of
everything from the *registry*, which is a copy of data from
[Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem post
their open source Rust projects for others to use.
-->
<p>Maintenant que nous avons une dépendance externe, Cargo récupère la dernière
version de tout ce qui nous faut depuis le <em>registre</em>, qui est une copie des
données de <a href="https://crates.io/">Crates.io</a>. Crates.io est là où les développeurs de
l'écosystème Rust publient leurs projets open source afin de les rendre
disponibles aux autres.</p>
<!--
After updating the registry, Cargo checks the `[dependencies]` section and
downloads any crates you don’t have yet. In this case, although we only listed
`rand` as a dependency, Cargo also grabbed `libc` and `rand_core`, because
`rand` depends on those to work. After downloading the crates, Rust compiles
them and then compiles the project with the dependencies available.
-->
<p>Une fois le registre mis à jour, Cargo lit la section <code>[dependencies]</code> et se
charge de télécharger les <em>crates</em> que vous n'avez pas encore. Dans notre cas,
bien que nous n'ayons spécifié qu'une seule dépendance, <code>rand</code>, Cargo a aussi
téléchargé la <em>crate</em> <code>libc</code> et <code>rand_core</code>, car <code>rand</code> dépend d'elles pour
fonctionner. Une fois le téléchargement terminé des <em>crates</em>, Rust les compile,
puis compile notre projet avec les dépendances disponibles.</p>
<!--
If you immediately run `cargo build` again without making any changes, you
won’t get any output aside from the `Finished` line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven’t changed anything
about them in your *Cargo.toml* file. Cargo also knows that you haven’t changed
anything about your code, so it doesn’t recompile that either. With nothing to
do, it simply exits.
-->
<p>Si vous relancez tout de suite <code>cargo build</code> sans changer quoi que ce soit, vous
n'obtiendrez rien d'autre que la ligne <code>Finished</code>. Cargo sait qu'il a déjà
téléchargé et compilé les dépendances, et que vous n'avez rien changé dans votre
fichier <em>Cargo.toml</em>. Cargo sait aussi que vous n'avez rien changé dans votre
code, donc il ne le recompile pas non plus. Étant donné qu'il n'a rien à faire,
Cargo se termine tout simplement.</p>
<!--
If you open up the *src/main.rs* file, make a trivial change, and then save it
and build again, you’ll only see two lines of output:
-->
<p>Si vous ouvrez le fichier <em>src/main.rs</em>, faites un changement très simple,
enregistrez le fichier, et relancez la compilation, vous verrez s'afficher
uniquement deux lignes :</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<!--
These lines show Cargo only updates the build with your tiny change to the
*src/main.rs* file. Your dependencies haven’t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those. It just rebuilds
your part of the code.
-->
<p>Ces lignes nous informent que Cargo a recompilé uniquement à cause de notre
petit changement dans le fichier <em>src/main.rs</em>. Les dépendances n'ayant pas
changé, Cargo sait qu'il peut simplement réutiliser ce qu'il a déjà téléchargé
et compilé précédemment. Il se contente donc de ne recompiler que notre partie
du code.</p>
<!--
#### Ensuring Reproducible Builds with the *Cargo.lock* File
-->
<h4><a class="header" href="#assurer-la-reproductibilité-des-compilations-avec-le-fichier-cargolock" id="assurer-la-reproductibilité-des-compilations-avec-le-fichier-cargolock">Assurer la reproductibilité des compilations avec le fichier <em>Cargo.lock</em></a></h4>
<!--
Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, what
happens if next week version 0.5.6 of the `rand` crate comes out and
contains an important bug fix but also contains a regression that will break
your code?
-->
<p>Cargo embarque une fonctionnalité qui garantie que vous pouvez recompiler le
même artéfact à chaque fois que vous ou quelqu'un d'autre compile votre code :
Cargo va utiliser uniquement les versions de dépendances que vous avez
utilisées jusqu'à ce que vous indiquiez le contraire.
Par exemple, que se passe-t-il si la semaine prochaine, la version 0.5.6 de la
<em>crate</em> <code>rand</code> est publiée et qu'elle apporte une correction importante, mais
aussi qu'elle produit une régression qui va casser votre code ?</p>
<!--
The answer to this problem is the *Cargo.lock* file, which was created the
first time you ran `cargo build` and is now in your *guessing_game* directory.
When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the *Cargo.lock* file. When you build your project in the future, Cargo will
see that the *Cargo.lock* file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at `0.5.5` until you explicitly upgrade, thanks to the *Cargo.lock*
file.
-->
<p>La réponse à ce problème est le fichier <em>Cargo.lock</em>, qui a été créé la première
fois que vous avez utilisé <code>cargo build</code> et qui se trouve désormais dans votre
dossier <em>guessing_game</em>. Quand vous compilez un projet pour la première fois,
Cargo détermine toutes les versions de dépendances qui correspondent à vos
critères et les écrit dans le fichier <em>Cargo.lock</em>.
Quand vous recompilerez votre projet plus tard, Cargo verra que le fichier
<em>Cargo.lock</em> existe et utilisera les versions précisées à l'intérieur au lieu
de recommencer à déterminer toutes les versions demandées.
Ceci vous permet d'avoir automatiquement des compilations reproductibles.
En d'autres termes, votre projet va rester sur la version <code>0.5.5</code> jusqu'à ce
que vous le mettiez à jour explicitement, grâce au fichier <em>Cargo.lock</em>.</p>
<!--
#### Updating a Crate to Get a New Version
-->
<h4><a class="header" href="#mettre-à-jour-une-crate-vers-sa-nouvelle-version" id="mettre-à-jour-une-crate-vers-sa-nouvelle-version">Mettre à jour une <em>crate</em> vers sa nouvelle version</a></h4>
<!--
When you *do* want to update a crate, Cargo provides another command, `update`,
which will ignore the *Cargo.lock* file and figure out all the latest versions
that fit your specifications in *Cargo.toml*. If that works, Cargo will write
those versions to the *Cargo.lock* file.
-->
<p>Lorsque vous souhaitez réellement mettre à jour une <em>crate</em>, Cargo vous fournit
une autre commande, <code>update</code>, qui va ignorer le fichier <em>Cargo.lock</em> et va
rechercher toutes les versions qui correspondent à vos critères dans
<em>Cargo.toml</em>. Si cela se passe bien, Cargo va écrire ces versions dans le
fichier <em>Cargo.lock</em>.</p>
<!--
But by default, Cargo will only look for versions greater than `0.5.5` and less
than `0.6.0`. If the `rand` crate has released two new versions, `0.5.6` and
`0.6.0`, you would see the following if you ran `cargo update`:
-->
<p>Mais par défaut, Cargo va rechercher uniquement les versions plus grandes que
<code>0.5.5</code> et inférieures à <code>0.6.0</code>. Si la <em>crate</em> <code>rand</code> a été publiée en deux
nouvelles versions, <code>0.5.6</code> et <code>0.6.0</code>, alors vous verrez ceci si vous
lancez <code>cargo update</code> :</p>
<pre><code class="language-text">$ cargo update
    Updating crates.io index
    Updating rand v0.5.5 -&gt; v0.5.6
</code></pre>
<!--
At this point, you would also notice a change in your *Cargo.lock* file noting
that the version of the `rand` crate you are now using is `0.5.6`.
-->
<p>À partir de ce moment, vous pouvez aussi constater un changement dans le fichier
<em>Cargo.lock</em> indiquant que la version de la <em>crate</em> <code>rand</code> que vous utilisez
maintenant est la <code>0.5.6</code>.</p>
<!--
If you wanted to use `rand` version `0.6.0` or any version in the `0.6.x`
series, you’d have to update the *Cargo.toml* file to look like this instead:
-->
<p>Si vous vouliez utiliser <code>rand</code> en version <code>0.6.0</code> ou toute autre version dans
la série des <code>0.6.x</code>, il vous faut mettre à jour le fichier <em>Cargo.toml</em> comme
ceci :</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.6.0&quot;
</code></pre>
<!--
The next time you run `cargo build`, Cargo will update the registry of crates
available and reevaluate your `rand` requirements according to the new version
you have specified.
-->
<p>La prochaine fois que vous lancerez <code>cargo build</code>, Cargo mettra à jour son
registre de <em>crates</em> disponibles et réévaluera vos exigences vis-à-vis de <code>rand</code>
selon la nouvelle version que vous avez spécifiée.</p>
<!--
There’s a lot more to say about [Cargo][doccargo]<!-- ignore -- > and [its
ecosystem][doccratesio]<!-- ignore -- > which we’ll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.
-->
<p>Il y a encore plus à dire à propos de <a href="http://doc.crates.io">Cargo</a><!-- ignore --> et de
<a href="http://doc.crates.io/crates-io.html">son écosystème</a><!-- ignore --> que nous aborderons au chapitre 14,
mais pour l'instant, c'est tout ce qu'il vous faut savoir. Cargo
facilite la réutilisation des bibliothèques, pour que les Rustacés soient
capables d'écrire des petits projets issus d'un assemblage d'un certain
nombre de paquets.</p>
<!--
### Generating a Random Number
-->
<h3><a class="header" href="#générer-un-nombre-aléatoire" id="générer-un-nombre-aléatoire">Générer un nombre aléatoire</a></h3>
<!--
Now that you’ve added the `rand` crate to *Cargo.toml*, let’s start using
`rand`. The next step is to update *src/main.rs*, as shown in Listing 2-3.
-->
<p>Maintenant que vous avez ajouté la <em>crate</em> <code>rand</code> dans <em>Cargo.toml</em>, commençons
à utiliser <code>rand</code>. La prochaine étape est de modifier <em>src/main.rs</em> comme dans
l'encart 2-3.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```
-->
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Devinez le nombre !&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);

    println!(&quot;Veuillez entrer un nombre.&quot;);

    let mut supposition = String::new();

    io::stdin().read_line(&amp;mut supposition)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

    println!(&quot;Votre nombre : {}&quot;, supposition);
}
</code></pre>
<!--
<span class="caption">Listing 2-3: Adding code to generate a random
number</span>
-->
<p><span class="caption">Encart 2-3 : Ajout du code pour générer un nombre
aléatoire</span></p>
<!--
First, we add a `use` line: `use rand::Rng`. The `Rng` trait defines
methods that random number generators implement, and this trait must be in
scope for us to use those methods. Chapter 10 will cover traits in detail.
-->
<p>D'abord, nous avons ajouté une ligne <code>use</code> : <code>use rand::Rng</code>. Le <em>trait</em>
<code>Rng</code> définit les méthodes implémentées par les générateurs de nombres
aléatoires, et ce <em>trait</em> doit être accessible à notre code pour qu'on puisse
utiliser ces méthodes. Le chapitre 10 expliquera plus en détail les <em>traits</em>.</p>
<!--
Next, we’re adding two lines in the middle. The `rand::thread_rng` function
will give us the particular random number generator that we’re going to use:
one that is local to the current thread of execution and seeded by the
operating system. Then we call the `gen_range` method on the random number
generator. This method is defined by the `Rng` trait that we brought into
scope with the `use rand::Rng` statement. The `gen_range` method takes two
numbers as arguments and generates a random number between them. It’s inclusive
on the lower bound but exclusive on the upper bound, so we need to specify `1`
and `101` to request a number between 1 and 100.
-->
<p>Ensuite, nous ajoutons deux lignes au milieu. La fonction <code>rand::thread_rng</code>
nous fournit le générateur de nombres aléatoires particulier que nous allons
utiliser : il est propre au fil d'exécution courant et généré par le
système d'exploitation. Ensuite, nous appelons la méthode <code>gen_range</code> sur le
générateur de nombres aléatoires. Cette méthode est définie par le <em>trait</em> <code>Rng</code>
que nous avons importé avec l'instruction <code>use rand::Rng</code>. La méthode
<code>gen_range</code> prend deux nombres en paramètres et génère un nombre aléatoire entre
ces deux bornes. Elle inclut la borne inférieure mais exclut la borne
supérieure, nous avons donc besoin de préciser <code>1</code> et <code>101</code> pour demander un
nombre entre 1 et 100.</p>
<!--
> Note: You won’t just know which traits to use and which methods and functions
> to call from a crate. Instructions for using a crate are in each crate’s
> documentation. Another neat feature of Cargo is that you can run the `cargo
> doc --open` command, which will build documentation provided by all of your
> dependencies locally and open it in your browser. If you’re interested in
> other functionality in the `rand` crate, for example, run `cargo doc --open`
> and click `rand` in the sidebar on the left.
-->
<blockquote>
<p>Remarque : vous ne pourrez pas deviner quels <em>traits</em>, méthodes et
fonctions utiliser avec une <em>crate</em>. Les instructions pour l'utilisation
d'une <em>crate</em> se trouvent dans la documentation propre à chaque <em>crate</em>. Une
autre fonctionnalité intéressante de Cargo est que vous pouvez utiliser la
commande <code>cargo doc --open</code>, qui va construire localement la documentation
intégrée par toutes vos dépendances et va l'ouvrir dans votre navigateur.
Si vous vous intéressez à d'autres fonctionnalités de la <em>crate</em> <code>rand</code>,
par exemple, vous pouvez lancer <code>cargo doc --open</code> et cliquer sur <code>rand</code>
dans la barre latérale sur la gauche.</p>
</blockquote>
<!--
The second line that we added to the middle of the code prints the secret
number. This is useful while we’re developing the program to be able to test
it, but we’ll delete it from the final version. It’s not much of a game if the
program prints the answer as soon as it starts!
-->
<p>La seconde ligne que nous avons ajoutée au milieu du code affiche le nombre
secret. C'est pratique lors du développement pour pouvoir le tester, mais nous
l'enlèverons dans la version finale. Ce n'est pas vraiment un jeu si le
programme affiche la réponse dès qu'il démarre !</p>
<!--
Try running the program a few times:
-->
<p>Essayez de lancer le programme plusieurs fois :</p>
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```
-->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 7
Veuillez entrer un nombre.
4
Votre nombre : 4
$ cargo run
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 83
Veuillez entrer un nombre.
5
Votre nombre : 5
</code></pre>
<!--
You should get different random numbers, and they should all be numbers between
1 and 100. Great job!
-->
<p>Vous devriez obtenir des nombres aléatoires différents, et ils devraient être
tous compris entre 1 et 100. Beau travail !</p>
<!--
## Comparing the Guess to the Secret Number
-->
<h2><a class="header" href="#comparer-le-nombre-saisi-au-nombre-secret" id="comparer-le-nombre-saisi-au-nombre-secret">Comparer le nombre saisi au nombre secret</a></h2>
<!--
Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won’t compile quite yet, as we
will explain.
-->
<p>Maintenant que nous avons une saisie utilisateur et un nombre aléatoire, nous
pouvons les comparer. Cette étape est écrite dans l'encart 2-4. Sachez toutefois
que le code ne se compile pas encore, nous allons l'expliquer par la suite.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // ---snip---

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // --- code inchangé masqué ici ---

    println!(&quot;Votre nombre : {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-4: Handling the possible return values of
comparing two numbers</span>
-->
<p><span class="caption">Encart 2-4 : Traitement des valeurs possibles saisies en
comparant les deux nombres</span></p>
<!--
The first new bit here is another `use` statement, bringing a type called
`std::cmp::Ordering` into scope from the standard library. Like `Result`,
`Ordering` is another enum, but the variants for `Ordering` are `Less`,
`Greater`, and `Equal`. These are the three outcomes that are possible when you
compare two values.
-->
<p>La première nouveauté ici est une nouvelle utilisation de l'instruction <code>use</code>,
qui importe <code>std::cmp::Ordering</code> à portée de notre code depuis la
bibliothèque standard. Comme <code>Result</code>, <code>Ordering</code> est une autre énumération,
mais les variantes pour <code>Ordering</code> sont <code>Less</code> <em>(inférieur)</em>, <code>Greater</code>
<em>(supérieur)</em> et <code>Equal</code> <em>(égal)</em>.
Ce sont les trois issues possibles lorsqu'on compare deux valeurs.</p>
<!--
Then we add five new lines at the bottom that use the `Ordering` type. The
`cmp` method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing the `guess` to the `secret_number`. Then it returns a variant of the
`Ordering` enum we brought into scope with the `use` statement. We use a
[`match`][match]<!-- ignore -- > expression to decide what to do next based on
which variant of `Ordering` was returned from the call to `cmp` with the values
in `guess` and `secret_number`.
-->
<p>Ensuite, nous ajoutons cinq nouvelles lignes à la fin qui utilisent le type
<code>Ordering</code>. La méthode <code>cmp</code> compare deux valeurs et peut être appelée sur
tout ce qui peut être comparé. Elle prend en paramètre une référence de ce qu'on
veut comparer : ici, nous voulons comparer <code>supposition</code> et <code>nombre_secret</code>.
Ensuite, cela retourne une variante de l'énumération <code>Ordering</code> que nous avons
importée avec l'instruction <code>use</code>. Nous utilisons une expression
<a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> pour décider quoi faire ensuite en fonction de
quelle variante de <code>Ordering</code> a été retournée à l'appel de <code>cmp</code> avec
<code>supposition</code> et <code>nombre_secret</code>.</p>
<!--
A `match` expression is made up of *arms*. An arm consists of a *pattern* and
the code that should be run if the value given to the beginning of the `match`
expression fits that arm’s pattern. Rust takes the value given to `match` and
looks through each arm’s pattern in turn. The `match` construct and patterns
are powerful features in Rust that let you express a variety of situations your
code might encounter and make sure that you handle them all. These features
will be covered in detail in Chapter 6 and Chapter 18, respectively.
-->
<p>Une expression <code>match</code> est composée de <em>branches</em>. Une branche est constituée
d'un <em>motif (pattern)</em> et du code qui sera exécuté si la valeur donnée
au début de l'expression <code>match</code> correspond bien au motif de cette
branche. Rust prend la valeur donnée à <code>match</code> et la compare au motif de
chaque branche à tour de rôle.
La structure de contrôle <code>match</code> et les motifs sont des
fonctionnalités puissantes de Rust qui vous permettent de décrire une multitude
de scénarios que votre code peut rencontrer et de s'assurer que vous les gérez
toutes. Ces fonctionnalités seront expliquées plus en détail respectivement dans
le chapitre 6 et le chapitre 18.</p>
<!--
Let’s walk through an example of what would happen with the `match` expression
used here. Say that the user has guessed 50 and the randomly generated secret
number this time is 38. When the code compares 50 to 38, the `cmp` method will
return `Ordering::Greater`, because 50 is greater than 38. The `match`
expression gets the `Ordering::Greater` value and starts checking each arm’s
pattern. It looks at the first arm’s pattern, `Ordering::Less`, and sees that
the value `Ordering::Greater` does not match `Ordering::Less`, so it ignores
the code in that arm and moves to the next arm. The next arm’s pattern,
`Ordering::Greater`, *does* match `Ordering::Greater`! The associated code in
that arm will execute and print `Too big!` to the screen. The `match`
expression ends because it has no need to look at the last arm in this scenario.
-->
<p>Voyons un exemple de ce qui se passerait avec l'expression <code>match</code> utilisée
ici. Disons que l'utilisateur a saisi le nombre 50 et que le nombre secret
généré aléatoirement a cette fois-ci comme valeur 38. Quand le code compare 50 à
38, la méthode <code>cmp</code> va retourner <code>Ordering::Greater</code>, car 50 est plus grand
que 38. L'expression <code>match</code> obtient la valeur <code>Ordering::Greater</code> et commence à
vérifier le motif de chaque branche.
Elle consulte le motif de la première branche, <code>Ordering::Less</code> et remarque que
la valeur <code>Ordering::Greater</code> ne correspond pas au motif <code>Ordering::Less</code> ;
elle ignore donc le code de cette branche et passe à la suivante.
Le motif de la branche suivante, <code>Ordering::Greater</code>, correspond à
<code>Ordering::Greater</code> ! Le code associé à cette branche va être exécuté et va
afficher à l'écran <code>C'est moins !</code>. L'expression <code>match</code> se termine ensuite, car
elle n'a pas besoin de consulter les autres branches de ce scénario.</p>
<!--
However, the code in Listing 2-4 won’t compile yet. Let’s try it:
-->
<p>Cependant, notre code dans l'encart 2-4 ne compile pas encore. Essayons de le
faire :</p>
<!-- markdownlint-disable -->
<!--
```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  -- > src/main.rs:23:21
   |
23 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer
   |
   = note: expected type `&std::string::String`
   = note:    found type `&{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
```
-->
<!-- markdownlint-restore -->
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  -- &gt; src/main.rs:23:21
   |
23 |     match supposition.cmp(&amp;nombre_secret) {
   |                           ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<!--
The core of the error states that there are *mismatched types*. Rust has a
strong, static type system. However, it also has type inference. When we wrote
`let mut guess = String::new()`, Rust was able to infer that `guess` should be
a `String` and didn’t make us write the type. The `secret_number`, on the other
hand, is a number type. A few number types can have a value between 1 and 100:
`i32`, a 32-bit number; `u32`, an unsigned 32-bit number; `i64`, a 64-bit
number; as well as others. Rust defaults to an `i32`, which is the type of
`secret_number` unless you add type information elsewhere that would cause Rust
to infer a different numerical type. The reason for the error is that Rust
cannot compare a string and a number type.
-->
<p>Le message d'erreur nous indique que nous sommes dans un cas de types non
compatibles <em>(mismatched types)</em>. Rust a un système de types fort et statique.
Cependant, il a aussi une fonctionnalité d'inférence de type. Quand nous avons
écrit <code>let mut supposition = String::new()</code>, Rust a pu en déduire que
<code>supposition</code> devait être une <code>String</code> et ne nous a pas demandé d'écrire le
type. D'autre part, <code>nombre_secret</code> est d'un type de nombre.
Quelques types de nombres peuvent avoir une valeur entre 1 et 100 : <code>i32</code>, un
nombre entier encodé sur 32 bits ; <code>u32</code>, un nombre entier de 32 bits non signé
(positif ou nul) ; <code>i64</code>, un nombre entier encodé sur 64 bits ; parmi
tant d'autres. Rust utilise par défaut un <code>i32</code>, qui est le type
de <code>nombre_secret</code>, à moins que vous précisiez quelque part une information de
type qui amènerait Rust à inférer un type de nombre différent. La raison de
cette erreur est que Rust ne peut pas comparer une chaîne de caractères à un
nombre.</p>
<!--
Ultimately, we want to convert the `String` the program reads as input into a
real number type so we can compare it numerically to the secret number. We can
do that by adding the following two lines to the `main` function body:
-->
<p>Au bout du compte, nous voulons convertir la <code>String</code> que le programme récupère
de la saisie utilisateur en un nombre, pour qu'on puisse la comparer
numériquement au nombre secret. Nous pouvons faire ceci en ajoutant les deux
lignes suivantes dans le corps de la fonction <code>main</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
// --snip--

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```
-->
<pre><code class="language-rust ignore">// -- code inchangé masqué ici --

    let mut supposition = String::new();

    io::stdin().read_line(&amp;mut supposition)
        .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

    let supposition: u32 = supposition.trim().parse()
        .expect(&quot;Veuillez entrer un nombre !&quot;);

    println!(&quot;Votre nombre : {}&quot;, supposition);

    match supposition.cmp(&amp;nombre_secret) {
        Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
        Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
        Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
    }
}
</code></pre>
<!--
The two new lines are:
-->
<p>Les deux nouvelles lignes sont :</p>
<!--
```rust,ignore
let guess: u32 = guess.trim().parse()
    .expect("Please type a number!");
```
-->
<pre><code class="language-rust ignore">let supposition: u32 = supposition.trim().parse()
    .expect(&quot;Veuillez entrer un nombre !&quot;);
</code></pre>
<!--
We create a variable named `guess`. But wait, doesn’t the program already have
a variable named `guess`? It does, but Rust allows us to *shadow* the previous
value of `guess` with a new one. This feature is often used in situations in
which you want to convert a value from one type to another type. Shadowing lets
us reuse the `guess` variable name rather than forcing us to create two unique
variables, such as `guess_str` and `guess` for example. (Chapter 3 covers
shadowing in more detail.)
-->
<p>Nous créons une variable qui s'appelle <code>supposition</code>. Mais attendez, le
programme n'a-t-il pas déjà une variable qui s'appelle <code>supposition</code> ?
C'est le cas, mais Rust nous permet de <em>masquer</em> la valeur précédente de
<code>supposition</code> avec une nouvelle.
Cette fonctionnalité est souvent utilisée dans des
situations où on veut convertir une valeur d'un type à un autre.
Le masquage <em>(shadowing)</em> nous permet de réutiliser le nom de variable
<code>supposition</code>, plutôt que de nous forcer à créer deux variables distinctes,
telles que <code>supposition_str</code> et <code>supposition</code> par exemple.
(Le chapitre 3 expliquera plus en détail le masquage.)</p>
<!--
We bind `guess` to the expression `guess.trim().parse()`. The `guess` in the
expression refers to the original `guess` that was a `String` with the input in
it. The `trim` method on a `String` instance will eliminate any whitespace at
the beginning and end. Although `u32` can contain only numerical characters,
the user must press <span class="keystroke">enter</span> to satisfy
`read_line`. When the user presses <span class="keystroke">enter</span>, a
newline character is added to the string. For example, if the user types <span
class="keystroke">5</span> and presses <span class="keystroke">enter</span>,
`guess` looks like this: `5\n`. The `\n` represents “newline,” the result of
pressing <span class="keystroke">enter</span>. The `trim` method eliminates
`\n`, resulting in just `5`.
-->
<p>Nous lions <code>supposition</code> à l'expression <code>supposition.trim().parse()</code>. Le
<code>supposition</code> dans l'expression se réfère au <code>supposition</code> initial qui était une
<code>String</code> contenant la saisie utilisateur. La méthode <code>trim</code> sur une instance
de <code>String</code> va enlever les espaces et autres <em>whitespaces</em> au début et à la fin.
Même si <code>u32</code> ne peut contenir que des chiffres, l'utilisateur doit
appuyer sur <span class="keystroke">entrée</span> pour mettre fin à <code>read_line</code>.
Lorsque l'utilisateur appuie sur
<span class="keystroke">entrée</span>, un caractère de fin de ligne
est ajouté à la chaîne de caractères. Par exemple, si l'utilisateur écrit
<span class="keystroke">5</span> et appuie sur <span class="keystroke">
entrée</span>, <code>supposition</code> aura alors cette valeur : <code>5\n</code>.
Le <code>\n</code> représente une fin de ligne, qui résulte de l'appui sur
<span class="keystroke">entrée</span>. La méthode <code>trim</code> enlève <code>\n</code>, il ne
reste donc plus que <code>5</code>.</p>
<!--
The [`parse` method on strings][parse]<!-- ignore -- > parses a string into some
kind of number. Because this method can parse a variety of number types, we
need to tell Rust the exact number type we want by using `let guess: u32`. The
colon (`:`) after `guess` tells Rust we’ll annotate the variable’s type. Rust
has a few built-in number types; the `u32` seen here is an unsigned, 32-bit
integer. It’s a good default choice for a small positive number. You’ll learn
about other number types in Chapter 3. Additionally, the `u32` annotation in
this example program and the comparison with `secret_number` means that Rust
will infer that `secret_number` should be a `u32` as well. So now the
comparison will be between two values of the same type!
-->
<p>La <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">méthode <code>parse</code> des chaînes de caractères</a><!-- ignore --> interprète
une chaîne de caractères en une sorte de nombre. Comme cette méthode peut
interpréter plusieurs types de nombres, nous devons indiquer à Rust le type
exact de nombre que nous voulons en utilisant <code>let supposition: u32</code>.
Le deux-points (<code>:</code>) après <code>supposition</code> indique à Rust que nous voulons
préciser le type de la variable.
Rust embarque quelques types de nombres ; le <code>u32</code> utilisé ici est un
entier non signé sur 32 bits.
C'est un bon choix par défaut pour un petit nombre positif.
Vous découvrirez d'autres types de nombres dans le chapitre 3.
De plus, l'annotation <code>u32</code> dans ce programme d'exemple et la
comparaison avec <code>nombre_secret</code> permet à Rust d'en déduire que <code>nombre_secret</code>
doit être lui aussi un <code>u32</code>. Donc maintenant, la comparaison se fera
entre deux valeurs du même type !</p>
<!-- [parse]: ../std/primitive.str.html#method.parse -->
<!--
The call to `parse` could easily cause an error. If, for example, the string
contained `A👍%`, there would be no way to convert that to a number. Because it
might fail, the `parse` method returns a `Result` type, much as the `read_line`
method does (discussed earlier in [“Handling Potential Failure with the
`Result` Type”](#handling-potential-failure-with-the-result-type)<!-- ignore
-- >). We’ll treat this `Result` the same way by using the `expect` method
again. If `parse` returns an `Err` `Result` variant because it couldn’t create
a number from the string, the `expect` call will crash the game and print the
message we give it. If `parse` can successfully convert the string to a number,
it will return the `Ok` variant of `Result`, and `expect` will return the
number that we want from the `Ok` value.
-->
<p>L'utilisation de <code>parse</code> peut facilement mener à une erreur. Si par exemple,
le texte contient <code>A👍%</code>, il ne sera pas possible de le convertir en nombre.
Comme elle peut échouer, la méthode <code>parse</code> retourne un type <code>Result</code>, comme
celui que la méthode <code>read_line</code> retourne (comme nous l'avons vu plus tôt dans
<a href="ch02-00-guessing-game-tutorial.html#g%C3%A9rer-les-erreurs-potentielles-avec-le-type-result">“Gérer les erreurs potentielles avec le type
<code>Result</code>”</a><!-- ignore-->).
Nous allons gérer ce <code>Result</code> de la même manière, avec à nouveau la méthode
<code>expect</code>. Si <code>parse</code> retourne une variante <code>Err</code> de <code>Result</code> car elle ne peut
pas créer un nombre à partir de la chaîne de caractères, l'appel à
<code>expect</code> va faire planter le jeu et va afficher le message que nous lui avons
passé en paramètre. Si <code>parse</code> arrive à convertir la chaîne de caractères en
nombre, alors elle retournera la variante <code>Ok</code> de <code>Result</code>, et <code>expect</code> va
retourner le nombre qu'il nous faut qui est stocké dans la variante <code>Ok</code>.</p>
<!--
Let’s run the program now!
-->
<p>Exécutons ce programme, maintenant !</p>
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```
-->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 58
Veuillez entrer un nombre.
  76
Votre nombre : 76
C'est moins !
</code></pre>
<!--
Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.
-->
<p>Très bien !
Même si des espaces ont été ajoutées avant la supposition, le programme a quand
même compris que l'utilisateur a saisi 76. Lancez le programme plusieurs
fois pour vérifier qu'il se comporte correctement avec différentes saisies :
devinez le nombre correctement, saisissez un nombre qui est trop grand, et
saisissez un nombre qui est trop petit.</p>
<!--
We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!
-->
<p>La majeure partie du jeu fonctionne désormais, mais l'utilisateur ne peut faire
qu'une seule supposition. Corrigeons cela en ajoutant une boucle !</p>
<!--
## Allowing Multiple Guesses with Looping
-->
<h2><a class="header" href="#permettre-plusieurs-suppositions-avec-les-boucles" id="permettre-plusieurs-suppositions-avec-les-boucles">Permettre plusieurs suppositions avec les boucles</a></h2>
<!--
The `loop` keyword creates an infinite loop. We’ll add that now to give users
more chances at guessing the number:
-->
<p>Le mot-clé <code>loop</code> crée une boucle infinie. C'est ce que nous allons ajouter pour
donner aux utilisateurs plus de chances de deviner le nombre :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
```
-->
<pre><code class="language-rust ignore">// -- code inchangé masqué ici --

    println!(&quot;Le nombre secret est : {}&quot;, nombre_secret);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        // -- code inchangé masqué ici --

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
            Ordering::Equal =&gt; println!(&quot;Vous avez gagné !&quot;),
        }
    }
}
</code></pre>
<!--
As you can see, we’ve moved everything into a loop from the guess input prompt
onward. Be sure to indent the lines inside the loop another four spaces each
and run the program again. Notice that there is a new problem because the
program is doing exactly what we told it to do: ask for another guess forever!
It doesn’t seem like the user can quit!
-->
<p>Comme vous pouvez le remarquer, nous avons déplacé dans une boucle tout le
code à partir de l'invite à entrer le nombre. Assurez-vous d'indenter
correctement les lignes dans la boucle avec quatre nouvelles espaces pour
chacune, et lancez à nouveau le programme. Notez bien qu'il y a un nouveau
problème, car le programme fait exactement ce que nous lui avons demandé de
faire : demander un nombre à l'infini ! Il n'est pas possible pour l'utilisateur
de l'arrêter !</p>
<!--
The user could always interrupt the program by using the keyboard shortcut <span
class="keystroke">ctrl-c</span>. But there’s another way to escape this
insatiable monster, as mentioned in the `parse` discussion in [“Comparing the
Guess to the Secret Number”](#comparing-the-guess-to-the-secret-number)<!--
ignore -- >: if the user enters a non-number answer, the program will crash. The
user can take advantage of that in order to quit, as shown here:
-->
<p>L'utilisateur pourrait quand même interrompre le programme en utilisant le
raccourci clavier <span class="keystroke">ctrl-c</span>.
Mais il y a une autre façon d'échapper à ce monstre insatiable, comme nous
l'avons abordé dans la partie <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au nombre
secret”</a><!-- ignore --> : si
l'utilisateur saisit quelque chose qui n'est pas un nombre, le programme va
planter. L'utilisateur peut procéder ainsi pour le quitter, comme ci-dessous :</p>
<!-- markdownlint-disable -->
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
```
-->
<!-- markdownlint-restore -->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 59
Veuillez entrer un nombre.
45
Votre nombre : 45
C'est plus !
Veuillez entrer un nombre.
60
Votre nombre : 60
C'est moins !
Veuillez entrer un nombre.
59
Votre nombre : 59
Vous avez gagné !
Veuillez entrer un nombre.
quitter
thread 'main' panicked at 'Veuillez entrer un nombre !: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/supposition` (exit code: 101)
</code></pre>
<!--
Typing `quit` actually quits the game, but so will any other non-number input.
However, this is suboptimal to say the least. We want the game to automatically
stop when the correct number is guessed.
-->
<p>Taper <code>quitter</code> ferme bien le jeu, mais toute autre saisie qui n'est pas un
nombre le ferait aussi.
Cependant, ce mécanisme laisse franchement à désirer. Nous voudrions que le jeu
s'arrête automatiquement lorsque le bon nombre est deviné.</p>
<!--
### Quitting After a Correct Guess
-->
<h3><a class="header" href="#arrêter-le-programme-après-avoir-gagné" id="arrêter-le-programme-après-avoir-gagné">Arrêter le programme après avoir gagné</a></h3>
<!--
Let’s program the game to quit when the user wins by adding a `break` statement:
-->
<p>Faisons en sorte que le jeu s'arrête quand le joueur gagne en ajoutant
l'instruction <code>break</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
// --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore">// -- code inchangé masqué ici --

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagné !&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
Adding the `break` line after `You win!` makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of `main`.
-->
<p>Ajouter la ligne <code>break</code> après <code>Vous avez gagné !</code> fait sortir le programme de
la boucle quand le joueur a correctement deviné le nombre secret. Et quitter la
boucle veut aussi dire terminer le programme, car ici la boucle est la dernière
partie de <code>main</code>.</p>
<!--
### Handling Invalid Input
-->
<h3><a class="header" href="#gérer-les-saisies-invalides" id="gérer-les-saisies-invalides">Gérer les saisies invalides</a></h3>
<!--
To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where `guess`
is converted from a `String` to a `u32`, as shown in Listing 2-5.
-->
<p>Pour améliorer le comportement du jeu, plutôt que de faire planter le programme
quand l'utilisateur saisit quelque chose qui n'est pas un nombre, faisons en
sorte que le jeu ignore ce qui n'est pas un nombre afin que l'utilisateur puisse
continuer à essayer de deviner. Nous pouvons faire ceci en modifiant la ligne où
<code>supposition</code> est converti d'une <code>String</code> en un <code>u32</code>, comme dans l'encart 2-5 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
// --snip--

io::stdin().read_line(&mut guess)
    .expect("Failed to read line");

let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};

println!("You guessed: {}", guess);

// --snip--
```
-->
<pre><code class="language-rust ignore">// -- code inchangé masqué ici --

io::stdin().read_line(&amp;mut supposition)
    .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

let supposition: u32 = match supposition.trim().parse() {
    Ok(nombre) =&gt; nombre,
    Err(_) =&gt; continue,
};

println!(&quot;Votre nombre : {}&quot;, supposition);

// -- code inchangé masqué ici --
</code></pre>
<!--
<span class="caption">Listing 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span>
-->
<p><span class="caption">Encart 2-5 : Ignorer une saisie qui n'est pas un nombre
et demander un nouveau nombre plutôt que de faire planter le programme</span></p>
<!--
Switching from an `expect` call to a `match` expression is how you generally
move from crashing on an error to handling the error. Remember that `parse`
returns a `Result` type and `Result` is an enum that has the variants `Ok` or
`Err`. We’re using a `match` expression here, as we did with the `Ordering`
result of the `cmp` method.
-->
<p>Remplacer un appel à <code>expect</code> par une expression <code>match</code> est la technique qu'on
utilise en général pour passer d'une erreur qui fait planter le programme à une
erreur proprement gérée. N'oubliez pas que
<code>parse</code> retourne un type <code>Result</code> et que <code>Result</code> est une énumération qui a pour
variantes <code>Ok</code> ou <code>Err</code>. Nous utilisons ici une expression <code>match</code> comme nous
l'avons déjà fait avec le résultat de type <code>Ordering</code> de la méthode <code>cmp</code>.</p>
<!--
If `parse` is able to successfully turn the string into a number, it will
return an `Ok` value that contains the resulting number. That `Ok` value will
match the first arm’s pattern, and the `match` expression will just return the
`num` value that `parse` produced and put inside the `Ok` value. That number
will end up right where we want it in the new `guess` variable we’re creating.
-->
<p>Si <code>parse</code> arrive à convertir la chaîne de caractères en nombre, cela va
retourner la variante <code>Ok</code> qui contient le nombre qui en résulte. Cette variante
va correspondre au motif de la première branche, et l'expression <code>match</code> va
simplement retourner la valeur de <code>nombre</code> que <code>parse</code> a trouvée et qu'elle a
mise dans la variante <code>Ok</code>.
Ce nombre va se retrouver là où nous en avons besoin,
dans la variable <code>supposition</code> que nous sommes en train de créer.</p>
<!--
If `parse` is *not* able to turn the string into a number, it will return an
`Err` value that contains more information about the error. The `Err` value
does not match the `Ok(num)` pattern in the first `match` arm, but it does
match the `Err(_)` pattern in the second arm. The underscore, `_`, is a
catchall value; in this example, we’re saying we want to match all `Err`
values, no matter what information they have inside them. So the program will
execute the second arm’s code, `continue`, which tells the program to go to the
next iteration of the `loop` and ask for another guess. So, effectively, the
program ignores all errors that `parse` might encounter!
-->
<p>Si <code>parse</code> n'arrive <em>pas</em> à convertir la chaîne de caractères en nombre, elle
va retourner la variante <code>Err</code> qui contient plus d'informations sur l'erreur. La
variante <code>Err</code> ne correspond pas au motif <code>Ok(nombre)</code> de la première branche,
mais elle correspond au motif <code>Err(_)</code> de la seconde branche. Le tiret bas,
<code>_</code>, est une valeur passe-partout ; dans notre exemple, nous disons
que nous voulons correspondre à toutes les valeurs de <code>Err</code>, peu importe quelle
information elles ont à l'intérieur d'elles-mêmes. Donc le programme va exécuter
le code de la seconde branche, <code>continue</code>, qui indique au programme de se rendre
à la prochaine itération de <code>loop</code> et de demander un nouveau nombre. Ainsi, le
programme ignore toutes les erreurs que <code>parse</code> pourrait rencontrer !</p>
<!--
Now everything in the program should work as expected. Let’s try it:
-->
<p>Maintenant, le programme devrait fonctionner correctement. Essayons-le :</p>
<!--
```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```
-->
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Devinez le nombre !
Le nombre secret est : 61
Veuillez entrer un nombre.
10
Votre nombre : 10
C'est plus !
Veuillez entrer un nombre.
99
Votre nombre : 99
C'est moins !
Veuillez entrer un nombre.
foo
Veuillez entrer un nombre.
61
Votre nombre : 61
Vous avez gagné !
</code></pre>
<!--
Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the `println!` that outputs the
secret number. Listing 2-6 shows the final code.
-->
<p>Super ! Avec notre petite touche finale, nous avons fini notre jeu de
devinettes. Rappelez-vous que le programme affiche toujours le nombre secret.
C'était pratique pour les tests, mais cela gâche le jeu. Supprimons le
<code>println!</code> qui affiche le nombre secret. L'encart 2-6 représente le code final.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
-->
<pre><code class="language-rust ignore">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Devinez le nombre !&quot;);

    let nombre_secret = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Veuillez entrer un nombre.&quot;);

        let mut supposition = String::new();

        io::stdin().read_line(&amp;mut supposition)
            .expect(&quot;Échec de la lecture de l'entrée utilisateur&quot;);

        let supposition: u32 = match supposition.trim().parse() {
            Ok(nombre) =&gt; nombre,
            Err(_) =&gt; continue,
        };

        println!(&quot;Votre nombre : {}&quot;, supposition);

        match supposition.cmp(&amp;nombre_secret) {
            Ordering::Less =&gt; println!(&quot;C'est plus !&quot;),
            Ordering::Greater =&gt; println!(&quot;C'est moins !&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Vous avez gagné !&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-6: Complete guessing game code</span>
-->
<p><span class="caption">Encart 2-6 : Code complet du jeu de devinettes</span></p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé-1" id="résumé-1">Résumé</a></h2>
<!--
At this point, you’ve successfully built the guessing game. Congratulations!
-->
<p>Si vous êtes arrivé jusqu'ici, c'est que vous avez construit avec succès le jeu
de devinettes. Félicitations !</p>
<!--
This project was a hands-on way to introduce you to many new Rust concepts:
`let`, `match`, methods, associated functions, the use of external crates, and
more. In the next few chapters, you’ll learn about these concepts in more
detail. Chapter 3 covers concepts that most programming languages have, such as
variables, data types, and functions, and shows how to use them in Rust.
Chapter 4 explores ownership, a feature that makes Rust different from other
languages. Chapter 5 discusses structs and method syntax, and Chapter 6
explains how enums work.
-->
<p>Ce projet était une mise en pratique pour vous initier à de nombreux concepts de
Rust : <code>let</code>, <code>match</code>, les méthodes, les fonctions associées, l'utilisation de
<em>crates</em> externes, et bien plus. Dans les prochains chapitres, vous allez en
apprendre plus sur ces concepts. Le chapitre 3 va traiter des concepts utilisés
par la plupart des langages de programmation, comme les variables, les types de
données, et les fonctions, et vous montrera comment les utiliser avec Rust. Le
chapitre 4 expliquera la possession <em>(ownership)</em>, qui est une fonctionnalité
qui distingue Rust des autres langages. Le chapitre 5 abordera les structures et
les syntaxes des méthodes, et le chapitre 6 expliquera comment les énumérations
fonctionnent.</p>
<!--
[variables-and-mutability]:
ch03-01-variables-and-mutability.html#variables-and-mutability
-->
<!--
# Common Programming Concepts
-->
<h1><a class="header" href="#les-concepts-courants-de-programmation" id="les-concepts-courants-de-programmation">Les concepts courants de programmation</a></h1>
<!--
This chapter covers concepts that appear in almost every programming language
and how they work in Rust. Many programming languages have much in common at
their core. None of the concepts presented in this chapter are unique to Rust,
but we’ll discuss them in the context of Rust and explain the conventions
around using these concepts.
-->
<p>Ce chapitre explique des concepts qui apparaissent dans presque tous les
langages de programmation, et la manière dont ils fonctionnent en Rust. De
nombreux langages sont basés sur des concepts communs. Les concepts présentés
dans ce chapitre ne sont pas spécifiques à Rust, mais nous les appliquerons
à Rust et nous expliquerons les conventions qui leur sont liées.</p>
<!--
Specifically, you’ll learn about variables, basic types, functions, comments,
and control flow. These foundations will be in every Rust program, and learning
them early will give you a strong core to start from.
-->
<p>Plus précisément, vous allez apprendre les concepts de variables, les types de
base, les fonctions, les commentaires, et les structures de contrôle. Ces
notions fondamentales seront présentes dans tous les programmes Rust, et les
apprendre dès le début vous procurera de solides bases pour débuter.</p>
<!--
> #### Keywords
>
> The Rust language has a set of *keywords* that are reserved for use by
> the language only, much as in other languages. Keep in mind that you cannot
> use these words as names of variables or functions. Most of the keywords have
> special meanings, and you’ll be using them to do various tasks in your Rust
> programs; a few have no current functionality associated with them but have
> been reserved for functionality that might be added to Rust in the future. You
> can find a list of the keywords in Appendix A.
-->
<blockquote>
<h4><a class="header" href="#mots-clés" id="mots-clés">Mots-clés</a></h4>
<p>Le langage Rust possède un ensemble de <em>mots-clés</em> qui ont été réservés pour
l'usage exclusif du langage, tout comme le font d'autres langages. Gardez à
l'esprit que vous ne pouvez pas utiliser ces mots pour des noms de variables
ou de fonctions. La plupart des mots-clés ont une signification spéciale, et
vous les utiliserez pour réaliser de différentes tâches dans vos programmes
Rust ; quelques-uns n'ont aucune fonctionnalité active pour le moment, mais
ont été réservés pour être ajoutés plus tard à Rust.
Vous pouvez trouver la liste de ces mots-clés dans l'annexe A.</p>
</blockquote>
<!--
## Variables and Mutability
-->
<h2><a class="header" href="#les-variables-et-la-mutabilité" id="les-variables-et-la-mutabilité">Les variables et la mutabilité</a></h2>
<!--
As mentioned in Chapter 2, by default variables are immutable. This is one of
many nudges Rust gives you to write your code in a way that takes advantage of
the safety and easy concurrency that Rust offers. However, you still have the
option to make your variables mutable. Let’s explore how and why Rust
encourages you to favor immutability and why sometimes you might want to opt
out.
-->
<p>Tel qu'abordé au chapitre 2, par défaut, les variables sont <em>immuables</em>. C'est
un des nombreux coups de pouce de Rust pour écrire votre code de façon à
garantir la sécurité et la concurrence sans problème. Cependant, vous avez quand
même la possibilité de rendre vos variables mutables <em>(modifiables)</em>. Explorons
comment et pourquoi Rust vous encourage à favoriser l'immuabilité, et pourquoi
parfois vous pourriez choisir d'y renoncer.</p>
<!--
When a variable is immutable, once a value is bound to a name, you can’t change
that value. To illustrate this, let’s generate a new project called *variables*
in your *projects* directory by using `cargo new variables`.
-->
<p>Lorsqu'une variable est immuable, cela signifie qu'une fois qu'une valeur est
liée à un nom, vous ne pouvez pas changer cette valeur. À titre d'illustration,
générons un nouveau projet appelé <em>variables</em> dans votre dossier <em>projects</em> en
utilisant <code>cargo new variables</code>.</p>
<!--
Then, in your new *variables* directory, open *src/main.rs* and replace its
code with the following code that won’t compile just yet:
-->
<p>Ensuite, dans votre nouveau dossier <em>variables</em>, ouvrez <em>src/main.rs</em> et
remplacez son code par le code suivant qui ne compile pas pour le moment :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;La valeur de x est : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre>
<!--
Save and run the program using `cargo run`. You should receive an error
message, as shown in this output:
-->
<p>Sauvegardez et lancez le programme en utilisant <code>cargo run</code>. Vous devriez
avoir un message d'erreur comme celui-ci :</p>
<!--
```text
error[E0384]: cannot assign twice to immutable variable `x`
 -- > src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```
-->
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;La valeur de x est : {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<!--
This example shows how the compiler helps you find errors in your programs.
Even though compiler errors can be frustrating, they only mean your program
isn’t safely doing what you want it to do yet; they do *not* mean that you’re
not a good programmer! Experienced Rustaceans still get compiler errors.
-->
<p>Cet exemple montre comment le compilateur vous aide à trouver les erreurs dans
vos programmes. Même si les erreurs de compilation peuvent s'avérer frustrantes,
elles signifient uniquement que, pour le moment, votre programme n'est pas en
train de faire ce que vous voulez qu'il fasse en toute sécurité ; elles ne
signifient <em>pas</em> que vous êtes un mauvais développeur ! Même les Rustacés
expérimentés continuent d'avoir des erreurs de compilation.</p>
<!--
The error message indicates that the cause of the error is that you `cannot
assign twice to immutable variable x`, because you tried to assign a second
value to the immutable `x` variable.
-->
<p>Ce message d'erreur indique que la cause du problème est qu'il est <em>impossible
d'assigner à deux reprises la variable immuable <code>x</code></em> (<code>cannot assign twice to immutable variable x</code>).</p>
<!--
It’s important that we get compile-time errors when we attempt to change a
value that we previously designated as immutable because this very situation
can lead to bugs. If one part of our code operates on the assumption that a
value will never change and another part of our code changes that value, it’s
possible that the first part of the code won’t do what it was designed to do.
The cause of this kind of bug can be difficult to track down after the fact,
especially when the second piece of code changes the value only *sometimes*.
-->
<p>Il est important que nous obtenions des erreurs au moment de la compilation
lorsque nous essayons de changer une valeur qui a précédemment été déclarée
comme immuable, car cette situation particulière peut donner lieu à des bogues.
Si une partie de notre code part du principe qu'une valeur ne changera jamais et
qu'une autre partie de notre code modifie cette valeur, il est possible que la
première partie du code ne fasse pas ce pour quoi elle a été conçue. La cause de
ce genre de bogue peut être difficile à localiser après coup, en particulier
lorsque la seconde partie du code ne modifie que <em>parfois</em> cette valeur.</p>
<!--
In Rust, the compiler guarantees that when you state that a value won’t change,
it really won’t change. That means that when you’re reading and writing code,
you don’t have to keep track of how and where a value might change. Your code
is thus easier to reason through.
-->
<p>Avec Rust, le compilateur garantit que lorsque nous déclarons qu'une variable ne
changera pas, elle ne changera vraiment pas. Cela signifie que lorsque vous
lisez et écrivez du code, vous n'avez pas à vous soucier d'où et comment la
valeur pourrait changer. Votre code est ainsi plus facile à comprendre.</p>
<!--
But mutability can be very useful. Variables are immutable only by default; as
you did in Chapter 2, you can make them mutable by adding `mut` in front of the
variable name. In addition to allowing this value to change, `mut` conveys
intent to future readers of the code by indicating that other parts of the code
will be changing this variable’s value.
-->
<p>Mais la mutabilité peut s'avérer très utile. Les variables sont immuables par
défaut ; mais comme vous l'avez fait au chapitre 2, vous pouvez les rendre
mutables en ajoutant <code>mut</code> devant le nom de la variable. En plus de permettre à
cette valeur de changer, <code>mut</code> va signaler l'intention aux futurs lecteurs de ce
code que d'autres parties du code vont modifier la valeur de cette variable.</p>
<!--
For example, let’s change *src/main.rs* to the following:
-->
<p>Par exemple, modifions <em>src/main.rs</em> ainsi :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;La valeur de x est : {}&quot;, x);
    x = 6;
    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
When we run the program now, we get this:
-->
<p>Lorsque nous exécutons le programme, nous obtenons :</p>
<!--
```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```
-->
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
La valeur de x est : 5
La valeur de x est : 6
</code></pre>
<!--
We’re allowed to change the value that `x` binds to from `5` to `6` when `mut`
is used. In some cases, you’ll want to make a variable mutable because it makes
the code more convenient to write than if it had only immutable variables.
-->
<p>En utilisant <code>mut</code>, nous avons permis à la valeur de <code>x</code> de passer de <code>5</code> à <code>6</code>.
Dans certains cas, on voudra rendre une variable mutable car cela
rendra le code plus pratique à écrire que s'il n'utilisait que des variables
immuables.</p>
<!--
There are multiple trade-offs to consider in addition to the prevention of
bugs. For example, in cases where you’re using large data structures, mutating
an instance in place may be faster than copying and returning newly allocated
instances. With smaller data structures, creating new instances and writing in
a more functional programming style may be easier to think through, so lower
performance might be a worthwhile penalty for gaining that clarity.
-->
<p>Il y a d'autres compromis à envisager, en plus de la prévention des bogues. Par
exemple, dans le cas où vous utiliseriez des grosses structures de données,
muter une instance déjà existante peut être plus rapide que copier et retourner
une instance nouvellement allouée. Avec des structures de données plus petites,
créer de nouvelles instances avec un style de programmation fonctionnelle peut
rendre le code plus facile à comprendre, donc il peut valoir le coup de
sacrifier un peu de performance pour que le code gagne en clarté.</p>
<!--
### Differences Between Variables and Constants
-->
<h3><a class="header" href="#différences-entre-les-variables-et-les-constantes" id="différences-entre-les-variables-et-les-constantes">Différences entre les variables et les constantes</a></h3>
<!--
Being unable to change the value of a variable might have reminded you of
another programming concept that most other languages have: *constants*. Like
immutable variables, constants are values that are bound to a name and are not
allowed to change, but there are a few differences between constants and
variables.
-->
<p>Rendre impossible de changer la valeur d'une variable peut vous avoir rappelé un
autre concept de programmation que de nombreux autres langages possèdent : les
<em>constantes</em>. Comme les variables immuables, les constantes sont des valeurs qui
sont liées à un nom et qui ne peuvent être modifiées, mais il y a quelques
différences entre les constantes et les variables.</p>
<!--
First, you aren’t allowed to use `mut` with constants. Constants aren’t just
immutable by default—they’re always immutable.
-->
<p>D'abord, vous ne pouvez pas utiliser <code>mut</code> avec les constantes. Les constantes
ne sont pas seulement immuables par défaut − elles sont toujours immuables.</p>
<!--
You declare constants using the `const` keyword instead of the `let` keyword,
and the type of the value *must* be annotated. We’re about to cover types and
type annotations in the next section, [“Data Types,”][data-types]<!-- ignore
-- > so don’t worry about the details right now. Just know that you must always
annotate the type.
-->
<p>On déclare les constantes en utilisant le mot-clé <code>const</code> à la place du
mot-clé <code>let</code>, et le type de la valeur <em>doit</em> être indiqué. Nous allons aborder
les types et les annotations de types dans la prochaine section,
<a href="ch03-02-data-types.html#les-types-de-donn%C3%A9es">“Les types de données”</a><!-- ignore -->, donc ne vous souciez pas
des détails pour le moment. Sachez seulement que vous devez toujours indiquer le
type.</p>
<!--
Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.
-->
<p>Les constantes peuvent être déclarées à n'importe quel endroit du code, y
compris la portée globale, ce qui les rend très utiles pour des valeurs que de
nombreuses parties de votre code ont besoin de connaître.</p>
<!--
The last difference is that constants may be set only to a constant expression,
not the result of a function call or any other value that could only be
computed at runtime.
-->
<p>La dernière différence est que les constantes ne peuvent être définies que par
une expression constante, et non pas le résultat d'un appel de fonction ou toute
autre valeur qui ne pourrait être calculée qu'à l'exécution.</p>
<!--
Here’s an example of a constant declaration where the constant’s name is
`MAX_POINTS` and its value is set to 100,000. (Rust’s naming convention for
constants is to use all uppercase with underscores between words, and
underscores can be inserted in numeric literals to improve readability):
-->
<p>Voici un exemple d'une déclaration de constante où le nom de la constante est
<code>MAX_POINTS</code> et où sa valeur est définie à 100 000. (En Rust, la convention de
nommage des constantes est de les écrire tout en majuscule avec des tirets bas
entre les mots, et des tirets bas peuvent être ajoutés entre les nombres pour
améliorer la lisibilité) :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<!--
Constants are valid for the entire time a program runs, within the scope they
were declared in, making them a useful choice for values in your application
domain that multiple parts of the program might need to know about, such as the
maximum number of points any player of a game is allowed to earn or the speed
of light.
-->
<p>Les constantes sont valables pendant toute la durée d'exécution du programme
au sein de la portée dans laquelle elles sont déclarées, ce qui en fait de
très bons choix lorsque plusieurs parties du programme doivent connaître
certaines valeurs, comme par exemple le nombre maximum de points qu'un joueur
est autorisé à gagner ou encore la vitesse de la lumière.</p>
<!--
Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.
-->
<p>Déclarer des valeurs codées en dur et utilisées tout le long de votre programme
en tant que constantes est utile pour faire comprendre la signification de ces
valeurs dans votre code aux futurs développeurs. Cela permet également de
n'avoir qu'un seul endroit de votre code à modifier si cette valeur codée en dur
doit être mise à jour à l'avenir.</p>
<!--
### Shadowing
-->
<h3><a class="header" href="#le-masquage" id="le-masquage">Le masquage</a></h3>
<!--
As you saw in the guessing game tutorial in the [“Comparing the Guess to the
Secret Number”][comparing-the-guess-to-the-secret-number]<!-- ignore -- >
section in Chapter 2, you can declare a new variable with the same name as a
previous variable, and the new variable shadows the previous variable.
Rustaceans say that the first variable is *shadowed* by the second, which means
that the second variable’s value is what appears when the variable is used. We
can shadow a variable by using the same variable’s name and repeating the use
of the `let` keyword as follows:
-->
<p>Comme nous l'avons vu dans la section <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au nombre
secret”</a><!-- ignore -->
du jeu de devinettes au chapitre 2, on peut déclarer une nouvelle variable
avec le même nom qu'une variable précédente, et la nouvelle variable
masquera la première. Les Rustacés disent que la première variable est <em>masquée</em>
par la seconde, ce qui signifie que la valeur de la seconde variable sera ce que
nous obtiendrons lorsque nous utiliserons cette variable. Nous pouvons créer un
masque d'une variable en utilisant le même nom de variable et en réutilisant le
mot-clé <code>let</code> comme ci-dessous :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
This program first binds `x` to a value of `5`. Then it shadows `x` by
repeating `let x =`, taking the original value and adding `1` so the value of
`x` is then `6`. The third `let` statement also shadows `x`, multiplying the
previous value by `2` to give `x` a final value of `12`. When we run this
program, it will output the following:
-->
<p>Au début, ce programme lie <code>x</code> à la valeur <code>5</code>. Puis il crée un masque de <code>x</code>
en répétant <code>let x =</code>, en récupérant la valeur d'origine et lui ajoutant <code>1</code> :
la valeur de <code>x</code> est désormais <code>6</code>. La troisième instruction <code>let</code> crée un autre
masque de <code>x</code>, en récupérant la précédente valeur et en la multipliant par <code>2</code>
pour donner à <code>x</code> la valeur finale de <code>12</code>. Lorsque nous exécutons ce programme,
nous obtenons ceci :</p>
<!--
```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```
-->
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
La valeur de x est : 12
</code></pre>
<!--
Shadowing is different from marking a variable as `mut`, because we’ll get a
compile-time error if we accidentally try to reassign to this variable without
using the `let` keyword. By using `let`, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.
-->
<p>Créer un masque est différent que de marquer une variable comme étant <code>mut</code>,
car à moins d'utiliser une nouvelle fois le mot-clé <code>let</code>, nous obtiendrons une
erreur de compilation si nous essayons de réassigner cette variable par
accident. Nous pouvons effectuer quelques transformations sur une valeur en
utilisant <code>let</code>, mais faire en sorte que la variable soit immuable après que ces
transformations ont été appliquées.</p>
<!--
The other difference between `mut` and shadowing is that because we’re
effectively creating a new variable when we use the `let` keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, but we really want to store that input as a number:
-->
<p>Comme nous créons une nouvelle variable lorsque nous utilisons le mot-clé <code>let</code>
une nouvelle fois, l'autre différence entre le <code>mut</code> et la création d'un masque
est que cela nous permet de changer le type de la valeur, mais en réutilisant
le même nom. Par exemple, imaginons un programme qui demande à l'utilisateur
le nombre d'espaces qu'il souhaite entre deux portions de texte en saisissant
des espaces, mais que nous voulons plutôt stocker cela sous forme de nombre :</p>
<!--
```rust
let spaces = "   ";
let spaces = spaces.len();
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let espaces = &quot;   &quot;;
let espaces = espaces.len();
<span class="boring">}
</span></code></pre></pre>
<!--
This construct is allowed because the first `spaces` variable is a string type
and the second `spaces` variable, which is a brand-new variable that happens to
have the same name as the first one, is a number type. Shadowing thus spares us
from having to come up with different names, such as `spaces_str` and
`spaces_num`; instead, we can reuse the simpler `spaces` name. However, if we
try to use `mut` for this, as shown here, we’ll get a compile-time error:
-->
<p>Cette solution est autorisée car la première variable <code>espaces</code> est du type
chaîne de caractères <em>(string)</em>, alors que la seconde variable <code>espaces</code>, qui
est une toute nouvelle variable qui se trouve avoir le même nom que la première,
est du type nombre. L'utilisation du masquage nous évite ainsi d'avoir à trouver
des noms différents, comme <code>espaces_str</code> et <code>espaces_num</code> ; nous pouvons plutôt
simplement réutiliser le nom <code>espaces</code>. Cependant, si nous essayons d'utiliser
<code>mut</code> pour faire ceci, comme ci-dessous, nous avons une erreur de compilation :</p>
<!--
```rust,ignore,does_not_compile
let mut spaces = "   ";
spaces = spaces.len();
```
-->
<pre><code class="language-rust ignore">let mut espaces = &quot;   &quot;;
espaces = espaces.len();
</code></pre>
<!--
The error says we’re not allowed to mutate a variable’s type:
-->
<p>L'erreur indique que nous ne pouvons pas muter le type d'une variable :</p>
<!--
```text
error[E0308]: mismatched types
 -- > src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```
-->
<pre><code class="language-text">error[E0308]: mismatched types
 -- &gt; src/main.rs:3:14
  |
3 |     espaces = espaces.len();
  |               ^^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<!--
Now that we’ve explored how variables work, let’s look at more data types they
can have.
-->
<p>Maintenant que nous avons découvert comment fonctionnent les variables, étudions
les types de données qu'elles peuvent prendre.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
-->
<!--
## Data Types
-->
<h2><a class="header" href="#les-types-de-données" id="les-types-de-données">Les types de données</a></h2>
<!--
Every value in Rust is of a certain *data type*, which tells Rust what kind of
data is being specified so it knows how to work with that data. We’ll look at
two data type subsets: scalar and compound.
-->
<p>Chaque valeur en Rust est d'un <em>type</em> bien déterminé, qui indique à Rust quel
genre de données il manipule pour qu'il sache comment traiter ces données.
Nous allons nous intéresser à deux catégories de types de données : les
scalaires et les composés.</p>
<!--
Keep in mind that Rust is a *statically typed* language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a `String` to a numeric
type using `parse` in the [“Comparing the Guess to the Secret
Number”][comparing-the-guess-to-the-secret-number]<!-- ignore -- > section in
Chapter 2, we must add a type annotation, like this:
-->
<p>Gardez à l'esprit que Rust est langage <em>statiquement typé</em>, ce qui signifie
qu'il doit connaître les types de toutes les variables au moment de la
compilation. Le compilateur peut souvent déduire quel type utiliser en se basant
sur la valeur et sur la façon dont elle est utilisée. Dans les cas où plusieurs
types sont envisageables, comme lorsque nous avons converti une chaîne de
caractères en un type numérique en utilisant <code>parse</code> dans la section
<a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au nombre
secret”</a><!-- ignore -->
du chapitre 2, nous devons ajouter une annotation de type, comme ceci :</p>
<!--
```rust
let guess: u32 = "42".parse().expect("Not a number!");
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let supposition: u32 = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre !&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
If we don’t add the type annotation here, Rust will display the following
error, which means the compiler needs more information from us to know which
type we want to use:
-->
<p>Si nous n'ajoutons pas l'annotation de type ici, Rust affichera l'erreur
suivante, signifiant que le compilateur a besoin de plus d'informations pour
déterminer quel type nous souhaitons utiliser :</p>
<!--
```text
error[E0282]: type annotations needed
 -- > src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```
-->
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let supposition = &quot;42&quot;.parse().expect(&quot;Ce n'est pas un nombre !&quot;);
  |         ^^^^^^^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `supposition` a type
</code></pre>
<!--
You’ll see different type annotations for other data types.
-->
<p>Vous découvrirez différentes annotations de type au fur et à mesure que nous
aborderons les autres types de données.</p>
<!--
### Scalar Types
-->
<h3><a class="header" href="#types-scalaires" id="types-scalaires">Types scalaires</a></h3>
<!--
A *scalar* type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Let’s jump into how they work in Rust.
-->
<p>Un type <em>scalaire</em> représente une seule valeur. Rust possède quatre types
principaux de scalaires : les entiers, les nombres à virgule flottante, les
booléens et les caractères. Vous les connaissez sûrement d'autres langages de
programmation. Regardons comment ils fonctionnent avec Rust.</p>
<!--
#### Integer Types
-->
<h4><a class="header" href="#types-de-nombres-entiers" id="types-de-nombres-entiers">Types de nombres entiers</a></h4>
<!--
An *integer* is a number without a fractional component. We used one integer
type in Chapter 2, the `u32` type. This type declaration indicates that the
value it’s associated with should be an unsigned integer (signed integer types
start with `i`, instead of `u`) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. Each variant in the Signed and Unsigned
columns (for example, `i16`) can be used to declare the type of an integer
value.
-->
<p>Un <em>entier</em> est un nombre sans partie décimale. Nous avons utilisé un entier
précédemment dans le chapitre 2, le type <code>u32</code>. Cette déclaration de type
indique que la valeur à laquelle elle est associée doit être un entier non signé
encodé sur 32 bits dans la mémoire (les entiers pouvant prendre des valeurs
négatives commencent par un <code>i</code> (comme <em>integer</em> : “entier”), plutôt que par un
<code>u</code> comme <em>unsigned</em> : “non signé”). Le tableau 3-1 montre les types
d'entiers intégrés au langage. Chaque variante dans les colonnes “Signé” et
“Non signé” (par exemple <code>i16</code>) peut être utilisée pour déclarer le type d'une
valeur entière.</p>
<!--
<span class="caption">Table 3-1: Integer Types in Rust</span>
-->
<p><span class="caption">Tableau 3-1 : les types d'entiers en Rust</span></p>
<!--
| Length  | Signed  | Unsigned |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |
-->
<table><thead><tr><th>Taille</th><th>Signé</th><th>Non signé</th></tr></thead><tbody>
<tr><td>8 bits</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 bits</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 bits</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 bits</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 bits</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>archi</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<!-- markdownlint-disable -->
<!--
Each variant can be either signed or unsigned and has an explicit size.
*Signed* and *unsigned* refer to whether it’s possible for the number to be
negative or positive—in other words, whether the number needs to have a sign
with it (signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). It’s like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when it’s safe to assume the number is positive, it’s shown with no sign.
Signed numbers are stored using [two’s complement](https://en.wikipedia.org/wiki/Two%27s_complement) representation.
-->
<!-- markdownlint-restore -->
<p>Chaque variante peut-être signée ou non signée et possède une taille explicite.
<em>Signé</em> et <em>non signé</em> veut dire respectivement que le nombre peut prendre ou
non des valeurs négatives ou positives — en d'autres termes, si l'on peut lui
attribuer un signe (signé) ou s'il sera toujours positif et que l'on peut donc
le représenter sans signe (non signé). C'est comme écrire des nombres sur du
papier : quand le signe est important, le nombre est écrit avec un signe plus
ou un signe moins ; en revanche, quand le nombre est forcément positif, on peut
l'écrire sans son signe. Les nombres signés sont stockés en utilisant le
<a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">complément à deux</a>.</p>
<!--
Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n -
1</sup> - 1 inclusive, where *n* is the number of bits that variant uses. So an
`i8` can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals
-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1,
so a `u8` can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255.
-->
<p>Chaque variante signée peut stocker des nombres allant de −(2<sup><em>n</em> − 1</sup>)
à 2<sup><em>n</em> − 1</sup> − 1 inclus, où <em>n</em> est le nombre de bits que cette
variante utilise.
Un <code>i8</code> peut donc stocker des nombres allant de −(2<sup>7</sup>) à
2<sup>7</sup> − 1, c'est-à-dire de −128 à 127. Les variantes non signées peuvent
stocker des nombres de 0 à 2<sup><em>n</em></sup> − 1, donc un <code>u8</code> peut stocker
des nombres allant de 0 à 2<sup>8</sup> − 1, c'est-à-dire de 0 à 255.</p>
<!--
Additionally, the `isize` and `usize` types depend on the kind of computer your
program is running on: 64 bits if you’re on a 64-bit architecture and 32 bits
if you’re on a 32-bit architecture.
-->
<p>De plus, les types <code>isize</code> et <code>usize</code> dépendent du type d'ordinateur sur lequel
votre programme va s'exécuter : 64 bits si vous utilisez une architecture
64 bits ou 32 bits si vous utilisez une architecture 32 bits.</p>
<!--
You can write integer literals in any of the forms shown in Table 3-2. Note
that all number literals except the byte literal allow a type suffix, such as
`57u8`, and `_` as a visual separator, such as `1_000`.
-->
<p>Vous pouvez écrire des littéraux d'entiers dans chacune des formes décrites dans
le tableau 3-2. Notez que chaque littéral numérique excepté l'octet accepte un
suffixe de type, comme <code>57u8</code>, et <code>_</code> comme séparateur visuel, comme par exemple
<code>1_000</code>.</p>
<!--
<span class="caption">Table 3-2: Integer Literals in Rust</span>
-->
<p><span class="caption">Tableau 3-2 : Les littéraux d'entiers en Rust</span></p>
<!--
| Number literals  | Example       |
|------------------|---------------|
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |
-->
<table><thead><tr><th>Littéral numérique</th><th>Exemple</th></tr></thead><tbody>
<tr><td>Décimal</td><td><code>98_222</code></td></tr>
<tr><td>Hexadécimal</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binaire</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Octet (<code>u8</code> seulement)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<!--
So how do you know which type of integer to use? If you’re unsure, Rust’s
defaults are generally good choices, and integer types default to `i32`: this
type is generally the fastest, even on 64-bit systems. The primary situation in
which you’d use `isize` or `usize` is when indexing some sort of collection.
-->
<p>Comment pouvez-vous déterminer le type d'entier à utiliser ? Si vous n'êtes pas
sûr, les choix par défaut de Rust sont généralement de bons choix, et le type
d'entier par défaut est le <code>i32</code> : c'est souvent le plus rapide, même sur les
systèmes 64 bits. La principale utilisation d'un <code>isize</code> ou d'un <code>usize</code> est
lorsque l'on indexe une quelconque collection.</p>
<!--
> ##### Integer Overflow
>
> Let’s say you have a variable of type `u8` that can hold values between 0 and 255.
> If you try to change the variable to a value outside of that range, such
> as 256, *integer overflow* will occur. Rust has some interesting rules
> involving this behavior. When you’re compiling in debug mode, Rust includes
> checks for integer overflow that cause your program to *panic* at runtime if
> this behavior occurs. Rust uses the term panicking when a program exits with
> an error; we’ll discuss panics in more depth in the [“Unrecoverable Errors
> with `panic!`”][unrecoverable-errors-with-panic]<!-- ignore -- > section in
> Chapter 9.
>
> When you’re compiling in release mode with the `--release` flag, Rust does
> *not* include checks for integer overflow that cause panics. Instead, if
> overflow occurs, Rust performs *two’s complement wrapping*. In short, values
> greater than the maximum value the type can hold “wrap around” to the minimum
> of the values the type can hold. In the case of a `u8`, 256 becomes 0, 257
> becomes 1, and so on. The program won’t panic, but the variable will have a
> value that probably isn’t what you were expecting it to have. Relying on
> integer overflow’s wrapping behavior is considered an error. If you want to
> wrap explicitly, you can use the standard library type [`Wrapping`][wrapping].
-->
<blockquote>
<h5><a class="header" href="#dépassement-dentier" id="dépassement-dentier">Dépassement d'entier</a></h5>
<p>Imaginons que vous avez une variable de type <code>u8</code> qui peut stocker des
valeurs entre 0 et 255. Si vous essayez de changer la variable pour une valeur
en dehors de cet intervalle, comme 256, vous aurez un dépassement
d'entier <em>(integer overflow)</em>. Rust possède quelques règles intéressantes
concernant ce comportement. Quand vous compilez en mode débogage, Rust
embarque des vérifications pour détecter les cas de dépassements d'entiers qui
pourraient faire <em>paniquer</em> votre programme à l'exécution si ce phénomène se
produit. Rust utilise le terme <em>paniquer</em> quand un programme se termine
avec une erreur ; nous verrons plus en détail les <em>paniques</em> dans une section
du <a href="ch09-01-unrecoverable-errors-with-panic.html">chapitre 9</a>.</p>
<p>Lorsque vous compilez en mode publication <em>(release)</em> avec le drapeau
<code>--release</code>, Rust ne va <em>pas</em> vérifier les potentiels dépassements d'entiers
qui peuvent faire paniquer le programme. En revanche, en cas de dépassement,
Rust va effectuer un <em>rebouclage du complément à deux</em>. Pour faire simple, les
valeurs supérieures à la valeur maximale du type seront “rebouclées” depuis la
valeur minimale que le type peut stocker. Dans cas d'un <code>u8</code>, 256 devient 0,
257 devient 1, et ainsi de suite. Le programme ne va paniquer, mais
la variable va avoir une valeur qui n'est probablement pas ce que vous
attendez à avoir. Se fier au comportement du rebouclage lors du
dépassement d'entier est considéré comme une faute. Si vous voulez reboucler
explicitement, vous pouvez utiliser le type <a href="https://doc.rust-lang.org/std/num/struct.Wrapping.html"><code>Wrapping</code></a> de la
bibliothèque standard.</p>
</blockquote>
<!--
#### Floating-Point Types
-->
<h4><a class="header" href="#types-de-nombres-à-virgule-flottante" id="types-de-nombres-à-virgule-flottante">Types de nombres à virgule flottante</a></h4>
<!--
Rust also has two primitive types for *floating-point numbers*, which are
numbers with decimal points. Rust’s floating-point types are `f32` and `f64`,
which are 32 bits and 64 bits in size, respectively. The default type is `f64`
because on modern CPUs it’s roughly the same speed as `f32` but is capable of
more precision.
-->
<p>Rust possède également deux types primitifs pour les <em>nombres à virgule
flottante</em> (ou <em>flottants</em>), qui sont des nombres avec des décimales. Les types
de flottants en Rust sont les <code>f32</code> et les <code>f64</code>, qui ont respectivement une
taille en mémoire de 32 bits et 64 bits. Le type par défaut est le <code>f64</code> car sur
les processeurs récents ce type est quasiment aussi rapide qu'un <code>f32</code> mais est
plus précis.</p>
<!--
Here’s an example that shows floating-point numbers in action:
-->
<p>Voici un exemple montrant l'utilisation de nombres à virgule flottante :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Nom du ficher: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<!--
Floating-point numbers are represented according to the IEEE-754 standard. The
`f32` type is a single-precision float, and `f64` has double precision.
-->
<p>Les nombres à virgule flottante sont représentés selon la norme IEEE-754. Le
type <code>f32</code> est un flottant à simple précision, et le <code>f64</code> est à double
précision.</p>
<!--
#### Numeric Operations
-->
<h4><a class="header" href="#les-opérations-numériques" id="les-opérations-numériques">Les opérations numériques</a></h4>
<!--
Rust supports the basic mathematical operations you’d expect for all of the
number types: addition, subtraction, multiplication, division, and remainder.
The following code shows how you’d use each one in a `let` statement:
-->
<p>Rust offre les opérations mathématiques de base dont vous auriez besoin pour
tous les types de nombres : addition, soustraction, multiplication, division et
modulo. Le code suivant montre comment utiliser chacune d'elles avec une
instruction <code>let</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // addition
    let somme = 5 + 10;

    // soustraction
    let difference = 95.5 - 4.3;

    // multiplication
    let produit = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // modulo
    let reste = 43 % 5;
}
</code></pre></pre>
<!--
Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. Appendix B contains a
list of all operators that Rust provides.
-->
<p>Chaque expression de ces instructions utilise un opérateur mathématique et
calcule une valeur unique, qui est ensuite attribuée à une variable. L'annexe B
présente une liste de tous les opérateurs que Rust fournit.</p>
<!--
#### The Boolean Type
-->
<h4><a class="header" href="#le-type-booléen" id="le-type-booléen">Le type booléen</a></h4>
<!--
As in most other programming languages, a Boolean type in Rust has two possible
values: `true` and `false`. Booleans are one byte in size. The Boolean type in
Rust is specified using `bool`. For example:
-->
<p>Comme dans la plupart des langages de programmation, un type booléen a deux
valeurs possibles en Rust : <code>true</code> (vrai) et <code>false</code> (faux). Les booléens
prennent un octet en mémoire. Le type booléen est désigné en utilisant <code>bool</code>.
Par exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // avec une annotation de type explicite
}
</code></pre></pre>
<!--
The main way to use Boolean values is through conditionals, such as an `if`
expression. We’ll cover how `if` expressions work in Rust in the [“Control
Flow”][control-flow]<!-- ignore -- > section.
-->
<p>Les valeurs booléennes sont principalement utilisées par les structures
conditionnelles, comme l'expression <code>if</code>. Nous aborderons le fonctionnement
de <code>if</code> en Rust dans la section
<a href="ch03-05-control-flow.html#les-structures-de-contr%C3%B4le">“Les structures de contrôle”</a><!-- ignore -->.</p>
<!--
#### The Character Type
-->
<h4><a class="header" href="#le-type-caractère" id="le-type-caractère">Le type caractère</a></h4>
<!--
So far we’ve worked only with numbers, but Rust supports letters too. Rust’s
`char` type is the language’s most primitive alphabetic type, and the following
code shows one way to use it. (Note that `char` literals are specified with
single quotes, as opposed to string literals, which use double quotes.)
-->
<p>Jusqu'à présent, nous avons utilisé uniquement des nombres, mais Rust peut aussi
travailler avec des lettres. Le type <code>char</code> (comme <em>character</em>) est le type de
caractère le plus rudimentaire, et le code suivant va vous montrer une façon de
l'utiliser. (A noter que les <code>char</code> sont écrits avec des guillemets simples,
contrairement aux chaînes, qui utilisent des guillemets doubles.)</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let chat_aux_yeux_de_coeur = '😻';
}
</code></pre></pre>
<!--
Rust’s `char` type is four bytes in size and represents a Unicode Scalar Value,
which means it can represent a lot more than just ASCII. Accented letters;
Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all
valid `char` values in Rust. Unicode Scalar Values range from `U+0000` to
`U+D7FF` and `U+E000` to `U+10FFFF` inclusive. However, a “character” isn’t
really a concept in Unicode, so your human intuition for what a “character” is
may not match up with what a `char` is in Rust. We’ll discuss this topic in
detail in [“Storing UTF-8 Encoded Text with Strings”][strings]<!-- ignore -- >
in Chapter 8.
-->
<p>Le type <code>char</code> de Rust prend quatre octets en mémoire et représente une valeur
scalaire Unicode, ce qui veut dire que cela représente plus de caractères que
l'ASCII. Les lettres accentuées ; les caractères chinois, japonais et coréens ;
les emoji ; les espaces de largeur nulle ont tous une valeur pour <code>char</code> avec
Rust. Les valeurs scalaires Unicode vont de <code>U+0000</code> à <code>U+D7FF</code> et de <code>U+E000</code> à
<code>U+10FFFF</code> inclus. Cependant, le concept de “caractère” n'est pas clairement
défini par Unicode, donc votre notion de “caractère” peut ne pas correspondre
à ce qu'est un <code>char</code> en Rust. Nous aborderons ce sujet plus en détail au
<a href="ch08-02-strings.html">chapitre 8</a>.</p>
<!--
### Compound Types
-->
<h3><a class="header" href="#les-types-composés" id="les-types-composés">Les types composés</a></h3>
<!--
*Compound types* can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.
-->
<p>Les <em>types composés</em> peuvent regrouper plusieurs valeurs dans un seul type. Rust
a deux types composés de base : les <em>tuples</em> et les tableaux <em>(arrays)</em>.</p>
<!--
#### The Tuple Type
-->
<h4><a class="header" href="#le-type-tuple" id="le-type-tuple">Le type <em>tuple</em></a></h4>
<!--
A tuple is a general way of grouping together a number of values with a variety
of types into one compound type. Tuples have a fixed length: once declared,
they cannot grow or shrink in size.
-->
<p>Un <em>tuple</em> est une manière générale de regrouper plusieurs valeurs
de types différents en un seul type composé. Les tuples ont une taille fixée :
à partir du moment où ils ont été déclarés, on ne peut pas y ajouter ou enlever
des valeurs.</p>
<!--
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:
-->
<p>Nous créons un <em>tuple</em> en écrivant une liste séparée par des virgules entre des
parenthèses. Chaque emplacement dans le tuple a un type, et les types de chacune
des valeurs dans le tuple n'ont pas forcément besoin d'être les mêmes.
Nous avons ajouté des annotations de type dans cet exemple, mais c'est
optionnel :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<!--
The variable `tup` binds to the entire tuple, because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:
-->
<p>La variable <code>tup</code> est liée à tout le tuple, car un tuple est considéré
comme étant un unique élément composé. Pour obtenir un élément précis de ce
tuple, nous pouvons utiliser un filtrage par motif <em>(pattern matching)</em> pour
déstructurer ce tuple, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;La valeur de y est : {}&quot;, y);
}
</code></pre></pre>
<!--
This program first creates a tuple and binds it to the variable `tup`. It then
uses a pattern with `let` to take `tup` and turn it into three separate
variables, `x`, `y`, and `z`. This is called *destructuring*, because it breaks
the single tuple into three parts. Finally, the program prints the value of
`y`, which is `6.4`.
-->
<p>Le programme commence par créer un tuple et il l'assigne à la variable <code>tup</code>.
Il utilise ensuite un motif avec <code>let</code> pour prendre <code>tup</code> et le scinder en
trois variables distinctes : <code>x</code>, <code>y</code>, et <code>z</code>.
On appelle cela <em>déstructurer</em>, car il divise le tuple en trois parties.
Puis finalement, le programme affiche la valeur de <code>y</code>, qui est <code>6.4</code>.</p>
<!--
In addition to destructuring through pattern matching, we can access a tuple
element directly by using a period (`.`) followed by the index of the value we
want to access. For example:
-->
<p>En plus de pouvoir déstructurer avec un filtrage par motif, nous pouvons accéder
directement à chaque élément du tuple en utilisant un point (<code>.</code>) suivi de
l'indice de la valeur que nous souhaitons obtenir. Par exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let cinq_cents = x.0;

    let six_virgule_quatre = x.1;

    let un = x.2;
}
</code></pre></pre>
<!--
This program creates a tuple, `x`, and then makes new variables for each
element by using their respective indices. As with most programming languages,
the first index in a tuple is 0.
-->
<p>Ce programme crée un tuple, <code>x</code>, puis crée une nouvelle variable pour
chaque élément en utilisant leur indices respectifs. Comme dans de nombreux
langages de programmation, le premier indice d'un tuple est 0.</p>
<!--
#### The Array Type
-->
<h4><a class="header" href="#le-type-tableau" id="le-type-tableau">Le type tableau</a></h4>
<!--
Another way to have a collection of multiple values is with an *array*. Unlike
a tuple, every element of an array must have the same type. Arrays in Rust are
different from arrays in some other languages because arrays in Rust have a
fixed length, like tuples.
-->
<p>Un autre moyen d'avoir une collection de plusieurs valeurs est d'utiliser
un <em>tableau</em>. Contrairement aux tuples, chaque élément d'un tableau doit être du
même type. Les tableaux de Rust diffèrent de ceux de certains autres langages
car les tableaux de Rust ont une taille fixe, comme les tuples.</p>
<!--
In Rust, the values going into an array are written as a comma-separated list
inside square brackets:
-->
<p>Avec Rust, les valeurs stockées dans un tableau sont écrites dans une
liste séparée par des virgules entre des crochets :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<!--
Arrays are useful when you want your data allocated on the stack rather than
the heap (we will discuss the stack and the heap more in Chapter 4) or when
you want to ensure you always have a fixed number of elements. An array isn’t
as flexible as the vector type, though. A vector is a similar collection type
provided by the standard library that *is* allowed to grow or shrink in size.
If you’re unsure whether to use an array or a vector, you should probably use a
vector. Chapter 8 discusses vectors in more detail.
-->
<p>Les tableaux sont utiles quand vous voulez que vos données soient allouées sur
la pile <em>(stack)</em> plutôt que sur le tas <em>(heap)</em> (nous expliquerons la pile et
le tas au chapitre 4) ou lorsque vous voulez vous assurer que vous avez toujours
un nombre fixe d'éléments. Cependant, un tableau n'est pas aussi flexible qu'un
vecteur <em>(vector)</em>. Un vecteur est un type de collection de données
similaire qui est fourni par la bibliothèque standard qui, lui, peut
grandir ou rétrécir en taille. Si vous ne savez pas si vous devez utiliser un
tableau ou un vecteur, vous devriez probablement utiliser un vecteur. Le
chapitre 8 expliquera les vecteurs.</p>
<!--
An example of when you might want to use an array rather than a vector is in a
program that needs to know the names of the months of the year. It’s very
unlikely that such a program will need to add or remove months, so you can use
an array because you know it will always contain 12 elements:
-->
<p>Un exemple de cas où vous pourriez avoir recours à un tableau plutôt qu'à un
vecteur est un programme qui nécessite de connaître les noms des mois de
l'année.
Il est très improbable qu'un tel programme ait besoin d'ajouter ou de supprimer
des mois, donc vous pouvez utiliser un tableau car vous savez qu'il contiendra
toujours 12 éléments :</p>
<!--
```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mois = [&quot;Janvier&quot;, &quot;Février&quot;, &quot;Mars&quot;, &quot;Avril&quot;, &quot;Mai&quot;, &quot;Juin&quot;, &quot;Juillet&quot;,
            &quot;Août&quot;, &quot;Septembre&quot;, &quot;Octobre&quot;, &quot;Novembre&quot;, &quot;Décembre&quot;];
<span class="boring">}
</span></code></pre></pre>
<!--
You would write an array’s type by using square brackets, and within the
brackets include the type of each element, a semicolon, and then the number of
elements in the array, like so:
-->
<p>Vous pouvez écrire le type d'un tableau en utilisant des crochets, et entre ces
crochets y ajouter le type de chaque élément, un point-virgule, et ensuite le
nombre d'éléments dans le tableau, comme ceci :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `i32` is the type of each element. After the semicolon, the number `5`
indicates the array contains five elements.
-->
<p>Ici, <code>i32</code> est le type de chaque élément. Après le point-virgule, le nombre <code>5</code>
indique que le tableau contient cinq éléments.</p>
<!--
Writing an array’s type this way looks similar to an alternative syntax for
initializing an array: if you want to create an array that contains the same
value for each element, you can specify the initial value, followed by a
semicolon, and then the length of the array in square brackets, as shown here:
-->
<p>L'écriture d'un type de tableau de cette manière ressemble à une autre syntaxe
pour initialiser un tableau : si vous voulez créer un tableau qui contient la
même valeur pour chaque élément, vous pouvez préciser la valeur initiale, suivie
par un point-virgule, et ensuite la taille du tableau, le tout entre crochets,
comme ci-dessous :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<!--
The array named `a` will contain `5` elements that will all be set to the value
`3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a
more concise way.
-->
<p>Le tableau <code>a</code> va contenir <code>5</code> éléments qui auront tous la valeur
initiale <code>3</code>. C'est la même chose que d'écrire <code>let a = [3, 3, 3, 3, 3];</code> mais
de manière plus concise.</p>
<!--
##### Accessing Array Elements
-->
<h5><a class="header" href="#accéder-aux-éléments-dun-tableau" id="accéder-aux-éléments-dun-tableau">Accéder aux éléments d'un tableau</a></h5>
<!--
An array is a single chunk of memory allocated on the stack. You can access
elements of an array using indexing, like this:
-->
<p>Un tableau est un simple bloc de mémoire alloué sur la pile. Vous pouvez accéder
aux éléments d'un tableau en utilisant l'indexation, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let premier = a[0];
    let second = a[1];
}
</code></pre></pre>
<!--
In this example, the variable named `first` will get the value `1`, because
that is the value at index `[0]` in the array. The variable named `second` will
get the value `2` from index `[1]` in the array.
-->
<p>Dans cet exemple, la variable qui s'appelle <code>premier</code> aura la valeur <code>1</code>, car
c'est la valeur à l'indice <code>[0]</code> dans le tableau. La variable <code>second</code>
récupèrera la valeur <code>2</code> depuis l'indice <code>[1]</code> du tableau.</p>
<!--
##### Invalid Array Element Access
-->
<h5><a class="header" href="#accès-incorrect-à-un-élément-dun-tableau" id="accès-incorrect-à-un-élément-dun-tableau">Accès incorrect à un élément d'un tableau</a></h5>
<!--
What happens if you try to access an element of an array that is past the end
of the array? Say you change the example to the following code, which will
compile but exit with an error when it runs:
-->
<p>Que se passe-t-il quand vous essayez d'accéder à un élément d'un tableau qui se
trouve après la fin du tableau ? Imaginons que vous changiez l'exemple par le
code suivant, qui va compiler mais qui va quitter avec une erreur quand il sera
exécuté :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,panics
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```
-->
<pre><code class="language-rust ignore panics">fn main() {
    let a = [1, 2, 3, 4, 5];
    let indice = 10;

    let element = a[indice];

    println!(&quot;La valeur de l'élément est : {}&quot;, element);
}
</code></pre>
<!--
Running this code using `cargo run` produces the following result:
-->
<p>Exécuter ce code en utilisant <code>cargo run</code> va donner le résultat suivant :</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:5:19
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!--
The compilation didn’t produce any errors, but the program resulted in a
*runtime* error and didn’t exit successfully. When you attempt to access an
element using indexing, Rust will check that the index you’ve specified is less
than the array length. If the index is greater than or equal to the array
length, Rust will panic.
-->
<p>La compilation n'a pas produit d'erreur, mais le programme a rencontré une
erreur <em>à l'exécution</em> et ne s'est pas terminé avec succès. Quand vous essayez
d'accéder à un élément en utilisant l'indexation, Rust va vérifier que l'indice
que vous avez demandé est plus petit que la taille du tableau. Si l'indice est
supérieur ou égal à la taille du tableau, Rust va <em>paniquer</em>.</p>
<!--
This is the first example of Rust’s safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rust’s error handling.
-->
<p>C'est un premier exemple pratique des principes de sécurité de Rust. Dans de
nombreux langages de bas niveau, ce genre de vérification n'est pas effectuée,
et quand vous utilisez un indice incorrect, de la mémoire invalide peut être
récupérée. Rust vous protège de ce genre d'erreur en quittant immédiatement
l'exécution au lieu de permettre l'accès en mémoire et
continuer son déroulement. Le chapitre 9 expliquera la gestion d'erreurs de
Rust.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[control-flow]: ch03-05-control-flow.html#control-flow
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[wrapping]: ../std/num/struct.Wrapping.html
-->
<!--
## Functions
-->
<h2><a class="header" href="#les-fonctions" id="les-fonctions">Les fonctions</a></h2>
<!--
Functions are pervasive in Rust code. You’ve already seen one of the most
important functions in the language: the `main` function, which is the entry
point of many programs. You’ve also seen the `fn` keyword, which allows you to
declare new functions.
-->
<p>Les fonctions sont omniprésentes dans le code Rust. Vous avez déjà vu l'une des
fonctions les plus importantes du langage : la fonction <code>main</code>, qui est le point
d'entrée de beaucoup de programmes. Vous avez aussi vu le mot-clé <code>fn</code>, qui vous
permet de déclarer des nouvelles fonctions.</p>
<!--
Rust code uses *snake case* as the conventional style for function and variable
names. In snake case, all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:
-->
<p>Le code Rust utilise le <em>snake case</em> comme convention de style de nom des
fonctions et des variables. Avec le <em>snake case</em>, toutes les lettres sont en
minuscule et on utilise des tirets bas pour séparer les mots. Voici un programme
qui est un exemple de définition de fonction :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    une_autre_fonction();
}

fn une_autre_fonction() {
    println!(&quot;Une autre fonction.&quot;);
}
</code></pre></pre>
<!--
Function definitions in Rust start with `fn` and have a set of parentheses
after the function name. The curly brackets tell the compiler where the
function body begins and ends.
-->
<p>La définition d'une fonction avec Rust commence par <code>fn</code> et a une paire de
parenthèses après le nom de la fonction. Les accolades indiquent au compilateur
où le corps de la fonction commence et où il se termine.</p>
<!--
We can call any function we’ve defined by entering its name followed by a set
of parentheses. Because `another_function` is defined in the program, it can be
called from inside the `main` function. Note that we defined `another_function`
*after* the `main` function in the source code; we could have defined it before
as well. Rust doesn’t care where you define your functions, only that they’re
defined somewhere.
-->
<p>Nous pouvons appeler n'importe quelle fonction que nous avons définie en
utilisant son nom, suivi d'une paire de parenthèses. Comme <code>une_autre_fonction</code>
est définie dans le programme, elle peut être appelée à l'intérieur de la
fonction <code>main</code>. Remarquez que nous avons défini <code>une_autre_fonction</code> <em>après</em>
la fonction <code>main</code> dans le code source ; nous aurions aussi pu la définir avant.
Rust ne se soucie pas de l'endroit où vous définissez vos fonctions, du moment
qu'elles sont bien définies quelque part.</p>
<!--
Let’s start a new binary project named *functions* to explore functions
further. Place the `another_function` example in *src/main.rs* and run it. You
should see the following output:
-->
<p>Créons un nouveau projet de binaire qui s'appellera <em>functions</em> afin d'en
apprendre plus sur les fonctions. Ajoutez l'exemple <code>une_autre_fonction</code> dans le
<em>src/main.rs</em> et exécutez-le. Vous devriez avoir ceci :</p>
<!--
```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
```
-->
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Une autre fonction.
</code></pre>
<!--
The lines execute in the order in which they appear in the `main` function.
First, the “Hello, world!” message prints, and then `another_function` is
called and its message is printed.
-->
<p>Les lignes s'exécutent dans l'ordre dans lequel elles apparaissent dans la
fonction <code>main</code>. D'abord, le message <code>Hello, world!</code> est écrit, et ensuite
<code>une_autre_fonction</code> est appelée et son message est affiché.</p>
<!--
### Function Parameters
-->
<h3><a class="header" href="#les-paramètres-de-fonctions" id="les-paramètres-de-fonctions">Les paramètres de fonctions</a></h3>
<!--
Functions can also be defined to have *parameters*, which are special variables
that are part of a function’s signature. When a function has parameters, you
can provide it with concrete values for those parameters. Technically, the
concrete values are called *arguments*, but in casual conversation, people tend
to use the words *parameter* and *argument* interchangeably for either the
variables in a function’s definition or the concrete values passed in when you
call a function.
-->
<p>Les fonctions peuvent aussi être définies avec des <em>paramètres</em>, qui sont des
variables spéciales qui font partie de la signature de la fonction. Quand une
fonction a des paramètres, vous pouvez lui fournir des valeurs concrètes avec
ces paramètres. Techniquement, ces valeurs concrètes sont appelées des
<em>arguments</em>, mais dans une conversation courante, on a tendance à
confondre les termes <em>paramètres</em> et <em>arguments</em> pour désigner soit les
variables dans la définition d'une fonction, soit les valeurs concrètes passées
quand on appelle une fonction.</p>
<!--
The following rewritten version of `another_function` shows what parameters
look like in Rust:
-->
<p>La version réécrite de <code>une_autre_fonction</code> montre comment utiliser un paramètre
avec Rust :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    une_autre_fonction(5);
}

fn une_autre_fonction(x: i32) {
    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
Try running this program; you should get the following output:
-->
<p>En exécutant ce programme, vous devriez obtenir ceci :</p>
<!--
```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
```
-->
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
La valeur de x est : 5
</code></pre>
<!--
The declaration of `another_function` has one parameter named `x`. The type of
`x` is specified as `i32`. When `5` is passed to `another_function`, the
`println!` macro puts `5` where the pair of curly brackets were in the format
string.
-->
<p>La déclaration de <code>une_autre_fonction</code> a un paramètre nommé <code>x</code>. Le type de
<code>x</code> a été déclaré comme <code>i32</code>. Quand <code>5</code> est passé à <code>une_autre_fonction</code>, la
macro <code>println!</code> place <code>5</code> là où la paire d'accolades <code>{}</code> a été placée dans la
chaîne de formatage.</p>
<!--
In function signatures, you *must* declare the type of each parameter. This is
a deliberate decision in Rust’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what you mean.
-->
<p>Dans la signature d'une fonction, vous <em>devez</em> déclarer le type de chaque
paramètre. C'est un choix délibéré de conception de Rust : exiger l'annotation
de type dans la définition d'une fonction fait en sorte que le compilateur n'a
presque plus besoin que vous les utilisiez autre part pour qu'il comprenne ce
que vous voulez faire.</p>
<!--
When you want a function to have multiple parameters, separate the parameter
declarations with commas, like this:
-->
<p>Lorsque vous souhaitez qu'une fonction ait plusieurs paramètres, séparez les
paramètres avec des virgules, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    une_autre_fonction(5, 6);
}

fn une_autre_fonction(x: i32, y: i32) {
    println!(&quot;La valeur de x est : {}&quot;, x);
    println!(&quot;La valeur de y est : {}&quot;, y);
}
</code></pre></pre>
<!--
This example creates a function with two parameters, both of which are `i32`
types. The function then prints the values in both of its parameters. Note that
function parameters don’t all need to be the same type, they just happen to be
in this example.
-->
<p>Cet exemple crée une fonction avec deux paramètres, chacun d'eux sont du type
<code>i32</code>. La fonction affiche ensuite les valeurs de ses deux paramètres.
Notez que les paramètres des fonctions n'ont pas besoin d'être du même type,
nous sommes dans cette situation uniquement pour les besoins de notre exemple.</p>
<!--
Let’s try running this code. Replace the program currently in your *functions*
project’s *src/main.rs* file with the preceding example and run it using `cargo
run`:
-->
<p>Essayons d'exécuter ce code. Remplacez le programme présent actuellement dans
votre fichier <em>src/main.rs</em> de votre projet <em>functions</em> par l'exemple précédent
et lancez-le en utilisant <code>cargo run</code> :</p>
<!--
```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
```
-->
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
La valeur de x est : 5
La valeur de y est : 6
</code></pre>
<!--
Because we called the function with `5` as the value for  `x` and `6` is passed
as the value for `y`, the two strings are printed with these values.
-->
<p>Comme nous avons appelé la fonction avec la valeur <code>5</code> pour <code>x</code> et <code>6</code> pour
<code>y</code>, deux lignes sont affichées avec ces valeurs.</p>
<!--
### Function Bodies Contain Statements and Expressions
-->
<h3><a class="header" href="#corps-de-fonction-avec-des-instructions-et-des-expressions" id="corps-de-fonction-avec-des-instructions-et-des-expressions">Corps de fonction avec des instructions et des expressions</a></h3>
<!--
Function bodies are made up of a series of statements optionally ending in an
expression. So far, we’ve only covered functions without an ending expression,
but you have seen an expression as part of a statement. Because Rust is an
expression-based language, this is an important distinction to understand.
Other languages don’t have the same distinctions, so let’s look at what
statements and expressions are and how their differences affect the bodies of
functions.
-->
<p>Les corps de fonctions sont constitués d'une série d'instructions qui se
termine éventuellement par une expression. Jusqu'à présent, nous avons vu des
fonctions sans expression à la fin, mais vous avez déjà vu une expression faire
partie d'une instruction. Comme Rust est un langage basé sur des expressions,
il est important de faire la distinction. D'autres langages ne font pas de
telles distinctions, donc penchons-nous sur ce que sont les instructions et les
expressions et comment leurs différences influent sur le corps des fonctions.</p>
<!--
We’ve actually already used statements and expressions. *Statements* are
instructions that perform some action and do not return a value. *Expressions*
evaluate to a resulting value. Let’s look at some examples.
-->
<p>Nous avons déjà utilisé des instructions et des expressions. Les <em>instructions</em>
effectuent des actions et ne retournent aucune valeur.
Les <em>expressions</em> sont évaluées pour retourner une valeur comme résultat.
Voyons quelques exemples.</p>
<!--
Creating a variable and assigning a value to it with the `let` keyword is a
statement. In Listing 3-1, `let y = 6;` is a statement.
-->
<p>Créer une variable en lui assignant une valeur avec le mot-clé <code>let</code> constitue
une instruction. Dans l'encart 3-1, <code>let y = 6;</code> est une instruction.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<!-- markdownlint-disable -->
<!--
<span class="caption">Listing 3-1: A `main` function declaration containing one statement</span>
-->
<!-- markdownlint-restore -->
<p><span class="caption">Encart 3-1 : une fonction <code>main</code> qui contient une
instruction</span></p>
<!--
Function definitions are also statements; the entire preceding example is a
statement in itself.
-->
<p>La définition d'une fonction est aussi une instruction ; l'intégralité de
l'exemple précédent est une instruction à elle toute seule.</p>
<!--
Statements do not return values. Therefore, you can’t assign a `let` statement
to another variable, as the following code tries to do; you’ll get an error:
-->
<p>Une instruction ne retourne pas de valeur. Ainsi, vous ne pouvez pas assigner
le résultat d'une instruction <code>let</code> à une autre variable, comme le code suivant
essaye de le faire, car vous obtiendrez une erreur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<!--
When you run this program, the error you’ll get looks like this:
-->
<p>Quand vous exécutez ce programme, l'erreur que vous obtenez devrait ressembler à
ceci :</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 -- &gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<!--
The `let y = 6` statement does not return a value, so there isn’t anything for
`x` to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write `x = y = 6` and have both `x` and `y` have the value
`6`; that is not the case in Rust.
-->
<p>L'instruction <code>let y = 6</code> ne retourne pas de valeur, donc cela ne peut pas
devenir une valeur de <code>x</code>. Ceci est différent d'autres langages, comme le C ou
Ruby, où l'assignation retourne la valeur de l'assignation. Dans ces
langages, vous pouvez écrire <code>x = y = 6</code> et avoir ainsi <code>x</code> et <code>y</code> qui ont
chacun la valeur <code>6</code> ; cela n'est pas possible avec Rust.</p>
<!--
Expressions evaluate to something and make up most of the rest of the code that
you’ll write in Rust. Consider a simple math operation, such as `5 + 6`, which
is an expression that evaluates to the value `11`. Expressions can be part of
statements: in Listing 3-1, the `6` in the statement `let y = 6;` is an
expression that evaluates to the value `6`. Calling a function is an
expression. Calling a macro is an expression. The block that we use to create
new scopes, `{}`, is an expression, for example:
-->
<p>Les expressions sont évaluées et seront ce que vous écrirez le plus en Rust
(hormis les instructions). Prenez une simple opération mathématique, comme
<code>5 + 6</code>, qui est une expression qui s'évalue à la valeur <code>11</code>. Les expressions
peuvent faire partie d'une instruction : dans l'encart 3-1, le <code>6</code> dans
l'instruction <code>let y = 6;</code> est une expression qui s'évalue à la valeur <code>6</code>.
L'appel de fonction est aussi une expression. L'appel de macro est une
expression. Le bloc que nous utilisons pour créer une nouvelle portée, <code>{}</code>,
est une expression, par exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;La valeur de y est : {}&quot;, y);
}
</code></pre></pre>
<!--
This expression:
-->
<p>L'expression suivante…</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<!--
is a block that, in this case, evaluates to `4`. That value gets bound to `y`
as part of the `let` statement. Note the `x + 1` line without a semicolon at
the end, which is unlike most of the lines you’ve seen so far. Expressions do
not include ending semicolons. If you add a semicolon to the end of an
expression, you turn it into a statement, which will then not return a value.
Keep this in mind as you explore function return values and expressions next.
-->
<p>… est un bloc qui, dans ce cas, s'évalue à <code>4</code>. Cette valeur est assignée à <code>y</code>
dans le cadre de l'instruction <code>let</code>. Remarquez la ligne <code>x + 1</code> qui ne se
termine pas par un point-virgule, ce qui est différent de la plupart
des lignes que vous avez vues jusque là. Les expressions n'ont pas de
point-virgule de fin de ligne. Si vous ajoutez un point-virgule à la fin de
l'expression, vous la transformez en instruction, qui ne va donc pas retourner
de valeur. Gardez ceci à l'esprit quand nous aborderons prochainement les
valeurs de retour des fonctions ainsi que les expressions.</p>
<!--
### Functions with Return Values
-->
<h3><a class="header" href="#les-fonctions-qui-retournent-des-valeurs" id="les-fonctions-qui-retournent-des-valeurs">Les fonctions qui retournent des valeurs</a></h3>
<!--
Functions can return values to the code that calls them. We don’t name return
values, but we do declare their type after an arrow (`->`). In Rust, the return
value of the function is synonymous with the value of the final expression in
the block of the body of a function. You can return early from a function by
using the `return` keyword and specifying a value, but most functions return
the last expression implicitly. Here’s an example of a function that returns a
value:
-->
<p>Les fonctions peuvent retourner des valeurs au code qui les appelle.
Nous ne nommons pas les valeurs de retour, mais nous devons déclarer
leur type après une flèche (<code>-&gt;</code>). En Rust, la valeur de retour de la fonction
est la même que la valeur de l'expression finale dans le corps de la fonction.
Vous pouvez sortir prématurément d'une fonction en utilisant le mot-clé <code>return</code>
et en précisant la valeur de retour, mais la plupart des fonctions vont
retourner implicitement la dernière expression.
Voici un exemple d'une fonction qui retourne une valeur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn cinq() -&gt; i32 {
    5
}

fn main() {
    let x = cinq();

    println!(&quot;La valeur de x est : {}&quot;, x);
}
</code></pre></pre>
<!--
There are no function calls, macros, or even `let` statements in the `five`
function—just the number `5` by itself. That’s a perfectly valid function in
Rust. Note that the function’s return type is specified too, as `-> i32`. Try
running this code; the output should look like this:
-->
<p>Il n'y a pas d'appel de fonction, de macro, ni même d'instruction <code>let</code> dans la
fonction <code>cinq</code> — uniquement le nombre <code>5</code> tout seul. C'est une fonction
parfaitement valide avec Rust. Remarquez que le type de retour de la fonction a
été précisé aussi, avec <code>-&gt; i32</code>. Essayez d'exécuter ce code ; le résultat
devrait ressembler à ceci :</p>
<!--
```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
The value of x is: 5
```
-->
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
La valeur de x est : 5
</code></pre>
<!--
The `5` in `five` is the function’s return value, which is why the return type
is `i32`. Let’s examine this in more detail. There are two important bits:
first, the line `let x = five();` shows that we’re using the return value of a
function to initialize a variable. Because the function `five` returns a `5`,
that line is the same as the following:
-->
<p>Le <code>5</code> dans <code>cinq</code> est la valeur de retour de la fonction, ce qui explique le
type de retour de <code>i32</code>. Regardons cela plus en détail. Il y a deux éléments
importants : premièrement, la ligne <code>let x = cinq();</code> dit que nous utilisons
la valeur de retour de la fonction pour initialiser la variable. Comme la
fonction <code>cinq</code> retourne un <code>5</code>, cette ligne revient à faire ceci :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Second, the `five` function has no parameters and defines the type of the
return value, but the body of the function is a lonely `5` with no semicolon
because it’s an expression whose value we want to return.
-->
<p>Deuxièmement, la fonction <code>cinq</code> n'a pas de paramètre et déclare le type de
valeur de retour, mais le corps de la fonction est un simple <code>5</code> sans
point-virgule car c'est une expression dont nous voulons retourner la valeur.</p>
<!--
Let’s look at another example:
-->
<p>Regardons un autre exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = plus_un(5);

    println!(&quot;La valeur de x est : {}&quot;, x);
}

fn plus_un(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<!--
Running this code will print `The value of x is: 6`. But if we place a
semicolon at the end of the line containing `x + 1`, changing it from an
expression to a statement, we’ll get an error.
-->
<p>Exécuter ce code va afficher <code>La valeur de x est : 6</code>. Mais si nous ajoutons un
point-virgule à la fin de la ligne qui contient <code>x + 1</code>, ce qui la transforme
d'une expression à une instruction, nous obtenons une erreur.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_un(5);

    println!(&quot;La valeur de x est : {}&quot;, x);
}

fn plus_un(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<!--
Compiling this code produces an error, as follows:
-->
<p>Compiler ce code va produire une erreur, comme ci-dessous :</p>
<!--
```text
error[E0308]: mismatched types
 -- > src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -> i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
```
-->
<pre><code class="language-text">error[E0308]: mismatched types
 -- &gt; src/main.rs:7:28
  |
7 |   fn plus_un(x: i32) -&gt; i32 {
  |  ___________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
</code></pre>
<!--
The main error message, “mismatched types,” reveals the core issue with this
code. The definition of the function `plus_one` says that it will return an
`i32`, but statements don’t evaluate to a value, which is expressed by `()`,
an empty tuple. Therefore, nothing is returned, which contradicts the function
definition and results in an error. In this output, Rust provides a message to
possibly help rectify this issue: it suggests removing the semicolon, which
would fix the error.
-->
<p>Le message d'erreur principal, “mismatched types” <em>(types inadéquats)</em> donne le
cœur du problème de ce code. La définition de la fonction <code>plus_un</code> dit qu'elle
va retourner un <code>i32</code>, mais les instructions ne retournent pas de valeur, ceci
est donc représenté par <code>()</code>, un <em>tuple</em> vide. Par conséquent, rien n'est
retourné, ce qui contredit la définition de la fonction et provoque une erreur.
Rust affiche un message qui peut aider à corriger ce problème : il suggère
d'enlever le point-virgule, ce qui va résoudre notre problème.</p>
<!--
## Comments
-->
<h2><a class="header" href="#les-commentaires" id="les-commentaires">Les commentaires</a></h2>
<!--
All programmers strive to make their code easy to understand, but sometimes
extra explanation is warranted. In these cases, programmers leave notes, or
*comments*, in their source code that the compiler will ignore but people
reading the source code may find useful.
-->
<p>Tous les développeurs s'efforcent de rendre leur code facile à comprendre, mais
parfois il est nécessaire d'écrire des explications supplémentaires.
Dans ce cas, les développeurs laissent des notes, appelées <em>commentaires</em>, dans
leur code source que le compilateur va ignorer mais qui peuvent être utiles
pour les personnes qui lisent le code source.</p>
<!--
Here’s a simple comment:
-->
<p>Voici un simple commentaire :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<!--
In Rust, comments must start with two slashes and continue until the end of the
line. For comments that extend beyond a single line, you’ll need to include
`//` on each line, like this:
-->
<p>Avec Rust, les commentaires commencent avec deux barres obliques et continuent
jusqu'à la fin de la ligne. Pour les commentaires qui font plus d'une seule
ligne, vous aurez besoin d'ajouter <code>//</code> sur chaque ligne, comme ceci :</p>
<!--
```rust
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Donc ici on fait quelque chose de compliqué, tellement long que nous avons
// besoin de plusieurs lignes de commentaires pour le faire ! Heureusement,
// ce commentaire va expliquer ce qui se passe.
<span class="boring">}
</span></code></pre></pre>
<!--
Comments can also be placed at the end of lines containing code:
-->
<p>Les commentaires peuvent aussi être aussi ajoutés à la fin d'une ligne qui
contient du code :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let nombre_chanceux = 7; // Je me sens chanceux aujourd'hui
}
</code></pre></pre>
<!--
But you’ll more often see them used in this format, with the comment on a
separate line above the code it’s annotating:
-->
<p>Mais parfois, vous pourrez les voir utilisés de cette manière, avec le
commentaire sur une ligne séparée au-dessus du code qu'il annote :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Je me sens chanceux aujourd'hui
    let nombre_chanceux = 7;
}
</code></pre></pre>
<!--
Rust also has another kind of comment, documentation comments, which we’ll
discuss in the “Publishing a Crate to Crates.io” section of Chapter 14.
-->
<p>Rust a aussi un autre type de commentaire, les commentaires de documentation,
que nous aborderons au chapitre 14.</p>
<!--
## Control Flow
-->
<h2><a class="header" href="#les-structures-de-contrôle" id="les-structures-de-contrôle">Les structures de contrôle</a></h2>
<!--
Deciding whether or not to run some code depending on if a condition is true
and deciding to run some code repeatedly while a condition is true are basic
building blocks in most programming languages. The most common constructs that
let you control the flow of execution of Rust code are `if` expressions and
loops.
-->
<p>Choisir d'exécuter ou non du code selon qu'une condition est vérifiée et
choisir d'exécuter du code de façon répétée tant qu'une condition est vérifiée
sont des constructions élémentaires dans la plupart des langages de
programmation. Les structures de contrôle les plus courantes en Rust sont les
expressions <code>if</code> et les boucles.</p>
<!--
### `if` Expressions
-->
<h3><a class="header" href="#les-expressions-if" id="les-expressions-if">Les expressions <code>if</code></a></h3>
<!--
An `if` expression allows you to branch your code depending on conditions. You
provide a condition and then state, “If this condition is met, run this block
of code. If the condition is not met, do not run this block of code.”
-->
<p>Une expression <code>if</code> vous permet de diviser votre code en fonction de conditions.
Vous précisez une condition et vous choisissez ensuite : “Si cette condition est
remplie, alors exécuter ce bloc de code. Si la condition n'est pas remplie,
ne pas exécuter ce bloc de code.”</p>
<!--
Create a new project called *branches* in your *projects* directory to explore
the `if` expression. In the *src/main.rs* file, input the following:
-->
<p>Créez un nouveau projet appelé <em>branches</em> dans votre dossier <em>projects</em> pour
découvrir les expressions <code>if</code>. Dans le fichier <em>src/main.rs</em>, écrivez ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre &lt; 5 {
        println!(&quot;La condition est vérifiée&quot;);
    } else {
        println!(&quot;La condition n'est pas vérifiée&quot;);
    }
}
</code></pre></pre>
<!--
All `if` expressions start with the keyword `if`, which is followed by a
condition. In this case, the condition checks whether or not the variable
`number` has a value less than 5. The block of code we want to execute if the
condition is true is placed immediately after the condition inside curly
brackets. Blocks of code associated with the conditions in `if` expressions are
sometimes called *arms*, just like the arms in `match` expressions that we
discussed in the [“Comparing the Guess to the Secret
Number”][comparing-the-guess-to-the-secret-number]<!-- ignore -- > section of
Chapter 2.
-->
<p>Une expression <code>if</code> commence par le mot-clé <code>if</code>, suivi d'une condition.
Dans notre cas, la condition vérifie si oui ou non la variable <code>nombre</code> a une
valeur inférieure à 5. Le bloc de code que nous voulons exécuter si la condition
est vérifiée est placé immédiatement après la condition entre des accolades.
Les blocs de code associés à une condition dans une expression <code>if</code> sont parfois
appelés des <em>branches</em>, exactement comme les branches dans les expressions
<code>match</code> que nous avons vu dans la section <a href="ch02-00-guessing-game-tutorial.html#comparer-le-nombre-saisi-au-nombre-secret">“Comparer le nombre saisi au
nombre secret”</a><!-- ignore --> du
chapitre 2.</p>
<!--
Optionally, we can also include an `else` expression, which we chose
to do here, to give the program an alternative block of code to execute should
the condition evaluate to false. If you don’t provide an `else` expression and
the condition is false, the program will just skip the `if` block and move on
to the next bit of code.
-->
<p>Éventuellement, vous pouvez aussi ajouter une expression <code>else</code>, ce que nous
avons fait ici, pour préciser un bloc alternatif de code qui sera exécuté dans
le cas où la condition est fausse (elle n'est pas vérifiée). Si
vous ne renseignez pas d'expression <code>else</code> et que la condition n'est pas
vérifiée, le programme va simplement sauter le bloc de <code>if</code> et passer au
prochain morceau de code.</p>
<!--
Try running this code; you should see the following output:
-->
<p>Essayez d'exécuter ce code ; vous verrez ceci :</p>
<!--
```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was true
```
-->
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
La condition est vérifiée
</code></pre>
<!--
Let’s try changing the value of `number` to a value that makes the condition
`false` to see what happens:
-->
<p>Essayons de changer la valeur de <code>nombre</code> pour une valeur qui rend la condition
non vérifiée pour voir ce qui se passe :</p>
<!--
```rust,ignore
let number = 7;
```
-->
<pre><code class="language-rust ignore">let nombre = 7;
</code></pre>
<!--
Run the program again, and look at the output:
-->
<p>Exécutez à nouveau le programme, et regardez le résultat :</p>
<!--
```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was false
```
-->
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
La condition n'est pas vérifiée
</code></pre>
<!--
It’s also worth noting that the condition in this code *must* be a `bool`. If
the condition isn’t a `bool`, we’ll get an error. For example, try running the
following code:
-->
<p>Il est aussi intéressant de noter que la condition dans ce code <em>doit</em> être un
<code>bool</code>. Si la condition n'est pas un <code>bool</code>, nous aurons une erreur. Par
exemple, essayez d'exécuter le code suivant :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let nombre = 3;

    if nombre {
        println!(&quot;Le nombre était trois&quot;);
    }
}
</code></pre>
<!--
The `if` condition evaluates to a value of `3` this time, and Rust throws an
error:
-->
<p>La condition <code>if</code> vaut <code>3</code> cette fois, et Rust lève une erreur :</p>
<!--
```text
error[E0308]: mismatched types
 -- > src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integer
  |
  = note: expected type `bool`
             found type `{integer}`
```
-->
<pre><code class="language-text">error[E0308]: mismatched types
 -- &gt; src/main.rs:4:8
  |
4 |     if nombre {
  |        ^^^^^^ expected bool, found integer
  |
  = note: expected type `bool`
             found type `{integer}`
</code></pre>
<!--
The error indicates that Rust expected a `bool` but got an integer. Unlike
languages such as Ruby and JavaScript, Rust will not automatically try to
convert non-Boolean types to a Boolean. You must be explicit and always provide
`if` with a Boolean as its condition. If we want the `if` code block to run
only when a number is not equal to `0`, for example, we can change the `if`
expression to the following:
-->
<p>Cette erreur explique que Rust attendait un <code>bool</code> mais a obtenu un entier
<em>(integer)</em>. Contrairement à des langages comme Ruby et JavaScript, Rust
ne va pas essayer de convertir automatiquement les types non booléens en
booléens. Vous devez être précis et toujours fournir un booléen à la condition
d'un <code>if</code>. Si nous voulons que le bloc de code du <code>if</code> soit exécuté quand le
nombre est différent de <code>0</code>, par exemple, nous pouvons changer l'expression <code>if</code>
par la suivante :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let nombre = 3;

    if nombre != 0 {
        println!(&quot;Le nombre valait autre chose que zéro&quot;);
    }
}
</code></pre></pre>
<!--
Running this code will print `number was something other than zero`.
-->
<p>Exécuter ce code va bien afficher <code>Le nombre valait autre chose que zéro</code>.</p>
<!--
#### Handling Multiple Conditions with `else if`
-->
<h4><a class="header" href="#gérer-plusieurs-conditions-avec-else-if" id="gérer-plusieurs-conditions-avec-else-if">Gérer plusieurs conditions avec <code>else if</code></a></h4>
<!--
You can have multiple conditions by combining `if` and `else` in an `else if`
expression. For example:
-->
<p>Vous pouvez utiliser plusieurs conditions en combinant <code>if</code> et <code>else</code> dans une
expression <code>else if</code>. Par exemple :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let nombre = 6;

    if nombre % 4 == 0 {
        println!(&quot;Le nombre est divisible par 4&quot;);
    } else if nombre % 3 == 0 {
        println!(&quot;Le nombre est divisible par 3&quot;);
    } else if nombre % 2 == 0 {
        println!(&quot;Le nombre est divisible par 2&quot;);
    } else {
        println!(&quot;Le nombre n'est pas divisible par 4, 3 ou 2&quot;);
    }
}
</code></pre></pre>
<!--
This program has four possible paths it can take. After running it, you should
see the following output:
-->
<p>Ce programme peut choisir entre quatre chemins différents. Après l'avoir
exécuté, vous devriez voir le résultat suivant :</p>
<!--
```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
number is divisible by 3
```
-->
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
Le nombre est divisible par 3
</code></pre>
<!--
When this program executes, it checks each `if` expression in turn and executes
the first body for which the condition holds true. Note that even though 6 is
divisible by 2, we don’t see the output `number is divisible by 2`, nor do we
see the `number is not divisible by 4, 3, or 2` text from the `else` block.
That’s because Rust only executes the block for the first true condition, and
once it finds one, it doesn’t even check the rest.
-->
<p>Quand ce programme s'exécute, il vérifie chaque expression <code>if</code> à tour de rôle
et exécute le premier bloc dont la condition est vérifiée. Notez que même si 6
est divisible par 2, nous ne voyons pas le message <code>Le nombre est divisible par 2</code>, ni le message <code>Le nombre n'est pas divisible par 4, 3 ou 2</code> du bloc <code>else</code>.
C'est parce que Rust n'exécute que le bloc de la première condition vérifiée,
et dès lors qu'il en a trouvé une, il ne va pas chercher à vérifier les
suivantes.</p>
<!--
Using too many `else if` expressions can clutter your code, so if you have more
than one, you might want to refactor your code. Chapter 6 describes a powerful
Rust branching construct called `match` for these cases.
-->
<p>Utiliser trop d'expressions <code>else if</code> peut encombrer votre code, donc si vous
en avez plus d'une, vous devriez envisager de remanier votre code. Le chapitre 6
présente une construction puissante appelée <code>match</code> pour de tels cas.</p>
<!--
#### Using `if` in a `let` Statement
-->
<h4><a class="header" href="#utiliser-if-dans-une-instruction-let" id="utiliser-if-dans-une-instruction-let">Utiliser <code>if</code> dans une instruction <code>let</code></a></h4>
<!--
Because `if` is an expression, we can use it on the right side of a `let`
statement, as in Listing 3-2.
-->
<p>Comme <code>if</code> est une expression, nous pouvons l'utiliser à droite d'une
instruction <code>let</code>, comme dans l'encart 3-2.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condition = true;
    let nombre = if condition {
        5
    } else {
        6
    };

    println!(&quot;La valeur du nombre est : {}&quot;, nombre);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-2: Assigning the result of an `if` expression
to a variable</span>
-->
<p><span class="caption">Encart 3-2 : assigner le résultat d'une expression <code>if</code> à
une variable</span></p>
<!--
The `number` variable will be bound to a value based on the outcome of the `if`
expression. Run this code to see what happens:
-->
<p>La variable <code>nombre</code> va avoir la valeur du résultat de l'expression <code>if</code>.
Exécutez ce code pour découvrir ce qui va se passer :</p>
<!--
```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
The value of number is: 5
```
-->
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
La valeur du nombre est : 5
</code></pre>
<!--
Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the
whole `if` expression depends on which block of code executes. This means the
values that have the potential to be results from each arm of the `if` must be
the same type; in Listing 3-2, the results of both the `if` arm and the `else`
arm were `i32` integers. If the types are mismatched, as in the following
example, we’ll get an error:
-->
<p>Souvenez-vous que les blocs de code s'exécutent jusqu'à la dernière expression
qu'ils contiennent, et que les nombres tout seuls sont aussi des expressions.
Dans notre cas, la valeur de toute l'expression <code>if</code> dépend de quel bloc de code
elle va exécuter. Cela veut dire que chaque valeur qui peut être le résultat de
chaque branche du <code>if</code> doivent être du même type ; dans l'encart 3-2, les
résultats des branches <code>if</code> et <code>else</code> sont tous deux des entiers <code>i32</code>. Si
les types ne sont pas identiques, comme dans l'exemple suivant, nous allons
obtenir une erreur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        "six"
    };

    println!("The value of number is: {}", number);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let nombre = if condition {
        5
    } else {
        &quot;six&quot;
    };

    println!(&quot;La valeur du nombre est : {}&quot;, nombre);
}
</code></pre>
<!--
When we try to compile this code, we’ll get an error. The `if` and `else` arms
have value types that are incompatible, and Rust indicates exactly where to
find the problem in the program:
-->
<p>Lorsque nous essayons de compiler ce code, nous obtenons une erreur. Les
branches <code>if</code> et <code>else</code> ont des types de valeurs qui ne sont pas compatibles, et
Rust indique exactement où trouver le problème dans le programme :</p>
<!--
```text
error[E0308]: if and else have incompatible types
 -- > src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         "six"
8 | |     };
  | |_____^ expected integer, found &str
  |
  = note: expected type `{integer}`
             found type `&str`
```
-->
<pre><code class="language-text">error[E0308]: if and else have incompatible types
 -- &gt; src/main.rs:4:18
  |
4 |       let nombre = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;six&quot;
8 | |     };
  | |_____^ expected integer, found &amp;str
  |
  = note: expected type `{integer}`
             found type `&amp;str`
</code></pre>
<!--
The expression in the `if` block evaluates to an integer, and the expression in
the `else` block evaluates to a string. This won’t work because variables must
have a single type. Rust needs to know at compile time what type the `number`
variable is, definitively, so it can verify at compile time that its type is
valid everywhere we use `number`. Rust wouldn’t be able to do that if the type
of `number` was only determined at runtime; the compiler would be more complex
and would make fewer guarantees about the code if it had to keep track of
multiple hypothetical types for any variable.
-->
<p>L'expression dans le bloc <code>if</code> donne un entier, et l'expression dans le bloc
<code>else</code> donne une chaîne de caractères. Ceci ne fonctionne pas car les variables
doivent avoir un seul type. Rust a besoin de savoir de quel type est la variable
<code>nombre</code> au moment de la compilation, assurément, afin de vérifier au moment
de la compilation que son type est valable n'importe où nous utilisons <code>nombre</code>.
Rust ne serait pas capable de faire cela si le type de <code>nombre</code> était déterminé
uniquement à l'exécution ; car le compilateur deviendrait plus complexe et nous
donnerait moins de garanties sur le code s'il devait prendre en compte tous les
types hypothétiques pour une variable.</p>
<!--
### Repetition with Loops
-->
<h3><a class="header" href="#les-répétitions-avec-les-boucles" id="les-répétitions-avec-les-boucles">Les répétitions avec les boucles</a></h3>
<!--
It’s often useful to execute a block of code more than once. For this task,
Rust provides several *loops*. A loop runs through the code inside the loop
body to the end and then starts immediately back at the beginning. To
experiment with loops, let’s make a new project called *loops*.
-->
<p>Il est parfois utile d'exécuter un bloc de code plus d'une seule fois. Dans ce
but, Rust propose plusieurs types de <em>boucles</em>. Une boucle parcourt le code à
l'intérieur du corps de la boucle jusqu'à la fin et recommence immédiatement du
début. Pour tester les boucles, créons un nouveau projet appelé <em>loops</em>.</p>
<!--
Rust has three kinds of loops: `loop`, `while`, and `for`. Let’s try each one.
-->
<p>Rust a trois types de boucles : <code>loop</code>, <code>while</code>, et <code>for</code>. Essayons chacune
d'elles.</p>
<!--
#### Repeating Code with `loop`
-->
<h4><a class="header" href="#répéter-du-code-avec-loop" id="répéter-du-code-avec-loop">Répéter du code avec <code>loop</code></a></h4>
<!--
The `loop` keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop.
-->
<p>Le mot-clé <code>loop</code> demande à Rust d'exécuter un bloc de code encore et encore
jusqu'à l'infini ou jusqu'à ce que vous lui demandiez explicitement de
s'arrêter.</p>
<!--
As an example, change the *src/main.rs* file in your *loops* directory to look
like this:
-->
<p>Par exemple, changez le fichier <em>src/main.rs</em> dans votre dossier <em>loops</em> comme
ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    loop {
        println!("again!");
    }
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;À nouveau !&quot;);
    }
}
</code></pre>
<!--
When we run this program, we’ll see `again!` printed over and over continuously
until we stop the program manually. Most terminals support a keyboard shortcut,
<span class="keystroke">ctrl-c</span>, to interrupt a program that is stuck in
a continual loop. Give it a try:
-->
<p>Quand nous exécutons ce programme, nous voyons <code>À nouveau !</code> s'afficher encore
et encore en continu jusqu'à ce qu'on arrête le programme manuellement. La
plupart des terminaux utilisent un raccourci clavier, <span class="keystroke">
ctrl-c</span>, pour arrêter un programme qui est bloqué dans une boucle infinie.
Essayons cela :</p>
<!--
```text
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```
-->
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
À nouveau !
À nouveau !
À nouveau !
À nouveau !
^CÀ nouveau !
</code></pre>
<!--
The symbol `^C` represents where you pressed <span class="keystroke">ctrl-c
</span>. You may or may not see the word `again!` printed after the `^C`,
depending on where the code was in the loop when it received the interrupt
signal.
-->
<p>Le symbole <code>^C</code> représente le moment où vous avez appuyé sur
<span class="keystroke">ctrl-c</span>. Vous devriez voir ou non le texte
<code>À nouveau !</code> après le <code>^C</code>, en fonction de là où la boucle en était dans votre
code quand elle a reçu le signal d'arrêt.</p>
<!--
Fortunately, Rust provides another, more reliable way to break out of a loop.
You can place the `break` keyword within the loop to tell the program when to
stop executing the loop. Recall that we did this in the guessing game in the
[“Quitting After a Correct Guess”][quitting-after-a-correct-guess]<!-- ignore
-- > section of Chapter 2 to exit the program when the user won the game by
guessing the correct number.
-->
<p>Heureusement, Rust fournit un autre moyen, plus fiable, de sortir d'une boucle.
Vous pouvez ajouter le mot-clé <code>break</code> à l'intérieur de la boucle pour demander
au programme d'arrêter la boucle. Souvenez-vous que nous avions fait ceci dans
le jeu de devinettes, dans la section <a href="ch02-00-guessing-game-tutorial.html#arr%C3%AAter-le-programme-apr%C3%A8s-avoir-gagn%C3%A9">“Arrêter le programme après avoir
gagné”</a><!-- ignore --> du chapitre 2 afin de
quitter le programme quand l'utilisateur gagne le jeu en devinant le bon nombre.</p>
<!--
#### Returning Values from Loops
-->
<h4><a class="header" href="#retourner-des-valeurs-dune-boucle" id="retourner-des-valeurs-dune-boucle">Retourner des valeurs d'une boucle</a></h4>
<!--
One of the uses of a `loop` is to retry an operation you know might fail, such
as checking whether a thread has completed its job. However, you might need to
pass the result of that operation to the rest of your code. To do this, you can
add the value you want returned after the `break` expression you use to stop
the loop; that value will be returned out of the loop so you can use it, as
shown here:
-->
<p>L'une des utilisations d'une boucle <code>loop</code> est de réessayer une opération qui
peut échouer, comme vérifier si une tâche a terminé son travail. Cependant, vous
aurez peut-être besoin de passer le résultat de l'opération au reste de votre
code. Pour ce faire, vous pouvez ajouter la valeur que vous voulez retourner
après l'expression <code>break</code> que vous utilisez pour stopper la boucle ; cette
valeur sera retournée de la boucle pour que vous puissiez l'utiliser, comme
ci-dessous :</p>
<!--
```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut compteur = 0;

    let resultat = loop {
        compteur += 1;

        if compteur == 10 {
            break compteur * 2;
        }
    };

    println!(&quot;Le résultat est {}&quot;, resultat);
}
</code></pre></pre>
<!--
Before the loop, we declare a variable named `counter` and initialize it to
`0`. Then we declare a variable named `result` to hold the value returned from
the loop. On every iteration of the loop, we add `1` to the `counter` variable,
and then check whether the counter is equal to `10`. When it is, we use the
`break` keyword with the value `counter * 2`. After the loop, we use a
semicolon to end the statement that assigns the value to `result`. Finally, we
print the value in `result`, which in this case is 20.
-->
<p>Avant la boucle, nous déclarons une variable avec le nom <code>compteur</code> et nous
l'initialisons à <code>0</code>. Ensuite, nous déclarons une variable <code>resultat</code> pour
stocker la valeur retournée de la boucle. À chaque itération de la boucle, nous
ajoutons <code>1</code> à la variable <code>compteur</code>, et ensuite nous vérifions si le compteur
est égal à <code>10</code>. Lorsque c'est le cas, nous utilisons le mot-clé <code>break</code> avec la
valeur <code>compteur * 2</code>. Après la boucle, nous utilisons un point-virgule pour
terminer l'instruction qui assigne la valeur à <code>resultat</code>. Enfin, nous
affichons la valeur de <code>resultat</code>, qui est 20 dans ce cas-ci.</p>
<!--
#### Conditional Loops with `while`
-->
<h4><a class="header" href="#les-boucles-conditionnelles-avec-while" id="les-boucles-conditionnelles-avec-while">Les boucles conditionnelles avec <code>while</code></a></h4>
<!--
It’s often useful for a program to evaluate a condition within a loop. While
the condition is true, the loop runs. When the condition ceases to be true, the
program calls `break`, stopping the loop. This loop type could be implemented
using a combination of `loop`, `if`, `else`, and `break`; you could try that
now in a program, if you’d like.
-->
<p>Il est souvent utile pour un programme d'évaluer une condition dans une boucle.
Tant que la condition est vraie, la boucle tourne. Quand la condition arrête
d'être vraie, le programme appelle <code>break</code>, ce qui arrête la boucle. Ce type de
boucle peut être implémenté en combinant <code>loop</code>, <code>if</code>, <code>else</code> et <code>break</code> ; vous
pouvez essayer de le faire, si vous voulez.</p>
<!--
However, this pattern is so common that Rust has a built-in language construct
for it, called a `while` loop. Listing 3-3 uses `while`: the program loops
three times, counting down each time, and then, after the loop, it prints
another message and exits.
-->
<p>Cependant, cette utilisation est si fréquente que Rust a une construction pour
cela, intégrée dans le langage, qui s'appelle une boucle <code>while</code>. L'encart 3-3
utilise <code>while</code> : le programme va boucler trois fois, en décrémentant à chaque
fois, et ensuite, après la boucle, il va afficher un message et se fermer.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut nombre = 3;

    while nombre != 0 {
        println!(&quot;{} !&quot;, nombre);

        nombre -= 1;
    }

    println!(&quot;DÉCOLLAGE !!!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-3: Using a `while` loop to run code while a
condition holds true</span>
-->
<p><span class="caption">Encart 3-3: utiliser une boucle <code>while</code> pour exécuter du
code tant qu'une condition est vraie</span></p>
<!--
This construct eliminates a lot of nesting that would be necessary if you used
`loop`, `if`, `else`, and `break`, and it’s clearer. While a condition holds
true, the code runs; otherwise, it exits the loop.
-->
<p>Cette construction élimine beaucoup d'imbrications qui seraient nécessaires si
vous utilisiez <code>loop</code>, <code>if</code>, <code>else</code> et <code>break</code>, et c'est aussi plus clair. Tant
que la condition est vraie, le code est exécuté ; sinon, il quitte la boucle.</p>
<!--
#### Looping Through a Collection with `for`
-->
<h4><a class="header" href="#boucler-dans-une-collection-avec-for" id="boucler-dans-une-collection-avec-for">Boucler dans une collection avec <code>for</code></a></h4>
<!--
You could use the `while` construct to loop over the elements of a collection,
such as an array. For example, let’s look at Listing 3-4.
-->
<p>Vous pouvez utiliser la construction <code>while</code> pour itérer sur les
éléments d'une collection, comme les tableaux. Par exemple, analysons l'encart
3-4.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut indice = 0;

    while indice &lt; 5 {
        println!(&quot;La valeur est : {}&quot;, a[indice]);

        indice += 1;
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-4: Looping through each element of a collection
using a `while` loop</span>
-->
<p><span class="caption">Encart 3-4 : itération sur les éléments d'une collection
en utilisant une boucle <code>while</code></span></p>
<!--
Here, the code counts up through the elements in the array. It starts at index
`0`, and then loops until it reaches the final index in the array (that is,
when `index < 5` is no longer true). Running this code will print every element
in the array:
-->
<p>Ici, le code parcourt le tableau élément par élément.
Il commence à l'indice <code>0</code>, et ensuite boucle jusqu'à ce qu'il atteigne l'indice
final du tableau (ce qui correspond au moment où la condition <code>index &lt; 5</code> n'est
plus vraie). Exécuter ce code va afficher chaque élément du tableau :</p>
<!--
```text
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```
-->
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
La valeur est : 10
La valeur est : 20
La valeur est : 30
La valeur est : 40
La valeur est : 50
</code></pre>
<!--
All five array values appear in the terminal, as expected. Even though `index`
will reach a value of `5` at some point, the loop stops executing before trying
to fetch a sixth value from the array.
-->
<p>Les cinq valeurs du tableau s'affichent toutes dans le terminal, comme attendu.
Même si <code>indice</code> va atteindre la valeur <code>5</code> à un moment, la boucle arrêtera de
s'exécuter avant d'essayer de récupérer une sixième valeur du tableau.</p>
<!--
But this approach is error prone; we could cause the program to panic if the
index length is incorrect. It’s also slow, because the compiler adds runtime
code to perform the conditional check on every element on every iteration
through the loop.
-->
<p>Mais cette approche pousse à l'erreur ; nous pourrions faire paniquer le
programme si l'indice est trop grand. De plus, c'est lent, car le compilateur
ajoute du code à l'exécution pour effectuer des vérifications sur chaque élément
à chaque itération de la boucle.</p>
<!--
As a more concise alternative, you can use a `for` loop and execute some code
for each item in a collection. A `for` loop looks like the code in Listing 3-5.
-->
<p>Pour une alternative plus concise, vous pouvez utiliser une boucle <code>for</code> et
exécuter du code pour chaque élément dans une collection. Une boucle <code>for</code>
s'utilise comme dans le code de l'encart 3-5.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;La valeur est : {}&quot;, element);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-5: Looping through each element of a collection
using a `for` loop</span>
-->
<p><span class="caption">Encart 3-5 : itérer sur chaque élément d'une collection
en utilisant une boucle <code>for</code></span></p>
<!--
When we run this code, we’ll see the same output as in Listing 3-4. More
importantly, we’ve now increased the safety of the code and eliminated the
chance of bugs that might result from going beyond the end of the array or not
going far enough and missing some items.
-->
<p>Lorsque nous exécutons ce code, nous obtenons les mêmes messages que dans
l'encart 3-4. Mais ce qui est plus important, c'est que nous avons amélioré la
sécurité de notre code et éliminé le risque de bogues qui pourraient survenir
si on dépassait la fin du tableau, ou si on n'allait pas jusqu'au bout
et qu'on ratait quelques éléments.</p>
<!--
For example, in the code in Listing 3-4, if you removed an item from the `a`
array but forgot to update the condition to `while index < 4`, the code would
panic. Using the `for` loop, you wouldn’t need to remember to change any other
code if you changed the number of values in the array.
-->
<p>Par exemple, dans le code de l'encart 3-4, si vous enlevez un élément du
tableau <code>a</code> mais que vous oubliez de mettre à jour la condition tel que
<code>while indice &lt; 4</code>, le code va paniquer. En utilisant la boucle <code>for</code>, vous
n'aurez pas à vous rappeler de changer le code si vous changez le nombre de
valeurs dans le tableau.</p>
<!--
The safety and conciseness of `for` loops make them the most commonly used loop
construct in Rust. Even in situations in which you want to run some code a
certain number of times, as in the countdown example that used a `while` loop
in Listing 3-3, most Rustaceans would use a `for` loop. The way to do that
would be to use a `Range`, which is a type provided by the standard library
that generates all numbers in sequence starting from one number and ending
before another number.
-->
<p>La sécurité et la concision de la boucle <code>for</code> en font la construction de boucle
la plus utilisée avec Rust. Même dans des situations dans lesquelles vous
voudriez exécuter du code plusieurs fois, comme l'exemple du décompte qui
utilisait une boucle <code>while</code> dans l'encart 3-3, la plupart des Rustacés
utiliseraient une boucle <code>for</code>. Il faut pour cela utiliser un intervalle
<code>Range</code>, qui est un type fourni par la bibliothèque standard qui génère dans
l'ordre tous les nombres compris entre un certain nombre et un autre nombre.</p>
<!--
Here’s what the countdown would look like using a `for` loop and another method
we’ve not yet talked about, `rev`, to reverse the range:
-->
<p>Voici ce que le décompte aurait donné en utilisant une boucle <code>for</code> et une autre
méthode que nous n'avons pas encore vue, <code>rev</code>, qui inverse l'intervalle :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for nombre in (1..4).rev() {
        println!(&quot;{} !&quot;, nombre);
    }
    println!(&quot;DÉCOLLAGE !!!&quot;);
}
</code></pre></pre>
<!--
This code is a bit nicer, isn’t it?
-->
<p>Ce code est un peu plus sympa, non ?</p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé-2" id="résumé-2">Résumé</a></h2>
<!--
You made it! That was a sizable chapter: you learned about variables, scalar
and compound data types, functions, comments, `if` expressions, and loops! If
you want to practice with the concepts discussed in this chapter, try building
programs to do the following:
-->
<p>Vous y êtes arrivé ! C'était un chapitre important : vous avez appris les
variables, les types scalaires et composés, les fonctions, les commentaires, les
expressions <code>if</code>, et les boucles ! Si vous voulez pratiquer un peu les concepts
abordés dans ce chapitre, voici quelques programmes que vous pouvez essayer de
créer :</p>
<!--
* Convert temperatures between Fahrenheit and Celsius.
* Generate the nth Fibonacci number.
* Print the lyrics to the Christmas carol “The Twelve Days of Christmas,”
  taking advantage of the repetition in the song.
-->
<ul>
<li>Convertir des températures entre les degrés Fahrenheit et Celsius.</li>
<li>Générer le <em>n</em>-ième nombre de Fibonacci.</li>
<li>Afficher les paroles de la chanson de Noël <em>The Twelve Days of Christmas</em> en
profitant de l'aspect répétitif de la chanson.</li>
</ul>
<!--
When you’re ready to move on, we’ll talk about a concept in Rust that *doesn’t*
commonly exist in other programming languages: ownership.
-->
<p>Quand vous serez prêt à aller plus loin, nous aborderons une notion de Rust
qui n'existe <em>pas</em> dans les autres langages de programmation : la possession
<em>(ownership)</em>.</p>
<!--
[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[quitting-after-a-correct-guess]:
ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess
-->
<!--
# Understanding Ownership
-->
<h1><a class="header" href="#comprendre-la-possession" id="comprendre-la-possession">Comprendre la possession</a></h1>
<!--
Ownership is Rust’s most unique feature, and it enables Rust to make memory
safety guarantees without needing a garbage collector. Therefore, it’s
important to understand how ownership works in Rust. In this chapter, we’ll
talk about ownership as well as several related features: borrowing, slices,
and how Rust lays data out in memory.
-->
<p>La possession (<em>ownership</em>) est la fonctionnalité la plus remarquable de Rust,
et elle permet à Rust de garantir la sécurité de la mémoire sans avoir besoin
d'un ramasse-miettes (<em>garbage collector</em>). Par conséquent, il est important de
comprendre comment la possession fonctionne en Rust. Dans ce chapitre, nous
aborderons la possession, ainsi que d'autres fonctionnalités associées :
l'emprunt, les <em>slices</em> et la façon dont Rust agence les données en mémoire.</p>
<!--
## What Is Ownership?
-->
<h2><a class="header" href="#quest-ce-que-la-possession-" id="quest-ce-que-la-possession-">Qu'est-ce que la possession ?</a></h2>
<!--
Rust’s central feature is *ownership*. Although the feature is straightforward
to explain, it has deep implications for the rest of the language.
-->
<p>La principale spécificité de Rust est <em>la possession</em>. Bien que cette
fonctionnalité soit simple à expliquer, elle a de profondes conséquences sur le
reste du langage.</p>
<!--
All programs have to manage the way they use a computer’s memory while running.
Some languages have garbage collection that constantly looks for no longer used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks at
compile time. None of the ownership features slow down your program while it’s
running.
-->
<p>Tous les programmes doivent gérer la façon dont ils utilisent la mémoire
lorsqu'ils s'exécutent. Certains langages ont un ramasse-miettes qui scrute
constamment la mémoire qui n'est plus utilisée pendant qu'il s'exécute ; dans
d'autres langages, le développeur doit explicitement allouer et libérer la
mémoire. Rust adopte une troisième approche : la mémoire est gérée avec un
système de possession qui repose sur un jeu de règles que le compilateur vérifie
au moment de la compilation. Aucune des fonctionnalités de possession ne
ralentit votre programme à l'exécution.</p>
<!--
Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the more you’ll be able to naturally
develop code that is safe and efficient. Keep at it!
-->
<p>Comme la possession est un nouveau principe pour de nombreux développeurs,
cela prend un certain temps pour s'y familiariser. La bonne nouvelle est que
plus vous devenez expérimenté avec Rust et ses règles de possession, plus vous
développerez naturellement du code sûr et efficace. Gardez bien cela à
l'esprit !</p>
<!--
When you understand ownership, you’ll have a solid foundation for understanding
the features that make Rust unique. In this chapter, you’ll learn ownership by
working through some examples that focus on a very common data structure:
strings.
-->
<p>Lorsque vous comprendrez la possession, vous aurez des bases solides pour
comprendre les fonctionnalités qui font la particularité de Rust. Dans ce
chapitre, vous allez apprendre la possession en pratiquant avec plusieurs
exemples qui se concentrent sur une structure de données très courante : les
chaînes de caractères.</p>
<!--
> ### The Stack and the Heap
>
> In many programming languages, you don’t have to think about the stack and
> the heap very often. But in a systems programming language like Rust, whether
> a value is on the stack or the heap has more of an effect on how the language
> behaves and why you have to make certain decisions. Parts of ownership will
> be described in relation to the stack and the heap later in this chapter, so
> here is a brief explanation in preparation.
>
> Both the stack and the heap are parts of memory that are available to your code
> to use at runtime, but they are structured in different ways. The stack stores
> values in the order it gets them and removes the values in the opposite order.
> This is referred to as *last in, first out*. Think of a stack of plates: when
> you add more plates, you put them on top of the pile, and when you need a
> plate, you take one off the top. Adding or removing plates from the middle or
> bottom wouldn’t work as well! Adding data is called *pushing onto the stack*,
> and removing data is called *popping off the stack*.
>
> All data stored on the stack must have a known, fixed size. Data with an
> unknown size at compile time or a size that might change must be stored on
> the heap instead. The heap is less organized: when you put data on the heap,
> you request a certain amount of space. The operating system finds an empty
> spot in the heap that is big enough, marks it as being in use, and returns a
> *pointer*, which is the address of that location. This process is called
> *allocating on the heap* and is sometimes abbreviated as just *allocating*.
> Pushing values onto the stack is not considered allocating. Because the
> pointer is a known, fixed size, you can store the pointer on the stack, but
> when you want the actual data, you must follow the pointer.
>
> Think of being seated at a restaurant. When you enter, you state the number of
> people in your group, and the staff finds an empty table that fits everyone
> and leads you there. If someone in your group comes late, they can ask where
> you’ve been seated to find you.
>
> Pushing to the stack is faster than allocating on the heap because the
> operating system never has to search for a place to store new data; that
> location is always at the top of the stack. Comparatively, allocating space
> on the heap requires more work, because the operating system must first find
> a big enough space to hold the data and then perform bookkeeping to prepare
> for the next allocation.
>
> Accessing data in the heap is slower than accessing data on the stack because
> you have to follow a pointer to get there. Contemporary processors are faster
> if they jump around less in memory. Continuing the analogy, consider a server
> at a restaurant taking orders from many tables. It’s most efficient to get
> all the orders at one table before moving on to the next table. Taking an
> order from table A, then an order from table B, then one from A again, and
> then one from B again would be a much slower process. By the same token, a
> processor can do its job better if it works on data that’s close to other
> data (as it is on the stack) rather than farther away (as it can be on the
> heap). Allocating a large amount of space on the heap can also take time.
>
> When your code calls a function, the values passed into the function
> (including, potentially, pointers to data on the heap) and the function’s
> local variables get pushed onto the stack. When the function is over, those
> values get popped off the stack.
>
> Keeping track of what parts of code are using what data on the heap,
> minimizing the amount of duplicate data on the heap, and cleaning up unused
> data on the heap so you don’t run out of space are all problems that ownership
> addresses. Once you understand ownership, you won’t need to think about the
> stack and the heap very often, but knowing that managing heap data is why
> ownership exists can help explain why it works the way it does.
-->
<blockquote>
<h3><a class="header" href="#la-pile-et-le-tas" id="la-pile-et-le-tas">La pile et le tas</a></h3>
<p>Dans de nombreux langages, il n'est pas nécessaire de se préoccuper de la
pile (<em>stack</em>) et du tas (<em>heap</em>). Mais dans un langage de programmation
système comme Rust, qu'une donnée soit sur la pile ou sur le tas influe
sur le comportement du langage et explique pourquoi nous devons faire certains
choix. Nous décrirons plus loin dans ce chapitre comment la possession
fonctionne vis-à-vis de la pile et du tas, voici donc une brève explication au
préalable.</p>
<p>La pile et le tas sont tous les deux des emplacements de la mémoire qui
sont à disposition de votre code lors de son exécution, mais sont organisés de
façon différente. La pile enregistre les valeurs dans l'ordre qu'elle les
reçoit et enlève les valeurs dans l'autre sens. C'est ce que l'on appelle le
principe de <em>dernier entré, premier sorti</em>. C'est comme une pile d'assiettes :
quand vous ajoutez des nouvelles assiettes, vous les déposez sur le dessus de
la pile, et quand vous avez besoin d'une assiette, vous en prenez une sur le
dessus. Ajouter ou enlever des assiettes au milieu ou en bas ne serait pas
aussi efficace ! Ajouter une donnée sur la pile se dit <em>empiler</em> et en retirer
une se dit <em>dépiler</em>.</p>
<p>Toutes les données stockées dans la pile doivent avoir une taille connue et
fixe. Les données avec une taille inconnue au moment de la compilation ou une
taille qui peut changer doivent plutôt être stockées sur le tas. Le tas est
moins bien organisé : lorsque vous ajoutez des données sur le tas, vous
demandez une certaine quantité d'espace mémoire. Le système d'exploitation va
trouver un emplacement dans le tas qui est suffisamment grand, va le marquer
comme étant en cours d'utilisation, et va retourner un <em>pointeur</em>, qui est
l'adresse de cet emplacement. Cette procédure est appelée <em>allocation sur le
tas</em>, ce qu'on abrège parfois en <em>allocation</em> tout court. L'ajout de valeurs
sur la pile n'est pas considéré comme une allocation. Comme le pointeur a une
taille connue et fixe, on peut stocker ce pointeur sur la pile, mais quand on
veut la vraie donnée, il faut suivre le pointeur.</p>
<p>C'est comme si vous vouliez manger au restaurant. Quand vous entrez, vous
indiquez le nombre de personnes dans votre groupe, et le personnel trouve une
table vide qui peut recevoir tout le monde, et vous y conduit. Si quelqu'un
dans votre groupe arrive en retard, il peut leur demander où vous êtes assis
pour vous rejoindre.</p>
<p>Empiler sur la pile est plus rapide qu'allouer sur le tas car le système
d'exploitation ne va jamais avoir besoin de chercher un emplacement pour y
stocker les nouvelles données ; il le fait toujours au sommet de la pile. En
comparaison, allouer de la place sur le tas demande plus de travail, car le
système d'exploitation doit d'abord trouver un espace assez grand pour stocker
les données et mettre à jour son suivi pour préparer la prochaine allocation.</p>
<p>Accéder à des données dans le tas est plus lent que d'accéder aux données sur
la pile car nous devons suivre un pointeur pour les obtenir. Les processeurs
modernes sont plus rapides s'ils se déplacent moins dans la mémoire. Pour
continuer avec notre analogie, imaginez un serveur dans un restaurant qui
prend les commandes de nombreuses tables. C'est plus efficace de récupérer
toutes les commandes à une seule table avant de passer à la table suivante.
Prendre une commande à la table A, puis prendre une commande à la table B,
puis ensuite une autre à la table A, puis une autre à la table B serait un
processus bien plus lent. De la même manière, un processeur sera plus efficace
dans sa tâche s'il travaille sur des données qui sont proches les unes des
autres (comme c'est le cas sur la pile) plutôt que si elles sont plus
éloignées (comme cela peut être le cas sur le tas). Allouer une grande
quantité de mémoire sur le tas peut aussi prendre beaucoup de temps.</p>
<p>Quand notre code utilise une fonction, les valeurs passées à la fonction
(incluant, potentiellement, des pointeurs de données sur le tas) et les
variables locales à la fonction sont déposées sur la pile. Quand l'utilisation
de la fonction est terminée, ces données sont retirées de la pile.</p>
<p>La possession nous aide à ne pas nous préoccuper de faire attention à quelles
parties du code utilisent quelles données sur le tas, de minimiser la
quantité de données en double sur le tas, ou encore de veiller à libérer les
données inutilisées sur le tas pour que nous ne soyons pas à court d'espace.
Quand vous aurez compris la possession, vous n'aurez plus besoin de vous
préoccuper de la pile et du tas très souvent, mais savoir que la possession
existe pour gérer les données du tas peut vous aider à comprendre pourquoi
elle fonctionne de cette manière.</p>
</blockquote>
<!--
### Ownership Rules
-->
<h3><a class="header" href="#les-règles-de-la-possession" id="les-règles-de-la-possession">Les règles de la possession</a></h3>
<!--
First, let’s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:
-->
<p>Tout d'abord, définissons les règles de la possession. Gardez à l'esprit ces
règles pendant que nous travaillons sur des exemples qui les illustrent :</p>
<!--
* Each value in Rust has a variable that’s called its *owner*.
* There can only be one owner at a time.
* When the owner goes out of scope, the value will be dropped.
-->
<ul>
<li>Chaque valeur en Rust a une variable qui s'appelle son <em>propriétaire</em>.</li>
<li>Il ne peut y avoir qu'un seul propriétaire à la fois.</li>
<li>Quand le propriétaire sortira de la portée, la valeur sera supprimée.</li>
</ul>
<!--
### Variable Scope
-->
<h3><a class="header" href="#portée-de-la-variable" id="portée-de-la-variable">Portée de la variable</a></h3>
<!--
We’ve walked through an example of a Rust program already in Chapter 2. Now
that we’re past basic syntax, we won’t include all the `fn main() {` code in
examples, so if you’re following along, you’ll have to put the following
examples inside a `main` function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.
-->
<p>Nous avons déjà vu un exemple de programme Rust au chapitre 2. Maintenant
que nous avons vu la syntaxe Rust de base, nous n'allons plus ajouter tout le
code du style <code>fn main() {</code> dans les exemples, donc si vous voulez reproduire
les exemples, vous devrez les mettre manuellement dans une fonction <code>main</code>. Par
conséquent, nos exemples seront plus concis, nous permettant de nous concentrer
sur les détails de la situation plutôt que sur du code normalisé.</p>
<!--
As a first example of ownership, we’ll look at the *scope* of some variables. A
scope is the range within a program for which an item is valid. Let’s say we
have a variable that looks like this:
-->
<p>Pour le premier exemple de possession, nous allons analyser la <em>portée</em> de
certaines variables. Une portée est une zone dans un programme dans laquelle un
élément est en vigueur. Imaginons que nous ayons la variable suivante :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The variable `s` refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it’s declared until the end of the current *scope*. Listing 4-1 has
comments annotating where the variable `s` is valid.
-->
<p>La variable <code>s</code> fait référence à un littéral de chaîne de caractères, où la
valeur de la chaîne est codée en dur dans notre programme. La variable est en
vigueur à partir du moment où elle est déclarée jusqu'à la fin de la <em>portée</em>
actuelle. L'encart 4-1 a des commentaires pour indiquer quand la variable <code>s</code>
est en vigueur :</p>
<!--
```rust
{                      // s is not valid here, it’s not yet declared
    let s = "hello";   // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{            // s n'est pas en vigueur ici, elle n'est pas encore déclarée
    let s = &quot;hello&quot;;   // s est en vigueur à partir de ce point

    // on fait des choses avec s ici
}            // cette portée est maintenant terminée, et s n'est plus en vigueur
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-1: A variable and the scope in which it is
valid</span>
-->
<p><span class="caption">Encart 4-1 : Une variable et la portée dans laquelle elle
est en vigueur.</span></p>
<!--
In other words, there are two important points in time here:
-->
<p>Autrement dit, il y a ici deux étapes importantes :</p>
<!--
* When `s` comes *into scope*, it is valid.
* It remains valid until it goes *out of scope*.
-->
<ul>
<li>Quand <code>s</code> rentre <em>dans la portée</em>, elle est en vigueur.</li>
<li>Cela reste ainsi jusqu'à ce qu'elle <em>sort de la portée</em>.</li>
</ul>
<!--
At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we’ll build on top of this
understanding by introducing the `String` type.
-->
<p>Pour le moment, la relation entre les portées et les conditions pour lesquelles
les variables sont en vigueur sont similaires à d'autres langages de
programmation. Maintenant, nous allons aller plus loin en y ajoutant le type
<code>String</code>.</p>
<!--
### The `String` Type
-->
<h3><a class="header" href="#le-type-string" id="le-type-string">Le type <code>String</code></a></h3>
<!--
To illustrate the rules of ownership, we need a data type that is more complex
than the ones we covered in the [“Data Types”][data-types]<!-- ignore -- >
section of Chapter 3. The types covered previously are all stored on the stack
and popped off the stack when their scope is over, but we want to look at data
that is stored on the heap and explore how Rust knows when to clean up that
data.
-->
<p>Pour illustrer les règles de la possession, nous avons besoin d'un type de
donnée qui est plus complexe que ceux que nous avons rencontrés dans la section
<a href="ch03-02-data-types.html">“Types de données”</a><!-- ignore --> du chapitre 3. Les types que
nous avons vus précédemment sont tous stockés sur la pile et sont retirés de la
pile quand ils sortent de la portée, mais nous voulons expérimenter le stockage
de données sur le tas et découvrir comment Rust sait quand il doit nettoyer ces
données.</p>
<!--
We’ll use `String` as the example here and concentrate on the parts of `String`
that relate to ownership. These aspects also apply to other complex data types,
whether they are provided by the standard library or created by you. We’ll
discuss `String` in more depth in Chapter 8.
-->
<p>Nous allons utiliser ici <code>String</code> pour l'exemple et nous concentrer sur les
caractéristiques de <code>String</code> qui sont liées à la possession. Ces aspects
s'appliquent également à d'autres types de données complexes, qu'ils soient
fournis par la bibliothèque standard ou qu'ils soient créés par vous. Nous
verrons <code>String</code> plus en détail dans le chapitre 8.</p>
<!--
We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, `String`. This type is
allocated on the heap and as such is able to store an amount of text that is
unknown to us at compile time. You can create a `String` from a string literal
using the `from` function, like so:
-->
<p>Nous avons déjà vu les littéraux de chaînes de caractères, quand une valeur de
chaîne est codée en dur dans notre programme. Les littéraux de chaînes sont
pratiques, mais ils ne conviennent pas toujours à tous les cas où on veut
utiliser du texte. Une des raisons est qu'ils sont immuables. Une autre raison
est qu'on ne connaît pas forcément le contenu des chaînes de caractères quand
nous écrivons notre code : par exemple, comment faire si nous voulons récupérer
du texte saisi par l'utilisateur et l'enregistrer ? Pour ces cas-ci, Rust a un
second type de chaîne de caractères, <code>String</code>. Ce type est alloué sur le tas et
est ainsi capable de stocker une quantité de texte qui nous est inconnue au
moment de la compilation. Vous pouvez créer une <code>String</code> à partir d'un littéral
de chaîne de caractères en utilisant la fonction <code>from</code>, comme ceci :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
The double colon (`::`) is an operator that allows us to namespace this
particular `from` function under the `String` type rather than using some sort
of name like `string_from`. We’ll discuss this syntax more in the [“Method
Syntax”][method-syntax]<!-- ignore -- > section of Chapter 5 and when we talk
about namespacing with modules in [“Paths for Referring to an Item in the
Module Tree”][paths-module-tree]<!-- ignore -- > in Chapter 7.
-->
<p>Le double deux-points (<code>::</code>) est un opérateur qui nous permet d'appeler cette
fonction spécifique dans l'espace de nom du type <code>String</code> plutôt que d'utiliser
un nom comme <code>string_from</code>. Nous verrons cette syntaxe plus en détail dans la
section <a href="ch05-03-method-syntax.html">“Syntaxe de méthode”</a><!-- ignore --> du chapitre 5 et
lorsque nous aborderons les espaces de noms dans la section
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Les chemins pour désigner un élément dans l'arborescence de
module”</a><!-- ignore --> du chapitre 7.</p>
<!--
This kind of string *can* be mutated:
-->
<p>Ce type de chaîne de caractères <em>peut</em> être mutable :</p>
<!--
```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() appends a literal to a String

println!("{}", s); // This will print `hello, world!`
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str() ajoute un littéral de chaîne dans une String

println!(&quot;{}&quot;, s); // Cela va afficher `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<!--
So, what’s the difference here? Why can `String` be mutated but literals
cannot? The difference is how these two types deal with memory.
-->
<p>Donc, quelle est la différence ici ? Pourquoi <code>String</code> peut être mutable, mais
pourquoi les littéraux de chaînes ne peuvent pas l'être ? La différence
se trouve dans la façon dont ces deux types travaillent avec la mémoire.</p>
<!--
### Memory and Allocation
-->
<h3><a class="header" href="#mémoire-et-allocation" id="mémoire-et-allocation">Mémoire et allocation</a></h3>
<!--
In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal’s immutability. Unfortunately, we can’t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.
-->
<p>Dans le cas d'un littéral de chaîne de caractères, nous connaissons le contenu
au moment de la compilation donc le texte est codé en dur directement dans
l'exécutable final. Voilà pourquoi ces littéraux de chaînes de caractères sont
performants et rapides. Mais ces caractéristiques viennent de leur immuabilité.
Malheureusement, on ne peut pas accorder une grosse région de mémoire dans le
binaire pour chaque morceau de texte qui n'a pas de taille connue au moment de
la compilation et dont la taille pourrait changer pendant l'exécution de ce
programme.</p>
<!--
With the `String` type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:
-->
<p>Avec le type <code>String</code>, pour nous permettre d'avoir un texte mutable et qui peut
s'agrandir, nous devons allouer une quantité de mémoire sur le tas, inconnue
au moment de la compilation, pour stocker le contenu. Cela signifie que :</p>
<!--
* The memory must be requested from the operating system at runtime.
* We need a way of returning this memory to the operating system when we’re
  done with our `String`.
-->
<ul>
<li>La mémoire doit être demandée auprès du système d'exploitation lors de
l'exécution.</li>
<li>Nous avons besoin d'un moyen de rendre cette mémoire au système
d'exploitation lorsque nous aurons fini d'utiliser notre <code>String</code>.</li>
</ul>
<!--
That first part is done by us: when we call `String::from`, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.
-->
<p>Nous nous occupons de ce premier point : quand nous appelons <code>String::from</code>, son
implémentation demande la mémoire dont elle a besoin. C'est pratiquement
toujours ainsi dans la majorité des langages de programmation.</p>
<!--
However, the second part is different. In languages with a *garbage collector
(GC)*, the GC keeps track and cleans up memory that isn’t being used anymore,
and we don’t need to think about it. Without a GC, it’s our responsibility to
identify when memory is no longer being used and call code to explicitly return
it, just as we did to request it. Doing this correctly has historically been a
difficult programming problem. If we forget, we’ll waste memory. If we do it
too early, we’ll have an invalid variable. If we do it twice, that’s a bug too.
We need to pair exactly one `allocate` with exactly one `free`.
-->
<p>Cependant, le deuxième point est différent. Dans des langages avec un
<em>ramasse-miettes</em>, le ramasse-miettes surveille et nettoie la mémoire qui n'est
plus utilisée, sans que nous n'ayons à nous en préoccuper. Sans un
ramasse-miettes, c'est de notre responsabilité d'identifier quand cette mémoire
n'est plus utilisée et d'appeler du code pour explicitement la libérer, comme
nous l'avons fait pour la demander auparavant. Historiquement, faire ceci
correctement a toujours été une difficulté pour les développeurs. Si nous
oublions de le faire, nous allons gaspiller de la mémoire. Si nous le faisons
trop tôt, nous allons avoir une variable invalide. Si nous le faisons deux fois,
cela produit aussi un bogue. Nous devons associer exactement un <code>allocate</code> avec
exactement un <code>free</code>.</p>
<!--
Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Here’s a version of our scope example
from Listing 4-1 using a `String` instead of a string literal:
-->
<p>Rust prend un chemin différent : la mémoire est automatiquement libérée dès
que la variable qui la possède sort de la portée. Voici une version de notre
exemple de portée de l'encart 4-1 qui utilise une <code>String</code> plutôt qu'un littéral
de chaîne de caractères :</p>
<!--
```rust
{
    let s = String::from("hello"); // s is valid from this point forward

    // do stuff with s
}                                  // this scope is now over, and s is no
                                   // longer valid
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // s est en vigueur à partir de ce point

    // on fait des choses avec s ici
}                                  // cette portée est désormais terminée, et s
                                   // n'est plus en vigueur maintenant
<span class="boring">}
</span></code></pre></pre>
<!--
There is a natural point at which we can return the memory our `String` needs
to the operating system: when `s` goes out of scope. When a variable goes out
of scope, Rust calls a special function for us. This function is called `drop`,
and it’s where the author of `String` can put the code to return the memory.
Rust calls `drop` automatically at the closing curly bracket.
-->
<p>Il y a un moment naturel où nous devons rendre la mémoire de notre
<code>String</code> au système d'exploitation : quand <code>s</code> sort de la portée. Quand une
variable sort de la portée, Rust appelle une fonction spéciale pour nous. Cette
fonction s'appelle <code>drop</code>, et c'est dans celle-ci que l'auteur de <code>String</code> a pu
mettre le code pour libérer la mémoire. Rust appelle automatiquement <code>drop</code> à
l'accolade fermante <code>}</code>.</p>
<!--
> Note: In C++, this pattern of deallocating resources at the end of an item’s
> lifetime is sometimes called *Resource Acquisition Is Initialization (RAII)*.
> The `drop` function in Rust will be familiar to you if you’ve used RAII
> patterns.
-->
<blockquote>
<p>Remarque : en C++, cette façon de libérer des ressources à la fin de la
durée de vie d'un élément est parfois appelée <em>l'acquisition d'une ressource
est une initialisation (RAII)</em>. La fonction <code>drop</code> de Rust vous sera familière
si vous avez déjà utilisé des techniques de RAII.</p>
</blockquote>
<!--
This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
we’ve allocated on the heap. Let’s explore some of those situations now.
-->
<p>Cette façon de faire a un impact profond sur la façon dont le code Rust est
écrit. Cela peut sembler simple dans notre cas, mais le comportement du code
peut être surprenant dans des situations plus compliquées où nous voulons
avoir plusieurs variables utilisant des données que nous avons affectées sur le
tas. Examinons une de ces situations dès à présent.</p>
<!--
#### Ways Variables and Data Interact: Move
-->
<h4><a class="header" href="#les-interactions-entre-les-variables-et-les-données--le-déplacement" id="les-interactions-entre-les-variables-et-les-données--le-déplacement">Les interactions entre les variables et les données : le déplacement</a></h4>
<!--
Multiple variables can interact with the same data in different ways in Rust.
Let’s look at an example using an integer in Listing 4-2.
-->
<p>Plusieurs variables peuvent interagir avec les mêmes données de différentes
manières en Rust. Regardons un exemple avec un entier dans l'encart 4-2 :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-2: Assigning the integer value of variable `x`
to `y`</span>
-->
<p><span class="caption">Encart 4-2 : Assigner l'entier de la variable <code>x</code> à <code>y</code>
</span></p>
<!--
We can probably guess what this is doing: “bind the value `5` to `x`; then make
a copy of the value in `x` and bind it to `y`.” We now have two variables, `x`
and `y`, and both equal `5`. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two `5` values are pushed
onto the stack.
-->
<p>Nous pouvons probablement deviner ce que ce code fait : “Assigner la valeur <code>5</code>
à <code>x</code> ; ensuite faire une copie de cette valeur de <code>x</code> et l'assigner à <code>y</code>.”
Nous avons maintenant deux variables, <code>x</code> et <code>y</code>, et chacune vaut <code>5</code>. C'est
effectivement ce qui se passe, car les entiers sont des valeurs simples avec une
taille connue et fixée, et ces deux valeurs <code>5</code> sont stockées sur la pile.</p>
<!--
Now let’s look at the `String` version:
-->
<p>Maintenant, essayons une nouvelle version avec <code>String</code> :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<!--
This looks very similar to the previous code, so we might assume that the way
it works would be the same: that is, the second line would make a copy of the
value in `s1` and bind it to `s2`. But this isn’t quite what happens.
-->
<p>Cela ressemble beaucoup au code précédent, donc nous allons supposer que cela
fonctionne pareil que précédemment : ainsi, la seconde ligne va faire une copie
de la valeur de <code>s1</code> et l'assigner à <code>s2</code>. Mais ce n'est pas tout à fait ce
qu'il se passe.</p>
<!--
Take a look at Figure 4-1 to see what is happening to `String` under the
covers. A `String` is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.
-->
<p>Regardons l'illustration 4-1 pour découvrir ce qui arrive à <code>String</code> sous le
capot. Une <code>String</code> est constituée de trois éléments, présents sur la gauche :
un pointeur vers la mémoire qui contient le contenu de la chaîne de caractères,
une taille, et une capacité. Ce groupe de données est stocké sur la pile. À
droite, nous avons la mémoire sur le tas qui contient les données.</p>
<!-- markdownlint-disable -->
<!--
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="Une string en mémoire" src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-1: Representation in memory of a `String`
holding the value `"hello"` bound to `s1`</span>
-->
<p><span class="caption">Illustration 4-1 : Représentation en mémoire d'une
<code>String</code> qui contient la valeur <code>&quot;hello&quot;</code> assignée à <code>s1</code>.</span></p>
<!--
The length is how much memory, in bytes, the contents of the `String` is
currently using. The capacity is the total amount of memory, in bytes, that the
`String` has received from the operating system. The difference between length
and capacity matters, but not in this context, so for now, it’s fine to ignore
the capacity.
-->
<p>La taille est la quantité de mémoire, en octets, que le contenu de la <code>String</code>
utilise actuellement. La capacité est la quantité totale de mémoire, en octets,
que la <code>String</code> a reçue du système d'exploitation. La différence entre la taille
et la capacité est importante, mais pas pour notre exemple, donc pour l'instant,
ce n'est pas grave d'ignorer la capacité.</p>
<!--
When we assign `s1` to `s2`, the `String` data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.
-->
<p>Quand nous assignons <code>s1</code> à <code>s2</code>, les données de la <code>String</code> sont copiées, ce
qui veut dire que nous copions le pointeur, la taille et la capacité qui sont
stockés sur la pile. Nous ne copions pas les données stockées sur le tas
auxquelles le pointeur se réfère. Autrement dit, la représentation des données
dans la mémoire ressemble à l'illustration 4-2.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 qui pointent vers la même valeur" src="img/trpl04-02.svg"
class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-2: Representation in memory of the variable `s2`
that has a copy of the pointer, length, and capacity of `s1`</span>
-->
<p><span class="caption">Illustration 4-2 : Représentation en mémoire de la
variable <code>s2</code> qui a une copie du pointeur, de la taille et de la capacité de
<code>s1</code></span></p>
<!--
The representation does *not* look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation `s2 = s1` could be very expensive in terms of runtime performance if
the data on the heap were large.
-->
<p>Cette représentation <em>n'est pas</em> comme l'illustration 4-3, qui représenterait la
mémoire si Rust avait aussi copié les données sur le tas. Si Rust faisait ceci,
l'opération <code>s2 = s1</code> pourrait potentiellement être très coûteuse en termes de
performances d'exécution si les données sur le tas étaient volumineuses.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 et s2 à deux endroits" src="img/trpl04-03.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-3: Another possibility for what `s2 = s1` might
do if Rust copied the heap data as well</span>
-->
<p><span class="caption">Illustration 4-3 : Une autre possibilité de ce que
pourrait faire <code>s2 = s1</code> si Rust copiait aussi les données du tas</span></p>
<!--
Earlier, we said that when a variable goes out of scope, Rust automatically
calls the `drop` function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when `s2` and `s1` go out of scope, they will both try to free the
same memory. This is known as a *double free* error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.
-->
<p>Précédemment, nous avons dit que quand une variable sortait de la portée, Rust
appelait automatiquement la fonction <code>drop</code> et nettoyait la mémoire sur le tas
allouée pour cette variable. Mais l'illustration 4-2 montre que les deux
pointeurs de données pointeraient au même endroit. C'est un problème : quand
<code>s2</code> et <code>s1</code> sortent de la portée, elles vont essayer toutes les deux de
libérer la même mémoire. C'est ce qu'on appelle une erreur de <em>double
libération</em> et c'est un des bogues de sécurité de mémoire que nous avons
mentionnés précédemment. Libérer la mémoire deux fois peut mener à des
corruptions de mémoire, ce qui peut potentiellement mener à des vulnérabilités
de sécurité.</p>
<!--
To ensure memory safety, there’s one more detail to what happens in this
situation in Rust. Instead of trying to copy the allocated memory, Rust
considers `s1` to no longer be valid and, therefore, Rust doesn’t need to free
anything when `s1` goes out of scope. Check out what happens when you try to
use `s1` after `s2` is created; it won’t work:
-->
<p>Pour garantir la sécurité de la mémoire, il y a un autre petit détail qui se
produit dans cette situation avec Rust. Plutôt qu'essayer de copier la mémoire
allouée, Rust considère que <code>s1</code> n'est plus en vigueur et donc, Rust n'a pas
besoin de libérer quoi que ce soit lorsque <code>s1</code> sort de la portée. Regardez ce
qu'il se passe quand vous essayez d'utiliser <code>s1</code> après que <code>s2</code> est créé,
cela ne va pas fonctionner :</p>
<pre><code class="language-rust ignore does_not_compile">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<!--
You’ll get an error like this because Rust prevents you from using the
invalidated reference:
-->
<p>Vous allez avoir une erreur comme celle-ci, car Rust vous défend d'utiliser la
référence qui n'est plus en vigueur :</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 -- &gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<!--
If you’ve heard the terms *shallow copy* and *deep copy* while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of being called a
shallow copy, it’s known as a *move*. In this example, we would say that
`s1` was *moved* into `s2`. So what actually happens is shown in Figure 4-4.
-->
<p>Si vous avez déjà entendu parler de <em>copie superficielle</em> et de <em>copie
profonde</em> en utilisant d'autres langages, l'idée de copier le pointeur, la
taille et la capacité sans copier les données peut vous faire penser à de la
copie superficielle. Mais comme Rust neutralise aussi la première variable, au
lieu d'appeler cela une copie superficielle, on appelle cela un <em>déplacement</em>.
Ici, nous pourrions dire que <code>s1</code> a été <em>déplacé</em> dans <code>s2</code>. Donc ce qui se
passe réellement est décrit par l'illustration 4-4.</p>
<!-- markdownlint-disable -->
<!--
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="s1 déplacé dans s2" src="img/trpl04-04.svg" class="center"
style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-4: Representation in memory after `s1` has been
invalidated</span>
-->
<p><span class="caption">Illustration 4-4 : Représentation de la mémoire après que
<code>s1</code> a été neutralisée</span></p>
<!--
That solves our problem! With only `s2` valid, when it goes out of scope, it
alone will free the memory, and we’re done.
-->
<p>Cela résout notre problème ! Avec seulement <code>s2</code> en vigueur, quand elle
sortira de la portée, elle seule va libérer la mémoire, et c'est tout.</p>
<!--
In addition, there’s a design choice that’s implied by this: Rust will never
automatically create “deep” copies of your data. Therefore, any *automatic*
copying can be assumed to be inexpensive in terms of runtime performance.
-->
<p>De plus, cela signifie qu'il y a eu un choix de conception : Rust ne va jamais
créer automatiquement de copie “profonde” de vos données. Par conséquent, toute
copie <em>automatique</em> peut être considérée comme peu coûteuse en termes de
performances d'exécution.</p>
<!--
#### Ways Variables and Data Interact: Clone
-->
<h4><a class="header" href="#les-interactions-entre-les-variables-et-les-données--le-clonage" id="les-interactions-entre-les-variables-et-les-données--le-clonage">Les interactions entre les variables et les données : le clonage</a></h4>
<!--
If we *do* want to deeply copy the heap data of the `String`, not just the
stack data, we can use a common method called `clone`. We’ll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, you’ve probably seen them before.
-->
<p>Si nous <em>voulons</em> faire une copie profonde des données sur le tas d'une
<code>String</code>, et pas seulement des données sur la pile, nous pouvons utiliser une
méthode commune qui s'appelle <code>clone</code>. Nous aborderons la syntaxe des méthodes
au chapitre 5, mais comme les méthodes sont des outils courants dans de
nombreux langages, vous les avez probablement utilisées auparavant.</p>
<!--
Here’s an example of the `clone` method in action:
-->
<p>Voici un exemple d'utilisation de la méthode <code>clone</code> :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data *does* get copied.
-->
<p>Cela fonctionne très bien et c'est ainsi que vous pouvez reproduire le
comportement décrit dans l'illustration 4-3, où les données du tas sont copiées.</p>
<!--
When you see a call to `clone`, you know that some arbitrary code is being
executed and that code may be expensive. It’s a visual indicator that something
different is going on.
-->
<p>Quand vous voyez un appel à <code>clone</code>, vous savez que du code arbitraire est
exécuté et que ce code peut être coûteux. C'est un indicateur visuel qu'il se
passe quelque chose de différent.</p>
<!--
#### Stack-Only Data: Copy
-->
<h4><a class="header" href="#données-uniquement-sur-la-pile--la-copie" id="données-uniquement-sur-la-pile--la-copie">Données uniquement sur la pile : la copie</a></h4>
<!--
There’s another wrinkle we haven’t talked about yet. This code using integers,
part of which was shown in Listing 4-2, works and is valid:
-->
<p>Il y a un autre détail dont on n'a pas encore parlé. Le code suivant utilise
des entiers, et on en a vu une partie dans l'encart 4-2 ; il fonctionne et
est correct :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
But this code seems to contradict what we just learned: we don’t have a call to
`clone`, but `x` is still valid and wasn’t moved into `y`.
-->
<p>Mais ce code semble contredire ce que nous venons d'apprendre : nous n'avons
pas appelé <code>clone</code>, mais <code>x</code> est toujours en vigueur et n'a pas été déplacé
dans <code>y</code>.</p>
<!--
The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means there’s no reason we would want to prevent `x` from being
valid after we create the variable `y`. In other words, there’s no difference
between deep and shallow copying here, so calling `clone` wouldn’t do anything
different from the usual shallow copying and we can leave it out.
-->
<p>La raison est que les types comme les entiers ont une taille connue au moment de
la compilation et sont entièrement stockés sur la pile, donc la copie des
vraies valeurs est rapide à faire. Cela signifie qu'il n'y a pas de raison que
nous voudrions neutraliser <code>x</code> après avoir créé la variable <code>y</code>. En d'autres
termes, il n'y a pas ici de différence entre la copie superficielle et profonde,
donc appeler <code>clone</code> ne ferait rien d'autre qu'une copie superficielle classique
et on peut s'en passer.</p>
<!--
Rust has a special annotation called the `Copy` trait that we can place on
types like integers that are stored on the stack (we’ll talk more about traits
in Chapter 10). If a type has the `Copy` trait, an older variable is still
usable after assignment. Rust won’t let us annotate a type with the `Copy`
trait if the type, or any of its parts, has implemented the `Drop` trait. If
the type needs something special to happen when the value goes out of scope and
we add the `Copy` annotation to that type, we’ll get a compile-time error. To
learn about how to add the `Copy` annotation to your type, see [“Derivable
Traits”][derivable-traits]<!-- ignore -- > in Appendix C.
-->
<p>Rust a une annotation spéciale appelée le trait <code>Copy</code> que nous pouvons utiliser
sur des types comme les entiers qui sont stockés sur la pile (nous verrons les
traits dans le chapitre 10). Si un type a le trait <code>Copy</code>, l'ancienne variable
sera toujours utilisable après avoir été affectée. Rust ne nous autorisera pas à
annoter un type avec le trait <code>Copy</code> si ce type, ou un de ses éléments, a
implémenté le trait <code>Drop</code>. Si ce type a besoin que quelque chose de spécial se
produise quand la valeur sort de la portée et que nous ajoutons l'annotation
<code>Copy</code> sur ce type, nous aurons une erreur au moment de la compilation. Pour
savoir comment ajouter l'annotation <code>Copy</code> sur votre type, référez-vous à
<a href="appendix-03-derivable-traits.html">l'annexe C</a><!-- ignore --> sur les traits dérivables.</p>
<!--
So what types are `Copy`? You can check the documentation for the given type to
be sure, but as a general rule, any group of simple scalar values can be
`Copy`, and nothing that requires allocation or is some form of resource is
`Copy`. Here are some of the types that are `Copy`:
-->
<p>Donc, quels sont les types qui sont <code>Copy</code> ? Vous pouvez regarder dans la
documentation pour un type donné pour vous en assurer, mais de manière générale,
tout groupe de valeur scalaire peut être <code>Copy</code>, et tout ce qui ne nécessite pas
d'allocation de mémoire ou tout autre forme de ressource est <code>Copy</code>.
Voici quelques types qui sont <code>Copy</code> :</p>
<!--
* All the integer types, such as `u32`.
* The Boolean type, `bool`, with values `true` and `false`.
* All the floating point types, such as `f64`.
* The character type, `char`.
* Tuples, if they only contain types that are also `Copy`. For example,
  `(i32, i32)` is `Copy`, but `(i32, String)` is not.
-->
<ul>
<li>Tous les types d'entiers, comme <code>u32</code>.</li>
<li>Le type booléen, <code>bool</code>, avec les valeurs <code>true</code> et <code>false</code>.</li>
<li>Tous les types de flottants, comme <code>f64</code>.</li>
<li>Le type de caractère, <code>char</code>.</li>
<li>Les tuples, mais uniquement s'ils contiennent des types qui sont aussi <code>Copy</code>.
Par exemple, le <code>(i32, i32)</code> est <code>Copy</code>, mais pas <code>(i32, String)</code>.</li>
</ul>
<!--
### Ownership and Functions
-->
<h3><a class="header" href="#la-possession-et-les-fonctions" id="la-possession-et-les-fonctions">La possession et les fonctions</a></h3>
<!--
The semantics for passing a value to a function are similar to those for
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.
-->
<p>La syntaxe pour passer une valeur à une fonction est similaire à celle pour
assigner une valeur à une variable. Passer une variable à une fonction va la
déplacer ou la copier, comme l'assignation. L'encart 4-3 est un exemple avec
quelques commentaires qui montrent où les variables rentrent et sortent de la
portée :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s rentre dans la portée.

    prendre_possession(s);  // La valeur de s est déplacée dans la fonction…
                            // … et n'est plus en vigueur à partir d'ici

    let x = 5;              // x rentre dans la portée.

    creer_copie(x);         // x va être déplacée dans la fonction,
                            // mais i32 est Copy, donc on peut
                            // utiliser x ensuite.

} // Ici, x sort de la portée, puis ensuite s. Mais puisque la valeur de s a
  // été déplacée, il ne se passe rien de spécial.

fn prendre_possession(texte: String) { // texte rentre dans la portée.
    println!(&quot;{}&quot;, texte);
} // Ici, texte sort de la portée et `drop` est appelé. La mémoire est libérée.

fn creer_copie(entier: i32) { // entier rentre dans la portée.
    println!(&quot;{}&quot;, entier);
} // Ici, entier sort de la portée. Il ne se passe rien de spécial.
</code></pre></pre>
<!--
<span class="caption">Listing 4-3: Functions with ownership and scope
annotated</span>
-->
<p><span class="caption">Encart 4-3 : Les fonctions avec les possessions et les
portées qui sont commentées</span></p>
<!--
If we tried to use `s` after the call to `takes_ownership`, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to `main` that uses `s` and `x` to see where you can use them and where
the ownership rules prevent you from doing so.
-->
<p>Si on essayait d'utiliser <code>s</code> après l'appel à <code>prendre_possession</code>, Rust
déclencherait une erreur à la compilation. Ces vérifications statiques
nous protègent des erreurs. Essayez d'ajouter du code au <code>main</code> qui utilise <code>s</code>
et <code>x</code> pour découvrir lorsque vous pouvez les utiliser et lorsque les règles de
la possession vous empêchent de le faire.</p>
<!--
### Return Values and Scope
-->
<h3><a class="header" href="#les-valeurs-de-retour-et-les-portées" id="les-valeurs-de-retour-et-les-portées">Les valeurs de retour et les portées</a></h3>
<!--
Returning values can also transfer ownership. Listing 4-4 is an example with
similar annotations to those in Listing 4-3.
-->
<p>Retourner des valeurs peut aussi transférer leur possession. L'encart 4-4 est un
exemple avec des annotations similaires à celles de l'encart 4-3 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = donne_possession();     // donne_possession déplace sa valeur de
                                     // retour dans s1

    let s2 = String::from(&quot;hello&quot;);  // s2 rentre dans la portée

    let s3 = prend_et_rend(s2);      // s2 est déplacée dans
                                     // prend_et_rend, qui elle aussi
                                     // déplace sa valeur de retour dans s3.
} // Ici, s3 sort de la portée et est éliminée. s2 sort de la portée mais a été
  // déplacée donc il ne se passe rien. s1 sort aussi de la portée et est
  // éliminée.

fn donne_possession() -&gt; String {        // donne_possession va déplacer sa
                                         // valeur de retour dans la
                                         // fonction qui l'appelle.

    let texte = String::from(&quot;hello&quot;);   // texte rentre dans la portée.

    texte                                // texte est retournée et
                                         // est déplacée vers le code qui
                                         // l'appelle.
}

// prend_et_rend va prendre une String et en retourne aussi une.
fn prend_et_rend(texte: String) -&gt; String { // texte rentre dans la portée.

    texte  // texte est retournée et déplacée vers le code qui l'appelle.
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-4: Transferring ownership of return
values</span>
-->
<p><span class="caption">Encart 4-4 : Transferts de possession des valeurs de
retour</span></p>
<!--
The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by `drop` unless the data
has been moved to be owned by another variable.
-->
<p>La possession d'une variable suit toujours le même schéma à chaque fois :
assigner une valeur à une autre variable la déplace. Quand une variable qui
contient des données sur le tas sort de la portée, la valeur sera nettoyée
avec <code>drop</code> à moins que la donnée ait été déplacée pour être possédée par une
autre variable.</p>
<!--
Taking ownership and then returning ownership with every function is a bit
tedious. What if we want to let a function use a value but not take ownership?
It’s quite annoying that anything we pass in also needs to be passed back if we
want to use it again, in addition to any data resulting from the body of the
function that we might want to return as well.
-->
<p>Il est un peu fastidieux de prendre la possession puis ensuite de retourner la
possession à chaque fonction. Et qu'est-ce qu'il se passe si nous voulons
qu'une fonction utilise une valeur, mais n'en prenne pas possession ? C'est
assez pénible que tout ce que nous passons doit être retourné si nous voulons
l'utiliser à nouveau, en plus de toutes les données qui découlent du corps
de la fonction que nous voulons aussi récupérer.</p>
<!--
It’s possible to return multiple values using a tuple, as shown in Listing 4-5.
-->
<p>Il est possible de retourner plusieurs valeurs à l'aide d'un tuple, comme ceci :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, taille) = calculer_taille(s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s2, taille);
}

fn calculer_taille(s: String) -&gt; (String, usize) {
    let taille = s.len(); // len() retourne la taille d'une String.

    (s, taille)
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-5: Returning ownership of parameters</span>
-->
<p><span class="caption">Encart 4-5 : Retourner la possession des paramètres</span></p>
<!--
But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for this concept, called
*references*.
-->
<p>Mais c'est trop laborieux et beaucoup de travail pour un principe qui devrait
être banal. Heureusement pour nous, Rust a une fonctionnalité pour ce principe,
c'est ce qu'on appelle les <em>références</em>.</p>
<!-- markdownlint-disable -->
<!--
[data-types]: ch03-02-data-types.html#data-types
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
-->
<!-- markdownlint-restore -->
<!--
## References and Borrowing
-->
<h2><a class="header" href="#les-références-et-lemprunt" id="les-références-et-lemprunt">Les références et l'emprunt</a></h2>
<!--
The issue with the tuple code in Listing 4-5 is that we have to return the
`String` to the calling function so we can still use the `String` after the
call to `calculate_length`, because the `String` was moved into
`calculate_length`.
-->
<p>La difficulté avec le code du tuple à la fin de la section précédente est que
nous avons besoin de retourner la <code>String</code> au code appelant pour qu'il puisse
continuer à utiliser la <code>String</code> après l'appel à <code>calculer_taille</code>, car la
<code>String</code> a été déplacée dans <code>calculer_taille</code>.</p>
<!--
Here is how you would define and use a `calculate_length` function that has a
reference to an object as a parameter instead of taking ownership of the
value:
-->
<p>Voici comment définir et utiliser une fonction <code>calculer_taille</code> qui prend une
<em>référence</em> à un objet en paramètre plutôt que de prendre possession de la
valeur :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let long = calculer_taille(&amp;s1);

    println!(&quot;La taille de '{}' est {}.&quot;, s1, long);
}

fn calculer_taille(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<!--
First, notice that all the tuple code in the variable declaration and the
function return value is gone. Second, note that we pass `&s1` into
`calculate_length` and, in its definition, we take `&String` rather than
`String`.
-->
<p>Premièrement, on peut observer que tout le code des <em>tuples</em> dans la déclaration
des variables et dans la valeur de retour de la fonction a été enlevé.
Deuxièmement, remarquez que nous passons <code>&amp;s1</code> à <code>calculer_taille</code>, et que dans
sa définition, nous utilisons <code>&amp;String</code> plutôt que <code>String</code>.</p>
<!--
These ampersands are *references*, and they allow you to refer to some value
without taking ownership of it. Figure 4-5 shows a diagram.
-->
<p>Ces esperluettes sont des <em>références</em>, et elles permettent de vous référer à
une valeur sans en prendre possession. L'illustration 4-5 nous montre cela dans
un schéma.</p>
<!-- markdownlint-disable -->
<!--
<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />
-->
<!-- markdownlint-restore -->
<p><img alt="&String s qui pointe vers la String s1" src="img/trpl04-05.svg"
class="center" /></p>
<!--
<span class="caption">Figure 4-5: A diagram of `&String s` pointing at `String
s1`</span>
-->
<p><span class="caption">Illustration 4-5 : Un schéma de la <code>&amp;String s</code> qui pointe
vers la <code>String s1</code></span></p>
<!--
> Note: The opposite of referencing by using `&` is *dereferencing*, which is
> accomplished with the dereference operator, `*`. We’ll see some uses of the
> dereference operator in Chapter 8 and discuss details of dereferencing in
> Chapter 15.
-->
<blockquote>
<p>Remarque : l'opposé de la création de références avec <code>&amp;</code> est le
<em>déréférencement</em>, qui s'effectue avec l'opérateur de déréférencement, <code>*</code>.
Nous allons voir quelques utilisations de l'opérateur de déréférencement dans
le chapitre 8 et nous aborderons les détails du déréférencement dans le
chapitre 15.</p>
</blockquote>
<!--
Let’s take a closer look at the function call here:
-->
<p>Regardons de plus près l'appel à la fonction :</p>
<!--
```rust
# fn calculate_length(s: &String) -> usize {
#     s.len()
# }
let s1 = String::from("hello");

let len = calculate_length(&s1);
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn calculer_taille(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span>let s1 = String::from(&quot;hello&quot;);

let long = calculer_taille(&amp;s1);
<span class="boring">}
</span></code></pre></pre>
<!--
The `&s1` syntax lets us create a reference that *refers* to the value of `s1`
but does not own it. Because it does not own it, the value it points to will
not be dropped when the reference goes out of scope.
-->
<p>La syntaxe <code>&amp;s1</code> nous permet de créer une référence qui se <em>réfère</em> à la valeur
de <code>s1</code> mais n'en prend pas possession. Et comme elle ne la possède pas, la
valeur vers laquelle elle pointe ne sera pas libérée quand cette référence
sortira de la portée.</p>
<!--
Likewise, the signature of the function uses `&` to indicate that the type of
the parameter `s` is a reference. Let’s add some explanatory annotations:
-->
<p>De la même manière, la signature de la fonction utilise <code>&amp;</code> pour indiquer que
le type du paramètre <code>s</code> est une référence. Ajoutons quelques commentaires
explicatifs :</p>
<!--
```rust
fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, nothing happens.
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn calculer_taille(s: &amp;String) -&gt; usize { // s est une référence à une String
    s.len()
} // Ici, s sort de la portée. Mais comme elle ne prend pas possession de ce
  // à quoi elle fait référence, il ne se passe rien.
<span class="boring">}
</span></code></pre></pre>
<!--
The scope in which the variable `s` is valid is the same as any function
parameter’s scope, but we don’t drop what the reference points to when it goes
out of scope because we don’t have ownership. When functions have references as
parameters instead of the actual values, we won’t need to return the values in
order to give back ownership, because we never had ownership.
-->
<p>La portée dans laquelle la variable <code>s</code> est en vigueur est la même que toute
portée d'un paramètre de fonction, mais nous ne libérons pas ce sur quoi cette
référence pointe quand elle sort de la portée, car nous n'en prenons pas
possession. Lorsque les fonctions ont des références en paramètres au lieu des
valeurs réelles, nous n'avons pas besoin de retourner les valeurs pour les
rendre, car nous n'en avons jamais pris possession.</p>
<!--
We call having references as function parameters *borrowing*. As in real life,
if a person owns something, you can borrow it from them. When you’re done, you
have to give it back.
-->
<p>Quand nous avons des références dans les paramètres d'une fonction, nous
appelons cela <em>l'emprunt</em>. Comme dans la vie réelle, quand un objet appartient
à quelqu'un, vous pouvez le lui emprunter. Et quand vous avez fini, vous devez
le lui rendre.</p>
<!--
So what happens if we try to modify something we’re borrowing? Try the code in
Listing 4-6. Spoiler alert: it doesn’t work!
-->
<p>Donc qu'est-ce qui se passe si nous essayons de modifier quelque chose que nous
empruntons ? Essayez le code dans l'encart 4-6. Attention, spoiler : cela ne
fonctionne pas !</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    changer(&amp;s);
}

fn changer(texte: &amp;String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 4-6: Attempting to modify a borrowed value</span>
-->
<p><span class="caption">Entrée 4-6 : Tentative de modification d'une valeur
empruntée.</span></p>
<!--
Here’s the error:
-->
<p>Voici l'erreur :</p>
<!--
```text
error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable
 -- > error.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- use `&mut String` here to make mutable
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ cannot borrow as mutable
```
-->
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*texte` as mutable
 --&gt; error.rs:8:5
  |
7 | fn changer(texte: &amp;String) {
  |                   ------- use `&amp;mut String` here to make mutable
8 |     texte.push_str(&quot;, world&quot;);
  |     ^^^^^ cannot borrow as mutable
</code></pre>
<!--
Just as variables are immutable by default, so are references. We’re not
allowed to modify something we have a reference to.
-->
<p>Comme les variables sont immuables par défaut, les références le sont aussi.
Nous ne sommes pas autorisés à modifier une chose quand nous avons une référence
vers elle.</p>
<!--
### Mutable References
-->
<h3><a class="header" href="#les-références-mutables" id="les-références-mutables">Les références mutables</a></h3>
<!--
We can fix the error in the code from Listing 4-6 with just a small tweak:
-->
<p>Nous pouvons résoudre l'erreur du code de l'encart 4-6 avec une petite
modification :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    changer(&amp;mut s);
}

fn changer(texte: &amp;mut String) {
    texte.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<!--
First, we had to change `s` to be `mut`. Then we had to create a mutable
reference with `&mut s` and accept a mutable reference with `some_string: &mut
String`.
-->
<p>D'abord, nous avons dû préciser que <code>s</code> est <code>mut</code>. Ensuite, nous avons dû
créer une référence mutable avec <code>&amp;mut s</code> et accepter de prendre une référence
mutable avec <code>texte: &amp;mut String</code>.</p>
<!--
But mutable references have one big restriction: you can have only one mutable
reference to a particular piece of data in a particular scope. This code will
fail:
-->
<p>Mais les références mutables ont une grosse contrainte : vous ne pouvez avoir
qu'une seule référence mutable pour chaque donnée dans chaque portée. Le code
suivant va échouer :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
```
-->
<pre><code class="language-rust ignore does_not_compile">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
</code></pre>
<!--
Here’s the error:
-->
<p>Voici l'erreur :</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 -- &gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here
</code></pre>
<!--
This restriction allows for mutation but in a very controlled fashion. It’s
something that new Rustaceans struggle with, because most languages let you
mutate whenever you’d like.
-->
<p>Cette contrainte autorise les mutations, mais de manière très contrôlée. C'est
quelque chose que les nouveaux Rustacés ont du mal à surmonter, car la plupart
des langages vous permettent de modifier les données quand vous le voulez.</p>
<!--
The benefit of having this restriction is that Rust can prevent data races at
compile time. A *data race* is similar to a race condition and happens when
these three behaviors occur:
-->
<p>L'avantage d'avoir cette contrainte est que Rust peut empêcher les accès
concurrents au moment de la compilation. Un <em>accès concurrent</em> est une situation
de concurrence qui se produit lorsque ces trois facteurs se combinent :</p>
<!--
* Two or more pointers access the same data at the same time.
* At least one of the pointers is being used to write to the data.
* There’s no mechanism being used to synchronize access to the data.
-->
<ul>
<li>Deux pointeurs ou plus accèdent à la même donnée au même moment.</li>
<li>Au moins un des pointeurs est utilisé pour écrire dans cette donnée.</li>
<li>On n'utilise aucun mécanisme pour synchroniser l'accès aux données.</li>
</ul>
<!--
Data races cause undefined behavior and can be difficult to diagnose and fix
when you’re trying to track them down at runtime; Rust prevents this problem
from happening because it won’t even compile code with data races!
-->
<p>L'accès concurrent provoque des comportements indéfinis et rend difficile le
diagnostic et la résolution de problèmes lorsque vous essayez de les reproduire
au moment de l'exécution ; Rust évite ce problème parce qu'il ne va pas compiler
du code avec des accès concurrents !</p>
<!--
As always, we can use curly brackets to create a new scope, allowing for
multiple mutable references, just not *simultaneous* ones:
-->
<p>Comme d'habitude, nous pouvons utiliser des accolades pour créer une nouvelle
portée, pour nous permettre d'avoir plusieurs références mutables, mais pas
<em>en même temps</em> :</p>
<!--
```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;

} // r1 goes out of scope here, so we can make a new reference with no problems.

let r2 = &mut s;
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1 sort de la portée ici, donc nous pouvons créer une nouvelle référence
  // sans problèmes.

let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<!--
A similar rule exists for combining mutable and immutable references. This code
results in an error:
-->
<p>Une règle similaire existe pour combiner les références immuables et mutables.
Ce code va mener à une erreur :</p>
<!--
```rust,ignore,does_not_compile
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
let r3 = &mut s; // BIG PROBLEM

println!("{}, {}, and {}", r1, r2, r3);
```
-->
<pre><code class="language-rust ignore does_not_compile">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // sans problème
let r2 = &amp;s; // sans problème
let r3 = &amp;mut s; // GROS PROBLEME

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
</code></pre>
<!--
Here’s the error:
-->
<p>Voici l'erreur :</p>
<!--
```text
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 -- > src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here
```
-->
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 -- &gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // sans problème
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // sans problème
6 |     let r3 = &amp;mut s; // GROS PROBLEME
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here
</code></pre>
<!--
Whew! We *also* cannot have a mutable reference while we have an immutable one.
Users of an immutable reference don’t expect the values to suddenly change out
from under them! However, multiple immutable references are okay because no one
who is just reading the data has the ability to affect anyone else’s reading of
the data.
-->
<p>Ouah ! Nous ne pouvons pas <em>non plus</em> avoir une référence mutable pendant que
nous en avons une autre immuable. Les utilisateurs d'une référence immuable ne
s'attendent pas à ce que sa valeur change soudainement ! Cependant,
l'utilisation de plusieurs références immuables ne pose pas de problème, car
simplement lire une donnée ne va pas affecter la lecture de la donnée par les
autres.</p>
<!--
Note that a reference’s scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references occurs before the
mutable reference is introduced:
-->
<p>Notez bien que la portée d'une référence commence dès qu'elle est introduite et
se poursuit jusqu'au dernier endroit où cette référence est utilisée. Par
exemple, le code suivant va se compiler car la dernière utilisation de la
référence immuable est située avant l'introduction de la référence mutable :</p>
<!-- This example is being ignored because there's a bug in rustdoc making the
edition2018 not work. The bug is currently fixed in nightly, so when we update
the book to >= 1.35, `ignore` can be removed from this example. -->
<!--
```rust,edition2018,ignore
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
println!("{} and {}", r1, r2);
// r1 and r2 are no longer used after this point

let r3 = &mut s; // no problem
println!("{}", r3);
```
-->
<pre><code class="language-rust edition2018 ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // sans problème
let r2 = &amp;s; // sans problème
println!(&quot;{} et {}&quot;, r1, r2);
// r1 et r2 ne sont plus utilisés à partir d'ici

let r3 = &amp;mut s; // sans problème
println!(&quot;{}&quot;, r3);
</code></pre>
<!--
The scopes of the immutable references `r1` and `r2` end after the `println!`
where they are last used, which is before the mutable reference `r3` is
created. These scopes don’t overlap, so this code is allowed.
-->
<p>Les portées des références immuables <code>r1</code> et <code>r2</code> se terminent après le
<code>println!</code> où elles sont utilisées pour la dernière fois, c'est-à-dire avant que
la référence mutable <code>r3</code> soit créée. Ces portées ne se chevauchent pas, donc ce
code est autorisé.</p>
<!--
Even though borrowing errors may be frustrating at times, remember that it’s
the Rust compiler pointing out a potential bug early (at compile time rather
than at runtime) and showing you exactly where the problem is. Then you don’t
have to track down why your data isn’t what you thought it was.
-->
<p>Même si ces erreurs d'emprunt peuvent parfois être frustrantes, n'oubliez pas
que le compilateur de Rust nous signale un bogue potentiel en avance (au moment
de la compilation plutôt que l'exécution) et vous montre où se situe exactement
le problème. Ainsi, vous n'avez pas à chercher pourquoi vos données ne
correspondent pas à ce que vous pensiez qu'elles devraient être.</p>
<!--
### Dangling References
-->
<h3><a class="header" href="#les-références-pendouillantes" id="les-références-pendouillantes">Les références pendouillantes</a></h3>
<!--
In languages with pointers, it’s easy to erroneously create a *dangling
pointer*, a pointer that references a location in memory that may have been
given to someone else, by freeing some memory while preserving a pointer to
that memory. In Rust, by contrast, the compiler guarantees that references will
never be dangling references: if you have a reference to some data, the
compiler will ensure that the data will not go out of scope before the
reference to the data does.
-->
<p>Avec les langages qui utilisent les pointeurs, il est facile de créer par erreur
un <em>pointeur pendouillant</em> (<em>dangling pointer</em>), qui est un pointeur qui pointe
vers un emplacement mémoire qui a été donné à quelqu'un d'autre, en libérant de
la mémoire tout en conservant un pointeur vers cette mémoire. En revanche, avec
Rust, le compilateur garantit que les références ne seront jamais des références
pendouillantes : si nous avons une référence vers une donnée, le compilateur va
s'assurer que cette donnée ne va pas sortir de la portée avant que la référence
vers cette donnée en soit elle-même sortie.</p>
<!--
Let’s try to create a dangling reference, which Rust will prevent with a
compile-time error:
-->
<p>Essayons de créer une référence pendouillante, ce que Rust va empêcher avec une
erreur au moment de la compilation :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_vers_rien = pendouille();
}

fn pendouille() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<!--
Here’s the error:
-->
<p>Voici l'erreur :</p>
<!--
```text
error[E0106]: missing lifetime specifier
 -- > main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
```
-->
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; main.rs:5:16
  |
5 | fn pendouille() -&gt; &amp;String {
  |                    ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<!--
This error message refers to a feature we haven’t covered yet: lifetimes. We’ll
discuss lifetimes in detail in Chapter 10. But, if you disregard the parts
about lifetimes, the message does contain the key to why this code is a problem:
-->
<p>Ce message d'erreur fait référence à une fonctionnalité que nous n'avons pas
encore vue : les <em>durées de vie</em>. Nous aborderons les durées de vie dans le
chapitre 10. Mais, si vous mettez de côté les parties qui parlent de durées de
vie, le message explique pourquoi le code pose problème :</p>
<!--
```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
```
-->
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<p>Ce qui peut se traduire par :</p>
<pre><code class="language-text">Le type de retour de cette fonction contient une valeur empruntée, mais il n'y a
plus aucune valeur qui peut être empruntée.
</code></pre>
<!--
Let’s take a closer look at exactly what’s happening at each stage of our
`dangle` code:
-->
<p>Regardons de plus près ce qui se passe exactement à chaque étape de notre code
de <code>pendouille</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```
-->
<pre><code class="language-rust ignore does_not_compile">fn pendouille() -&gt; &amp;String { // pendouille retourne une référence vers une String

    let s = String::from(&quot;hello&quot;); // s est une nouvelle String

    &amp;s // nous retournons une référence vers la String, s
} // Ici, s sort de la portée, et est libéré. Sa mémoire disparaît.
  // Attention, danger !
</code></pre>
<!--
Because `s` is created inside `dangle`, when the code of `dangle` is finished,
`s` will be deallocated. But we tried to return a reference to it. That means
this reference would be pointing to an invalid `String`. That’s no good! Rust
won’t let us do this.
-->
<p>Comme <code>s</code> est créé dans <code>pendouille</code>, lorsque le code de <code>pendouille</code> est
terminé, la variable <code>s</code> sera désallouée. Mais nous avons essayé de retourner
une référence vers elle. Cela veut dire que cette référence va pointer vers une
<code>String</code> invalide. Ce n'est pas bon ! Rust ne nous laissera pas faire cela.</p>
<!--
The solution here is to return the `String` directly:
-->
<p>Ici la solution est de renvoyer la <code>String</code> directement :</p>
<!--
```rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn ne_pendouille_pas() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
<span class="boring">}
</span></code></pre></pre>
<!--
This works without any problems. Ownership is moved out, and nothing is
deallocated.
-->
<p>Cela fonctionne sans problème. La possession est transférée à la valeur de
retour de la fonction, et rien n'est désalloué.</p>
<!--
### The Rules of References
-->
<h3><a class="header" href="#les-règles-de-référencement" id="les-règles-de-référencement">Les règles de référencement</a></h3>
<!--
Let’s recap what we’ve discussed about references:
-->
<p>Récapitulons ce que nous avons vu à propos des références :</p>
<!--
* At any given time, you can have *either* one mutable reference *or* any
  number of immutable references.
* References must always be valid.
-->
<ul>
<li>À un instant donné, vous pouvez avoir <em>soit</em> une référence mutable, <em>soit</em> un
nombre quelconque de références immuables.</li>
<li>Les références doivent toujours être en vigueur.</li>
</ul>
<!--
Next, we’ll look at a different kind of reference: slices.
-->
<p>Ensuite, nous aborderons un autre type de référence : les <em>slices</em>.</p>
<!--
## The Slice Type
-->
<h2><a class="header" href="#le-type-slice" id="le-type-slice">Le type slice</a></h2>
<!--
Another data type that does not have ownership is the *slice*. Slices let you
reference a contiguous sequence of elements in a collection rather than the
whole collection.
-->
<p>Un autre type de donnée qui ne prend pas possession est la <em>slice</em>. Une slice
vous permet d'obtenir une référence vers une séquence continue d'éléments d'une
collection plutôt que toute la collection.</p>
<!--
Here’s a small programming problem: write a function that takes a string and
returns the first word it finds in that string. If the function doesn’t find a
space in the string, the whole string must be one word, so the entire string
should be returned.
-->
<p>Voici un petit problème de programmation : écrire une fonction qui prend une
chaîne de caractères et retourne le premier mot qu'elle trouve dans cette
chaîne. Si la fonction ne trouve pas d'espace dans la chaîne, cela veut dire
que la chaîne est en un seul mot, donc la chaîne en entier doit être retournée.</p>
<!--
Let’s think about the signature of this function:
-->
<p>Imaginons la signature de cette fonction :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> ?
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; ?
</code></pre>
<!--
This function, `first_word`, has a `&String` as a parameter. We don’t want
ownership, so this is fine. But what should we return? We don’t really have a
way to talk about *part* of a string. However, we could return the index of the
end of the word. Let’s try that, as shown in Listing 4-7.
-->
<p>Cette fonction, <code>premier_mot</code>, prend un <code>&amp;String</code> comme paramètre. Nous ne
voulons pas en prendre possession, donc c'est ce qu'il nous faut. Mais que
devons-nous retourner ? Nous n'avons aucun moyen de désigner une <em>partie</em>
d'une chaîne de caractères. Cependant, nous pouvons retourner l'indice de la
fin du mot. Essayons cela, dans l'encart 4-7 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn premier_mot(s: &amp;String) -&gt; usize {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-7: The `first_word` function that returns a
byte index value into the `String` parameter</span>
-->
<p><span class="caption">Encart 4-7 : La fonction <code>premier_mot</code> qui retourne
l'indice d'un octet provenant du paramètre <code>String</code></span></p>
<!--
Because we need to go through the `String` element by element and check whether
a value is a space, we’ll convert our `String` to an array of bytes using the
`as_bytes` method:
-->
<p>Comme nous avons besoin de parcourir la <code>String</code> élément par élément et de
vérifier si la valeur est une espace, nous convertissons notre <code>String</code> en un
tableau d'octets en utilisant la méthode <code>as_bytes</code> :</p>
<!--
```rust,ignore
let bytes = s.as_bytes();
```
-->
<pre><code class="language-rust ignore">let octets = s.as_bytes();
</code></pre>
<!--
Next, we create an iterator over the array of bytes using the `iter` method:
-->
<p>Ensuite, nous créons un itérateur sur le tableau d'octets en utilisant la
méthode <code>iter</code> :</p>
<!--
```rust,ignore
for (i, &item) in bytes.iter().enumerate() {
```
-->
<pre><code class="language-rust ignore">for (i, &amp;element) in octets.iter().enumerate() {
</code></pre>
<!--
We’ll discuss iterators in more detail in Chapter 13. For now, know that `iter`
is a method that returns each element in a collection and that `enumerate`
wraps the result of `iter` and returns each element as part of a tuple instead.
The first element of the tuple returned from `enumerate` is the index, and the
second element is a reference to the element. This is a bit more convenient
than calculating the index ourselves.
-->
<p>Nous aborderons plus en détail les itérateurs dans le chapitre 13. Pour le
moment, sachez que <code>iter</code> est une méthode qui retourne chaque élément d'une
collection, et que <code>enumerate</code> transforme le résultat de <code>iter</code> pour retourner
plutôt chaque élément comme un tuple. Le premier élément du tuple retourné par
<code>enumerate</code> est l'indice, et le second élément est une référence vers l'élément.
C'est un peu plus pratique que de calculer les indices par nous-mêmes.</p>
<!--
Because the `enumerate` method returns a tuple, we can use patterns to
destructure that tuple, just like everywhere else in Rust. So in the `for`
loop, we specify a pattern that has `i` for the index in the tuple and `&item`
for the single byte in the tuple. Because we get a reference to the element
from `.iter().enumerate()`, we use `&` in the pattern.
-->
<p>Comme la méthode <code>enumerate</code> retourne un tuple, nous pouvons utiliser des motifs
pour déstructurer ce tuple, comme nous pourrions le faire n'importe où avec
Rust. Donc dans la boucle <code>for</code>, nous précisons un motif qui indique que nous
définissons <code>i</code> pour l'indice au sein du tuple et <code>&amp;element</code> pour l'octet dans
le tuple. Comme nous obtenons une référence vers l'élément avec
<code>.iter().enumerate()</code>, nous utilisons <code>&amp;</code> dans le motif.</p>
<!--
Inside the `for` loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using `s.len()`:
-->
<p>Au sein de la boucle <code>for</code>, nous recherchons l'octet qui représente l'espace en
utilisant la syntaxe de littéral d'octet. Si nous trouvons une espace, nous
retournons sa position. Sinon, nous retournons la taille de la chaîne en
utilisant <code>s.len()</code> :</p>
<!--
```rust,ignore
    if item == b' ' {
        return i;
    }
}

s.len()
```
-->
<pre><code class="language-rust ignore">    if element == b' ' {
        return i;
    }
}

s.len()
</code></pre>
<!--
We now have a way to find out the index of the end of the first word in the
string, but there’s a problem. We’re returning a `usize` on its own, but it’s
only a meaningful number in the context of the `&String`. In other words,
because it’s a separate value from the `String`, there’s no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the `first_word` function from Listing 4-7.
-->
<p>Nous avons maintenant une façon de trouver l'indice de la fin du premier mot
dans la chaîne de caractères, mais il y a un problème. Nous retournons un
<code>usize</code> tout seul, mais il n'a du sens que lorsqu'il est lié au <code>&amp;String</code>.
Autrement dit, comme il a une valeur séparée de la <code>String</code>, il n'y a pas de
garantie qu'il restera toujours valide dans le futur. Imaginons le programme
dans l'encart 4-8 qui utilise la fonction <code>premier_mot</code> de l'encart 4-7 :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
#
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```
-->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;String) -&gt; usize {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s); // la variable mot aura 5 comme valeur.

    s.clear(); // ceci vide la String, elle vaut maintenant &quot;&quot;.

    // mot a toujours la valeur 5 ici, mais il n'y a plus de chaîne qui donne
    // du sens à la valeur 5. mot est maintenant complètement invalide !
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-8: Storing the result from calling the
`first_word` function and then changing the `String` contents</span>
-->
<p><span class="caption">Encart 4-8 : On stocke le résultat de l'appel à la
fonction <code>premier_mot</code> et ensuite on change le contenu de la <code>String</code></span></p>
<!--
This program compiles without any errors and would also do so if we used `word`
after calling `s.clear()`. Because `word` isn’t connected to the state of `s`
at all, `word` still contains the value `5`. We could use that value `5` with
the variable `s` to try to extract the first word out, but this would be a bug
because the contents of `s` have changed since we saved `5` in `word`.
-->
<p>Ce programme se compile sans aucune erreur et le ferait toujours si nous
utilisions <code>mot</code> après avoir appelé <code>s.clear()</code>. Comme <code>mot</code> n'est pas du tout
lié à <code>s</code>, <code>mot</code> contient toujours la valeur <code>5</code>. Nous pourrions utiliser cette
valeur <code>5</code> avec la variable <code>s</code> pour essayer d'en extraire le premier mot, mais
cela serait un bogue, car le contenu de <code>s</code> a changé depuis que nous avons
enregistré <code>5</code> dans <code>mot</code>.</p>
<!--
Having to worry about the index in `word` getting out of sync with the data in
`s` is tedious and error prone! Managing these indices is even more brittle if
we write a `second_word` function. Its signature would have to look like this:
-->
<p>Se préoccuper en permanence que l'indice présent dans <code>mot</code> ne soit plus
synchronisé avec les données présentes dans <code>s</code> est fastidieux et source
d'erreur ! La gestion de ces indices est encore plus risquée si nous écrivons
une fonction <code>second_mot</code>. Sa signature ressemblerait à ceci :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<!--
Now we’re tracking a starting *and* an ending index, and we have even more
values that were calculated from data in a particular state but aren’t tied to
that state at all. We now have three unrelated variables floating around that
need to be kept in sync.
-->
<p>Maintenant, nous avons un indice de début <em>et</em> un indice de fin, donc nous avons
encore plus de valeurs qui sont calculées à partir d'une donnée dans un état
donné, mais qui ne sont pas liées du tout à l'état de cette donnée. Nous avons
maintenant trois variables isolées qui ont besoin d'être maintenues à jour.</p>
<!--
Luckily, Rust has a solution to this problem: string slices.
-->
<p>Heureusement, Rust a une solution pour ce problème : les <em>slices</em> de chaînes de
caractères.</p>
<!--
### String Slices
-->
<h3><a class="header" href="#les-slices-de-chaînes-de-caractères" id="les-slices-de-chaînes-de-caractères">Les slices de chaînes de caractères</a></h3>
<!--
A *string slice* is a reference to part of a `String`, and it looks like this:
-->
<p>Une <em>slice de chaîne de caractères</em> (ou <em>slice de chaîne</em>) est une référence à
une partie d'une <code>String</code>, et ressemble à ceci :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<!--
This is similar to taking a reference to the whole `String` but with the extra
`[0..5]` bit. Rather than a reference to the entire `String`, it’s a reference
to a portion of the `String`.
-->
<p>Cela ressemble à une référence pour toute la <code>String</code>, mais avec la partie
<code>[0..5]</code> en plus. Plutôt que d'être une référence vers toute la <code>String</code>, c'est
une référence vers une partie de la <code>String</code>.</p>
<!-- markdownlint-disable -->
<!--
We can create slices using a range within brackets by specifying
`[starting_index..ending_index]`, where `starting_index` is the first position
in the slice and `ending_index` is one more than the last position in the
slice. Internally, the slice data structure stores the starting position and
the length of the slice, which corresponds to `ending_index` minus
`starting_index`. So in the case of `let world = &s[6..11];`, `world` would be
a slice that contains a pointer to the 7th byte (counting from 1) of `s` with a length value of 5.
-->
<!-- markdownlint-enable -->
<p>Nous pouvons créer des slices en utilisant un intervalle entre crochets en
spécifiant <code>[indice_debut..indice_fin]</code>, où <code>indice_debut</code> est la position du
premier octet de la slice et <code>indice_fin</code> est la position juste après le dernier
octet de la slice. En interne, la structure de données de la slice stocke la
position de départ et la longueur de la slice, ce qui correspond à <code>indice_fin</code>
moins <code>indice_debut</code>. Donc dans le cas de <code>let world = &amp;s[6..11];</code>, <code>world</code> est
une slice qui contient un pointeur vers le septième octet (en comptant à partir
de 1) de <code>s</code> et une longueur de 5.</p>
<!--
Figure 4-6 shows this in a diagram.
-->
<p>L'illustration 4-6 montre ceci dans un schéma.</p>
<!-- markdownlint-disable -->
<!--
<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
-->
<!-- markdownlint-restore -->
<p><img alt="world contient un pointeur vers l'octet d'indice 6 de la String s et
une longueur de 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<!--
<span class="caption">Figure 4-6: String slice referring to part of a
`String`</span>
-->
<p><span class="caption">Illustration 4-6 : Une slice de chaîne qui pointe vers
une partie d'une <code>String</code></span></p>
<!--
With Rust’s `..` range syntax, if you want to start at the first index (zero),
you can drop the value before the two periods. In other words, these are equal:
-->
<p>Avec la syntaxe d'intervalle <code>..</code> de Rust, si vous voulez commencer au premier
indice (zéro), vous pouvez ne rien mettre avant les deux points. Autrement dit,
ces deux cas sont identiques :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<!--
By the same token, if your slice includes the last byte of the `String`, you
can drop the trailing number. That means these are equal:
-->
<p>De la même manière, si votre slice contient le dernier octet de la <code>String</code>,
vous pouvez ne rien mettre à la fin. Cela veut dire que ces deux cas sont
identiques :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[3..taille];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<!--
You can also drop both values to take a slice of the entire string. So these
are equal:
-->
<p>Vous pouvez aussi ne mettre aucune limite pour créer une slice de toute la
chaîne de caractères. Ces deux cas sont donc identiques :</p>
<!--
```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let taille = s.len();

let slice = &amp;s[0..taille];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: String slice range indices must occur at valid UTF-8 character
> boundaries. If you attempt to create a string slice in the middle of a
> multibyte character, your program will exit with an error. For the purposes
> of introducing string slices, we are assuming ASCII only in this section; a
> more thorough discussion of UTF-8 handling is in the [“Storing UTF-8 Encoded
> Text with Strings”][strings]<!-- ignore -- > section of Chapter 8.
-->
<blockquote>
<p>Remarque : Les indices de l'intervalle d'une slice de chaîne doivent toujours
se trouver dans les zones acceptables de séparation des caractères encodés en
UTF-8. Si vous essayez de créer une slice de chaîne qui s'arrête au milieu
d'un caractère encodé sur plusieurs octets, votre programme va se fermer avec
une erreur. Afin de simplifier l'explication des slices de chaînes, nous
utiliserons uniquement l'ASCII dans cette section ; nous verrons la gestion
d'UTF-8 dans la section <a href="ch08-02-strings.html">“Stocker du texte encodé en UTF-8 avec les chaînes de
caractères”</a><!-- ignore --> du chapitre 8.</p>
</blockquote>
<!--
With all this information in mind, let’s rewrite `first_word` to return a
slice. The type that signifies “string slice” is written as `&str`:
-->
<p>Maintenant que nous savons tout cela, essayons de réécrire <code>premier_mot</code> pour
qu'il retourne une slice. Le type pour les slices de chaînes de caractères
s'écrit <code>&amp;str</code> :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn premier_mot(s: &amp;String) -&gt; &amp;str {
    let octets = s.as_bytes();

    for (i, &amp;element) in octets.iter().enumerate() {
        if element == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}
</span></code></pre></pre>
<!--
We get the index for the end of the word in the same way as we did in Listing
4-7, by looking for the first occurrence of a space. When we find a space, we
return a string slice using the start of the string and the index of the space
as the starting and ending indices.
-->
<p>Nous récupérons l'indice de la fin du mot de la même façon que nous l'avions
fait dans l'encart 4-7, en cherchant la première occurrence d'une espace.
Lorsque nous trouvons une espace, nous retournons une slice de chaîne en
utilisant le début de la chaîne de caractères et l'indice de l'espace comme
indices de début et de fin respectivement.</p>
<!--
Now when we call `first_word`, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.
-->
<p>Désormais, quand nous appelons <code>premier_mot</code>, nous récupérons une unique valeur
qui est liée à la donnée de base. La valeur se compose d'une référence vers le
point de départ de la slice et du nombre d'éléments dans la slice.</p>
<!--
Returning a slice would also work for a `second_word` function:
-->
<p>Retourner une slice fonctionnerait aussi pour une fonction <code>second_mot</code> :</p>
<!--
```rust,ignore
fn second_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn second_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
We now have a straightforward API that’s much harder to mess up, because the
compiler will ensure the references into the `String` remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didn’t show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of `first_word` will throw a
compile-time error:
-->
<p>Nous avons maintenant une API simple qui est bien plus difficile à mal utiliser,
puisque le compilateur va s'assurer que les références dans la <code>String</code> seront
toujours en vigueur. Vous souvenez-vous du bogue du programme de l'encart 4-8,
lorsque nous avions un indice vers la fin du premier mot mais qu'ensuite nous
avions vidé la chaîne de caractères et que notre indice n'était plus valide ? Ce
code était logiquement incorrect, mais ne montrait pas immédiatement une erreur.
Les problèmes apparaîtront plus tard si nous essayons d'utiliser l'indice du
premier mot avec une chaîne de caractères qui a été vidée. Les slices rendent ce
bogue impossible et nous signalent bien plus tôt que nous avons un problème avec
notre code. Utiliser la version avec la slice de <code>premier_mot</code> va causer une
erreur de compilation :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let mot = premier_mot(&amp;s);

    s.clear(); // Erreur !

    println!(&quot;Le premier mot est : {}&quot;, mot);
}
</code></pre>
<!--
Here’s the compiler error:
-->
<p>Voici l'erreur du compilateur :</p>
<!--
```text
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  -- > src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here
```
-->
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let mot = premier_mot(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // Erreur !
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!(&quot;Le premier mot est : {}&quot;, mot);
   |                                         --- immutable borrow later used here
</code></pre>
<!--
Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because `clear` needs to
truncate the `String`, it needs to get a mutable reference. Rust disallows
this, and compilation fails. Not only has Rust made our API easier to use, but
it has also eliminated an entire class of errors at compile time!
-->
<p>Rappelons-nous que d'après les règles d'emprunt, si nous avons une référence
immuable vers quelque chose, nous ne pouvons pas avoir une référence mutable
en même temps. Étant donné que <code>clear</code> a besoin de modifier la <code>String</code>, il a
besoin d'une référence mutable. Rust interdit cette situation, et la compilation
échoue. Non seulement Rust a simplifié l'utilisation de notre API, mais il a
aussi éliminé une catégorie entière d'erreurs au moment de la compilation !</p>
<!--
#### String Literals Are Slices
-->
<h4><a class="header" href="#les-littéraux-de-chaîne-de-caractères-sont-aussi-des-slices" id="les-littéraux-de-chaîne-de-caractères-sont-aussi-des-slices">Les littéraux de chaîne de caractères sont aussi des slices</a></h4>
<!--
Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:
-->
<p>Rappelez-vous lorsque nous avons appris que les littéraux de chaîne de
caractères étaient enregistrés dans le binaire. Maintenant que nous connaissons
les slices, nous pouvons désormais comprendre les littéraux de chaîne.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `s` here is `&str`: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; `&str` is an
immutable reference.
-->
<p>Ici, le type de <code>s</code> est un <code>&amp;str</code> : c'est une slice qui pointe vers un endroit
précis du binaire. C'est aussi la raison pour laquelle les littéraux de chaîne
sont immuables ; <code>&amp;str</code> est une référence immuable.</p>
<!--
#### String Slices as Parameters
-->
<h4><a class="header" href="#les-slices-de-chaînes-de-caractères-en-paramètres" id="les-slices-de-chaînes-de-caractères-en-paramètres">Les slices de chaînes de caractères en paramètres</a></h4>
<!--
Knowing that you can take slices of literals and `String` values leads us to
one more improvement on `first_word`, and that’s its signature:
-->
<p>Savoir que l'on peut utiliser des slices de littéraux et de <code>String</code> nous incite
à apporter une petite amélioration à <code>premier_mot</code>, dont voici la signature :</p>
<!--
```rust,ignore
fn first_word(s: &String) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both `&String` values
and `&str` values.
-->
<p>Un Rustacé plus expérimenté écrirait plutôt la signature de l'encart 4-9, car
cela nous permet d'utiliser la même fonction sur les <code>&amp;String</code> et aussi les
<code>&amp;str</code> :</p>
<!--
```rust,ignore
fn first_word(s: &str) -> &str {
```
-->
<pre><code class="language-rust ignore">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
<span class="caption">Listing 4-9: Improving the `first_word` function by using
a string slice for the type of the `s` parameter</span>
-->
<p><span class="caption">Encart 4-9 : Amélioration de la fonction <code>premier_mot</code> en
utilisant une slice de chaîne de caractères comme type du paramètre <code>s</code></span></p>
<!--
If we have a string slice, we can pass that directly. If we have a `String`, we
can pass a slice of the entire `String`. Defining a function to take a string
slice instead of a reference to a `String` makes our API more general and useful
without losing any functionality:
-->
<p>Si nous avons une slice de chaîne, nous pouvons la passer en argument
directement. Si nous avons une <code>String</code>, nous pouvons envoyer une slice de toute
la <code>String</code>. Définir une fonction qui prend une slice de chaîne plutôt qu'une
référence à une <code>String</code> rend notre API plus générique et plus utile sans perdre
aucune fonctionnalité :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
#
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
#
#     &s[..]
# }
fn main() {
    let my_string = String::from("hello world");

    // first_word works on slices of `String`s
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_word works on slices of string literals
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
```
-->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn premier_mot(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let octets = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;element) in octets.iter().enumerate() {
</span><span class="boring">        if element == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span>fn main() {
    let ma_string = String::from(&quot;hello world&quot;);

    // premier_mot fonctionne avec les slices de `String`
    let mot = premier_mot(&amp;ma_string[..]);

    let mon_litteral_de_chaine = &quot;hello world&quot;;

    // premier_mot fonctionne avec les slices de littéraux de chaîne
    let mot = premier_mot(&amp;mon_litteral_de_chaine[..]);

    // Comme les littéraux de chaîne *sont* déjà des slices de chaînes,
    // cela fonctionne aussi, sans la syntaxe de slice !
    let mot = premier_mot(mon_litteral_de_chaine);
}
</code></pre></pre>
<!--
### Other Slices
-->
<h3><a class="header" href="#les-autres-slices" id="les-autres-slices">Les autres slices</a></h3>
<!--
String slices, as you might imagine, are specific to strings. But there’s a
more general slice type, too. Consider this array:
-->
<p>Les slices de chaînes de caractères, comme vous pouvez l'imaginer, sont
spécifiques aux chaînes de caractères. Mais il existe aussi un type de slice
plus générique. Imaginons ce tableau de données :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Just as we might want to refer to a part of a string, we might want to refer
to part of an array. We’d do so like this:
-->
<p>Tout comme nous pouvons nous référer à une partie d'une chaîne de caractères,
nous pouvons nous référer à une partie d'un tableau. Nous pouvons le faire comme
ceci :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<!--
This slice has the type `&[i32]`. It works the same way as string slices do, by
storing a reference to the first element and a length. You’ll use this kind of
slice for all sorts of other collections. We’ll discuss these collections in
detail when we talk about vectors in Chapter 8.
-->
<p>Cette slice est de type <code>&amp;[i32]</code>. Elle fonctionne de la même manière que les
slices de chaînes de caractères, en enregistrant une référence vers le premier
élément et une longueur. Vous utiliserez ce type de slice pour tous les autres
types de collections. Nous aborderons ces collections en détail quand nous
verrons les vecteurs au chapitre 8.</p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé-3" id="résumé-3">Résumé</a></h2>
<!--
The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you don’t have to write and debug extra code to get this control.
-->
<p>Les concepts de possession, d'emprunt et de slices garantissent la sécurité de
la mémoire dans les programmes Rust au moment de la compilation. Le langage Rust
vous donne le contrôle sur l'utilisation de la mémoire comme tous les autres
langages de programmation système, mais le fait que celui qui possède des
données nettoie automatiquement ces données quand il sort de la portée vous
permet de ne pas avoir à écrire et déboguer du code en plus pour avoir cette
fonctionnalité.</p>
<!--
Ownership affects how lots of other parts of Rust work, so we’ll talk about
these concepts further throughout the rest of the book. Let’s move on to
Chapter 5 and look at grouping pieces of data together in a `struct`.
-->
<p>La possession influe sur de nombreuses autres fonctionnalités de Rust, c'est
pourquoi nous allons encore parler de ces concepts plus loin dans le livre.
Passons maintenant au chapitre 5 et découvrons comment regrouper des données
ensemble dans une <code>struct</code>.</p>
<!--
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
-->
<!-- # Using Structs to Structure Related Data -->
<h1><a class="header" href="#utiliser-les-structures-pour-structurer-des-données-apparentées" id="utiliser-les-structures-pour-structurer-des-données-apparentées">Utiliser les structures pour structurer des données apparentées</a></h1>
<!--
A *struct*, or *structure*, is a custom data type that lets you name and
package together multiple related values that make up a meaningful group. If
you’re familiar with an object-oriented language, a *struct* is like an
object’s data attributes. In this chapter, we’ll compare and contrast tuples
with structs, demonstrate how to use structs, and discuss how to define methods
and associated functions to specify behavior associated with a struct’s data.
Structs and enums (discussed in Chapter 6) are the building blocks for creating
new types in your program’s domain to take full advantage of Rust’s compile
time type checking.
-->
<p>Une <em>struct</em>, ou <em>structure</em>, est un type de données personnalisé qui vous
permet de nommer et de rassembler plusieurs valeurs associées qui forment
un groupe cohérent.
Si vous êtes familier avec un langage orienté objet, une structure est en
quelque sorte l'ensemble des attributs d'un objet.
Dans ce chapitre, nous comparerons les tuples avec les structures, nous
montrerons comment utiliser les structures et nous aborderons la définition des
méthodes et des fonctions associées pour spécifier le comportement associé aux
données d'une structure.
Les structures et les énumérations (traitées au chapitre 6) sont les fondements
de la création de nouveaux types au sein de votre programme pour tirer
pleinement parti des vérifications de types effectuées par Rust à la
compilation.</p>
<!--
## Defining and Instantiating Structs
-->
<h2><a class="header" href="#définir-et-instancier-des-structures" id="définir-et-instancier-des-structures">Définir et instancier des structures</a></h2>
<!--
Structs are similar to tuples, which were discussed in Chapter 3. Like tuples,
the pieces of a struct can be different types. Unlike with tuples, you’ll name
each piece of data so it’s clear what the values mean. As a result of these
names, structs are more flexible than tuples: you don’t have to rely on the
order of the data to specify or access the values of an instance.
-->
<p>Les structures sont similaires aux tuples, qu'on a vus au chapitre 3. Comme pour
les tuples, les éléments d'une structure peuvent être de différents types.
Contrairement aux tuples, on doit nommer chaque élément des données afin de
clarifier le rôle de chaque valeur. Grâce à ces noms, les structures sont plus
flexibles que les tuples : on n'a pas à utiliser l'ordre des données pour
spécifier ou accéder aux valeurs d'une instance.</p>
<!--
To define a struct, we enter the keyword `struct` and name the entire struct. A
struct’s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call *fields*. For example, Listing 5-1 shows a
struct that stores information about a user account.
-->
<p>Pour définir une structure, on tape le mot-clé <code>struct</code> et on donne un nom à
toute la structure. Le nom d'une structure devrait décrire l'utilisation des
éléments des données regroupés. Ensuite, entre des accolades, on définit le nom
et le type de chaque élément des données, qu'on appelle un <em>champ</em>. Par exemple,
l'encart 5-1 montre une structure qui stocke des informations à propos d'un
compte d'utilisateur.</p>
<!--
```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Utilisateur {
    pseudo: String,
    email: String,
    nombre_de_connexions: u64,
    actif: bool,
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-1: A `User` struct definition</span>
-->
<p><span class="caption">Encart 5-1 : La définition d'une structure
<code>Utilisateur</code></span></p>
<!--
To use a struct after we’ve defined it, we create an *instance* of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing `key:
value` pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We don’t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.
-->
<p>Pour utiliser une structure après l'avoir définie, on crée une <em>instance</em> de
cette structure en indiquant des valeurs concrètes pour chacun des champs.
On crée une instance en indiquant le nom de la structure puis en ajoutant des
accolades qui contiennent des paires de <code>clé: valeur</code>, où les clés sont les noms
des champs et les valeurs sont les données que l'on souhaite stocker dans ces
champs. Nous n'avons pas à préciser les champs dans le même ordre qu'on les a
déclarés dans la structure. En d'autres termes, la définition de la structure
décrit un gabarit pour le type, et les instances remplissent ce gabarit avec des
données précises pour créer des valeurs de ce type. Par exemple, nous pouvons
déclarer un utilisateur précis comme dans l'encart 5-2.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span>let utilisateur1 = Utilisateur {
    email: String::from(&quot;quelquun@example.com&quot;),
    pseudo: String::from(&quot;pseudoquelconque123&quot;),
    actif: true,
    nombre_de_connexions: 1,
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-2: Creating an instance of the `User`
struct</span>
-->
<p><span class="caption">Encart 5-2 : Création d'une instance de la structure
<code>Utilisateur</code></span></p>
<!--
To get a specific value from a struct, we can use dot notation. If we wanted
just this user’s email address, we could use `user1.email` wherever we wanted
to use this value. If the instance is mutable, we can change a value by using
the dot notation and assigning into a particular field. Listing 5-3 shows how
to change the value in the `email` field of a mutable `User` instance.
-->
<p>Pour obtenir une valeur spécifique depuis une structure, on utilise la notation
avec le point. Si nous voulions seulement l'adresse e-mail de cet utilisateur,
on pourrait utiliser <code>utilisateur1.email</code> partout où on voudrait utiliser cette
valeur. Si l'instance est mutable, nous pourrions changer une valeur en
utilisant la notation avec le point et assigner une valeur à ce champ en
particulier. L'encart 5-3 montre comment changer la valeur du champ <code>email</code>
d'une instance mutable de <code>Utilisateur</code>.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span>let mut utilisateur1 = Utilisateur {
    email: String::from(&quot;quelquun@example.com&quot;),
    pseudo: String::from(&quot;pseudoquelconque123&quot;),
    actif: true,
    nombre_de_connexions: 1,
};

utilisateur1.email = String::from(&quot;unautremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-3: Changing the value in the `email` field of a
`User` instance</span>
-->
<p><span class="caption">Encart 5-3 : Changement de la valeur du champ <code>email</code>
d'une instance de <code>Utilisateur</code></span></p>
<!--
Note that the entire instance must be mutable; Rust doesn’t allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.
-->
<p>À noter que l'instance tout entière doit être mutable ; Rust ne nous permet pas
de marquer seulement certains champs comme mutables. Comme pour toute
expression, nous pouvons construire une nouvelle instance de la structure comme
dernière expression du corps d'une fonction pour retourner implicitement cette
nouvelle instance.</p>
<!--
Listing 5-4 shows a `build_user` function that returns a `User` instance with
the given email and username. The `active` field gets the value of `true`, and
the `sign_in_count` gets a value of `1`.
-->
<p>L'encart 5-4 montre une fonction <code>creer_utilisateur</code> qui retourne une instance
de <code>Utilisateur</code> avec l'adresse e-mail et le pseudo fournis. Le champ <code>actif</code>
prend la valeur <code>true</code> et le <code>nombre_de_connexions</code> prend la valeur <code>1</code>.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email: email,
        pseudo: pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-4: A `build_user` function that takes an email
and username and returns a `User` instance</span>
-->
<p><span class="caption">Encart 5-4 : Une fonction <code>creer_utilisateur</code> qui prend
en entrée une adresse e-mail et un pseudo et retourne une instance de
<code>Utilisateur</code></span></p>
<!--
It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the `email` and `username` field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, there’s a convenient shorthand!
-->
<p>Il est logique de nommer les paramètres de fonction avec le même nom que les
champs de la structure, mais devoir répéter les noms de variables et de champs
<code>email</code> et <code>pseudo</code> est un peu pénible. Si la structure avait plus de champs,
répéter chaque nom serait encore plus fatigant. Heureusement, il existe un
raccourci pratique !</p>
<!--
### Using the Field Init Shorthand when Variables and Fields Have the Same Name
-->
<h3><a class="header" href="#utiliser-le-raccourci-dinitialisation-des-champs-lorsque-les-variables-et-les-champs-ont-le-même-nom" id="utiliser-le-raccourci-dinitialisation-des-champs-lorsque-les-variables-et-les-champs-ont-le-même-nom">Utiliser le raccourci d'initialisation des champs lorsque les variables et les champs ont le même nom</a></h3>
<!--
Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the *field init shorthand* syntax to rewrite
`build_user` so that it behaves exactly the same but doesn’t have the
repetition of `email` and `username`, as shown in Listing 5-5.
-->
<p>Puisque les noms des paramètres et les noms de champs de la structure sont
exactement les mêmes dans l'encart 5-4, on peut utiliser la syntaxe de
<em>raccourci d'initialisation des champs</em> pour réécrire <code>creer_utilisateur</code> de
sorte qu'elle se comporte exactement de la même façon sans avoir à répéter
<code>email</code> et <code>pseudo</code>, comme le montre l'encart 5-5.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn creer_utilisateur(email: String, pseudo: String) -&gt; Utilisateur {
    Utilisateur {
        email,
        pseudo,
        actif: true,
        nombre_de_connexions: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-5: A `build_user` function that uses field init
shorthand because the `email` and `username` parameters have the same name as
struct fields</span>
-->
<p><span class="caption">Encart 5-5 : Une fonction <code>creer_utilisateur</code> qui utilise
le raccourci d'initialisation des champs parce que les paramètres <code>email</code> et
<code>pseudo</code> ont le même nom que les champs de la structure</span></p>
<!--
Here, we’re creating a new instance of the `User` struct, which has a field
named `email`. We want to set the `email` field’s value to the value in the
`email` parameter of the `build_user` function. Because the `email` field and
the `email` parameter have the same name, we only need to write `email` rather
than `email: email`.
-->
<p>Ici, on crée une nouvelle instance de la structure <code>Utilisateur</code>, qui possède
un champ nommé <code>email</code>. On veut donner au champ <code>email</code> la valeur du paramètre
<code>email</code> de la fonction <code>creer_utilisateur</code>. Comme le champ <code>email</code> et le
paramètre <code>email</code> ont le même nom, on a uniquement besoin d'écrire <code>email</code>
plutôt que <code>email: email</code>.</p>
<!--
### Creating Instances From Other Instances With Struct Update Syntax
-->
<h3><a class="header" href="#créer-des-instances-à-partir-dautres-instances-avec-la-syntaxe-de-mise-à-jour-de-structure" id="créer-des-instances-à-partir-dautres-instances-avec-la-syntaxe-de-mise-à-jour-de-structure">Créer des instances à partir d'autres instances avec la syntaxe de mise à jour de structure</a></h3>
<!--
It’s often useful to create a new instance of a struct that uses most of an old
instance’s values but changes some. You’ll do this using *struct update syntax*.
-->
<p>Il est souvent utile de créer une nouvelle instance de structure qui utilise la
plupart des valeurs d'une ancienne instance tout en en changeant certaines. On
utilisera pour cela la <em>syntaxe de mise à jour de structure</em>.</p>
<!--
First, Listing 5-6 shows how we create a new `User` instance in `user2` without
the update syntax. We set new values for `email` and `username` but otherwise
use the same values from `user1` that we created in Listing 5-2.
-->
<p>Tout d'abord, l'encart 5-6 nous montre comment créer une nouvelle instance de
<code>Utilisateur</code> dans <code>utilisateur2</code> sans la syntaxe de mise à jour de structure.
On donne de nouvelles valeurs à <code>email</code> et <code>pseudo</code> mais on utilise pour les
autres champs les mêmes valeurs que dans <code>utilisateur1</code> qu'on a créé à
l'encart 5-2.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from("someone@example.com"),
#     username: String::from("someusername123"),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let utilisateur1 = Utilisateur {
</span><span class="boring">    email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">    pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    actif: true,
</span><span class="boring">    nombre_de_connexions: 1,
</span><span class="boring">};
</span><span class="boring">
</span>let utilisateur2 = Utilisateur {
    email: String::from(&quot;quelquundautre@example.com&quot;),
    pseudo: String::from(&quot;autrepseudo567&quot;),
    actif: utilisateur1.actif,
    nombre_de_connexions: utilisateur1.nombre_de_connexions,
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-6: Creating a new `User` instance using some of
the values from `user1`</span>
-->
<p><span class="caption">Encart 5-6 : Création d'une nouvelle instance de
<code>Utilisateur</code> en utilisant certaines valeurs de <code>utilisateur1</code>.</span></p>
<!--
Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax `..` specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.
-->
<p>En utilisant la syntaxe de mise à jour de structure, on peut produire le même
résultat avec moins de code, comme le montre l'encart 5-7. La syntaxe <code>..</code>
indique que les autres champs auxquels on ne donne pas explicitement de valeur
devraient avoir la même valeur que dans l'instance précisée.</p>
<!--
```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from("someone@example.com"),
#     username: String::from("someusername123"),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Utilisateur {
</span><span class="boring">    pseudo: String,
</span><span class="boring">    email: String,
</span><span class="boring">    nombre_de_connexions: u64,
</span><span class="boring">    actif: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let utilisateur1 = Utilisateur {
</span><span class="boring">    email: String::from(&quot;quelquun@example.com&quot;),
</span><span class="boring">    pseudo: String::from(&quot;pseudoquelconque123&quot;),
</span><span class="boring">    actif: true,
</span><span class="boring">    nombre_de_connexions: 1,
</span><span class="boring">};
</span><span class="boring">
</span>let utilisateur2 = Utilisateur {
    email: String::from(&quot;quelquundautre@example.com&quot;),
    pseudo: String::from(&quot;autrepseudo567&quot;),
    ..utilisateur1
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-7: Using struct update syntax to set new
`email` and `username` values for a `User` instance but use the rest of the
values from the fields of the instance in the `user1` variable</span>
-->
<p><span class="caption">Encart 5-7 : Utilisation de la syntaxe de mise à jour de
structure pour assigner de nouvelles valeurs à <code>email</code> et <code>pseudo</code> à une
nouvelle instance de <code>Utilisateur</code> tout en utilisant les autres valeurs des
champs de l'instance de la variable <code>utilisateur1</code></span></p>
<!--
The code in Listing 5-7 also creates an instance in `user2` that has a
different value for `email` and `username` but has the same values for the
`active` and `sign_in_count` fields from `user1`.
-->
<p>Le code dans l'encart 5-7 crée aussi une instance dans <code>utilisateur2</code> qui a une
valeur différente pour <code>email</code> et <code>pseudo</code> mais qui a les mêmes valeurs pour les
champs <code>actif</code> et <code>nombre_de_connexions</code> que <code>utilisateur1</code>.</p>
<!--
### Using Tuple Structs without Named Fields to Create Different Types
-->
<h3><a class="header" href="#utilisation-de-structures-tuples-sans-champ-nommé-pour-créer-des-types-différents" id="utilisation-de-structures-tuples-sans-champ-nommé-pour-créer-des-types-différents">Utilisation de structures tuples sans champ nommé pour créer des types différents</a></h3>
<!--
You can also define structs that look similar to tuples, called *tuple
structs*. Tuple structs have the added meaning the struct name provides but
don’t have names associated with their fields; rather, they just have the types
of the fields. Tuple structs are useful when you want to give the whole tuple a
name and make the tuple be a different type from other tuples, and naming each
field as in a regular struct would be verbose or redundant.
-->
<p>On peut aussi définir des structures qui ressemblent à des tuples, appelées
<em>structures tuples</em>. La signification d'une structure tuple est donnée par son
nom. En revanche, ses champs ne sont pas nommés ; on ne précise que leurs types.
Les structures tuples servent lorsqu'on veut donner un nom à un tuple pour qu'il
ait un type différent des autres tuples, mais que nommer chaque champ comme dans
une structure classique serait trop verbeux ou redondant.</p>
<!--
To define a tuple struct, start with the `struct` keyword and the struct name
followed by the types in the tuple. For example, here are definitions and
usages of two tuple structs named `Color` and `Point`:
-->
<p>La définition d'une structure tuple commence par le mot-clé <code>struct</code> et le nom
de la structure suivis des types des champs du tuple. Par exemple, voici une
définition et une utilisation de deux structures tuples nommées <code>Couleur</code> et
<code>Point</code> :</p>
<!--
```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Couleur(i32, i32, i32);
struct Point(i32, i32, i32);

let noir = Couleur(0, 0, 0);
let origine = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<!--
Note that the `black` and `origin` values are different types, because they’re
instances of different tuple structs. Each struct you define is its own type,
even though the fields within the struct have the same types. For example, a
function that takes a parameter of type `Color` cannot take a `Point` as an
argument, even though both types are made up of three `i32` values. Otherwise,
tuple struct instances behave like tuples: you can destructure them into their
individual pieces, you can use a `.` followed by the index to access an
individual value, and so on.
-->
<p>Notez que les valeurs <code>noir</code> et <code>origine</code> sont de types différents parce que ce
sont des instances de structures tuples différentes. Chaque structure que l'on
définit constitue son propre type, même si les champs au sein de la structure
ont les mêmes types. Par exemple, une fonction qui prend un paramètre de type
<code>Couleur</code> ne peut pas prendre un argument de type <code>Point</code> à la place, bien que
ces deux types soient tous les deux constitués de trois valeurs <code>i32</code>. Mis à
part cela, les instances de stuctures tuples se comportent comme des tuples : on
peut les déstructurer en éléments individuels, on peut utiliser un <code>.</code> suivi de
l'indice pour accéder individuellement à une valeur, et ainsi de suite.</p>
<!--
### Unit-Like Structs Without Any Fields
-->
<h3><a class="header" href="#les-structures-unité-sans-champs" id="les-structures-unité-sans-champs">Les structures unité sans champs</a></h3>
<!--
You can also define structs that don’t have any fields! These are called
*unit-like structs* because they behave similarly to `()`, the unit type.
Unit-like structs can be useful in situations in which you need to implement a
trait on some type but don’t have any data that you want to store in the type
itself. We’ll discuss traits in Chapter 10.
-->
<p>On peut aussi définir des structures qui n'ont pas de champs ! Cela s'appelle
des <em>structures unité</em> parce qu'elles se comportent d'une façon analogue au type
unité, <code>()</code>. Les structures unité sont utiles lorsqu'on doit implémenter un
trait sur un type mais qu'on n'a aucune donnée à stocker dans le type en
lui-même. Nous aborderons les traits au chapitre 10.</p>
<!--
> ### Ownership of Struct Data
>
> In the `User` struct definition in Listing 5-1, we used the owned `String`
> type rather than the `&str` string slice type. This is a deliberate choice
> because we want instances of this struct to own all of its data and for that
> data to be valid for as long as the entire struct is valid.
>
> It’s possible for structs to store references to data owned by something else,
> but to do so requires the use of *lifetimes*, a Rust feature that we’ll
> discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
> is valid for as long as the struct is. Let’s say you try to store a reference
> in a struct without specifying lifetimes, like this, which won’t work:
>
> <span class="filename">Filename: src/main.rs</span>
>
> ```rust,ignore,does_not_compile
> struct User {
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
>     active: bool,
> }
>
> fn main() {
>     let user1 = User {
>         email: "someone@example.com",
>         username: "someusername123",
>         active: true,
>         sign_in_count: 1,
>     };
> }
> ```
>
>
> The compiler will complain that it needs lifetime specifiers:
>
> ```text
> error[E0106]: missing lifetime specifier
>  -- >
>   |
> 2 |     username: &str,
>   |               ^ expected lifetime parameter
>
> error[E0106]: missing lifetime specifier
>  -- >
>   |
> 3 |     email: &str,
>   |            ^ expected lifetime parameter
> ```
>
> In Chapter 10, we’ll discuss how to fix these errors so you can store
> references in structs, but for now, we’ll fix errors like these using owned
> types like `String` instead of references like `&str`.
-->
<blockquote>
<h3><a class="header" href="#la-possession-des-données-dune-structure" id="la-possession-des-données-dune-structure">La possession des données d'une structure</a></h3>
<p>Dans la définition de la structure <code>Utilisateur</code> de l'encart 5-1, nous avions
utilisé le type possédé <code>String</code> plutôt que le type de <em>slice</em> de chaîne de
caractères <code>&amp;str</code>. Il s'agit d'un choix délibéré puisque nous voulons que les
instances de cette structure possèdent toutes leurs données et que ces données
restent valides tant que la structure tout entière est valide.</p>
<p>Il est possible pour les structures de stocker des références vers des données
possédées par autre chose, mais cela nécessiterait d'utiliser des
<em>durées de vie</em>, une fonctionnalité de Rust que nous aborderons au
chapitre 10. Les durées de vie assurent que les données référencées par une
structure restent valides tant que la structure l'est aussi. Disons que vous
essayiez de stocker une référence dans une structure sans indiquer de durées
de vie, comme ceci, ce qui ne fonctionnera pas :</p>
<p><span class="filename">Fichier : src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Utilisateur {
    pseudo: &amp;str,
    email: &amp;str,
    nombre_de_connexions: u64,
    actif: bool,
}

fn main() {
    let utilisateur1 = Utilisateur {
        email: &quot;quelquun@example.com&quot;,
        pseudo: &quot;pseudoquelconque123&quot;,
        actif: true,
        nombre_de_connexions: 1,
    };
}
</code></pre>
<p>Le compilateur réclamera l'ajout des durées de vie :</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt;
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt;
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>Au chapitre 10, nous aborderons la façon de corriger ces erreurs pour qu'on
puisse stocker des références dans des structures, mais pour le moment, nous
résoudrons les erreurs comme celles-ci en utilisant des types possédés comme
<code>String</code> plutôt que des références comme <code>&amp;str</code>.</p>
</blockquote>
<!--
## An Example Program Using Structs
-->
<h2><a class="header" href="#un-exemple-de-programme-qui-utilise-des-structures" id="un-exemple-de-programme-qui-utilise-des-structures">Un exemple de programme qui utilise des structures</a></h2>
<!--
To understand when we might want to use structs, let’s write a program that
calculates the area of a rectangle. We’ll start with single variables, and then
refactor the program until we’re using structs instead.
-->
<p>Pour comprendre dans quels cas nous voudrions utiliser des structures, écrivons
un programme qui calcule l'aire d'un rectangle. Nous commencerons avec de
simples variables, puis on remaniera le code jusqu'à utiliser des structures à
la place.</p>
<!--
Let’s make a new binary project with Cargo called *rectangles* that will take
the width and height of a rectangle specified in pixels and calculate the area
of the rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our project’s *src/main.rs*.
-->
<p>Créons un nouveau projet binaire avec Cargo nommé <em>rectangles</em> qui prendra la
largeur et la hauteur en pixels d'un rectangle et qui calculera l'aire de ce
rectangle. L'encart 5-8 montre un petit programme qui effectue cette tâche d'une
certaine manière dans le <em>src/main.rs</em> de notre projet.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier: src/main.rs</span></p>
<!--
```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let largeur1 = 30;
    let hauteur1 = 50;

    println!(
        &quot;L'aire du rectangle est de {} pixels carrés.&quot;,
        aire(largeur1, hauteur1)
    );
}

fn aire(largeur: u32, hauteur: u32) -&gt; u32 {
    largeur * hauteur
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-8: Calculating the area of a rectangle
specified by separate width and height variables</span>
-->
<p><span class="caption">Encart 5-8 : Calcul de l'aire d'un rectangle défini par
les variables distinctes <code>largeur</code> et <code>hauteur</code></span></p>
<!--
Now, run this program using `cargo run`:
-->
<p>Maintenant, lancez ce programme avec <code>cargo run</code> :</p>
<!--
```text
The area of the rectangle is 1500 square pixels.
```
-->
<pre><code class="language-text">L'aire du rectangle est de 1500 pixels carrés.
</code></pre>
<!--
Even though Listing 5-8 works and figures out the area of the rectangle by
calling the `area` function with each dimension, we can do better. The width
and the height are related to each other because together they describe one
rectangle.
-->
<p>Bien que l'encart 5-8 fonctionne et détermine l'aire du rectangle en appelant
la fonction <code>aire</code> avec chaque dimension, on peut faire mieux. La largeur et la
hauteur sont couplées entre elles car elles décrivent toutes les deux un rectangle.</p>
<!--
The issue with this code is evident in the signature of `area`:
-->
<p>Le problème de ce code se voit dans la signature de <code>aire</code> :</p>
<!--
```rust,ignore
fn area(width: u32, height: u32) -> u32 {
```
-->
<pre><code class="language-rust ignore">fn aire(largeur: u32, hauteur: u32) -&gt; u32 {
</code></pre>
<!--
The `area` function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters. The parameters are related, but that’s
not expressed anywhere in our program. It would be more readable and more
manageable to group width and height together. We’ve already discussed one way
we might do that in [“The Tuple Type”][the-tuple-type]<!−− ignore −− > section
of Chapter 3: by using tuples.
-->
<p>La fonction <code>aire</code> est censée calculer l'aire d'un rectangle, mais la fonction
que nous avons écrite a deux paramètres. Les paramètres sont liés, mais ce n'est
exprimé nulle part dans notre programme. Il serait plus lisible et plus gérable
de regrouper ensemble la largeur et la hauteur. Nous avons déjà vu dans la
section <a href="ch03-02-data-types.html#le-type-tuple">“Le type <em>tuple</em>”</a><!-- ignore --> du chapitre 3 une
façon qui nous permettrait de le faire : en utilisant des tuples.</p>
<!--
### Refactoring with Tuples
-->
<h3><a class="header" href="#remanier-le-code-avec-des-tuples" id="remanier-le-code-avec-des-tuples">Remanier le code avec des tuples</a></h3>
<!--
Listing 5-9 shows another version of our program that uses tuples.
-->
<p>L'encart 5-9 nous montre une autre version de notre programme qui utilise des
tuples.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```
-->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;L'aire du rectangle est de {} pixels carrés.&quot;,
        aire(rect1)
    );
}

fn aire(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-9: Specifying the width and height of the
rectangle with a tuple</span>
-->
<p><span class="caption">Encart 5-9 : Renseigner la largeur et la hauteur du
rectangle dans un tuple</span></p>
<!--
In one way, this program is better. Tuples let us add a bit of structure, and
we’re now passing just one argument. But in another way, this version is less
clear: tuples don’t name their elements, so our calculation has become more
confusing because we have to index into the parts of the tuple.
-->
<p>D'une certaine façon, ce programme est meilleur. Les tuples nous permettent de
structurer un peu plus et nous ne passons plus qu'un argument. Mais d'une autre
façon, cette version est moins claire : les tuples ne donnent pas de noms à
leurs éléments, donc notre calcul est devenu plus déroutant puisqu'il faut
accéder aux éléments du tuple via leur indice.</p>
<!--
It doesn’t matter if we mix up width and height for the area calculation, but
if we want to draw the rectangle on the screen, it would matter! We would have
to keep in mind that `width` is the tuple index `0` and `height` is the tuple
index `1`. If someone else worked on this code, they would have to figure this
out and keep it in mind as well. It would be easy to forget or mix up these
values and cause errors, because we haven’t conveyed the meaning of our data in
our code.
-->
<p>Ce n'est pas grave de confondre la largeur et la hauteur pour calculer l'aire,
mais si on voulait afficher le rectangle à l'écran, cela serait problématique !
Il nous faut garder à l'esprit que la <code>largeur</code> est l'élément à l'indice 0 du
tuple et que la <code>hauteur</code> est l'élément à l'indice 1. Si quelqu'un d'autre
travaillait sur ce code, il devrait le déduire et s'en souvenir aussi. Il est
facile d'oublier ou de confondre ces valeurs et par conséquent provoquer des
erreurs, parce qu'on n'a pas exprimé la signification de nos données dans notre
code.</p>
<!--
### Refactoring with Structs: Adding More Meaning
-->
<h3><a class="header" href="#remanier-avec-des-structures--donner-plus-de-sens" id="remanier-avec-des-structures--donner-plus-de-sens">Remanier avec des structures : donner plus de sens</a></h3>
<!--
We use structs to add meaning by labeling the data. We can transform the tuple
we’re using into a data type with a name for the whole as well as names for the
parts, as shown in Listing 5-10.
-->
<p>On utilise des structures pour rendre les données plus expressives en leur
donnant des noms. On peut transformer le tuple que nous avons utilisé en un type
de donnée nommé dont ses éléments sont aussi nommés, comme le montre l'encart
5-10.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```
-->
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carrés.&quot;,
        aire(&amp;rect1)
    );
}

fn aire(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.largeur * rectangle.hauteur
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-10: Defining a `Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-10 : Définition d'une structure
<code>Rectangle</code></span></p>
<!--
Here we’ve defined a struct and named it `Rectangle`. Inside the curly
brackets, we defined the fields as `width` and `height`, both of which have
type `u32`. Then in `main`, we created a particular instance of `Rectangle`
that has a width of 30 and a height of 50.
-->
<p>Ici, on a défini une structure et on l'a appelée <code>Rectangle</code>. Entre les
accolades, on a défini les champs <code>largeur</code> et <code>hauteur</code>, tous deux du type
<code>u32</code>. Puis dans <code>main</code>, on crée une instance de <code>Rectangle</code> de largeur 30 et de
hauteur 50.</p>
<!--
Our `area` function is now defined with one parameter, which we’ve named
`rectangle`, whose type is an immutable borrow of a struct `Rectangle`
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, `main` retains its ownership and can continue
using `rect1`, which is the reason we use the `&` in the function signature and
where we call the function.
-->
<p>Notre fonction <code>aire</code> est désormais définie avec un unique paramètre, nommé
<code>rectangle</code>, et dont le type est une référence immuable vers une instance de la
structure <code>Rectangle</code>. Comme mentionné au chapitre 4, on préfère emprunter la
structure au lieu d'en prendre possession. Ainsi, elle reste en possession de
<code>main</code> qui peut continuer à utiliser <code>rect1</code> ; c'est pourquoi on utilise le <code>&amp;</code>
dans la signature de la fonction ainsi que dans l'appel de fonction.</p>
<!--
The `area` function accesses the `width` and `height` fields of the `Rectangle`
instance. Our function signature for `area` now says exactly what we mean:
calculate the area of `Rectangle`, using its `width` and `height` fields. This
conveys that the width and height are related to each other, and it gives
descriptive names to the values rather than using the tuple index values of `0`
and `1`. This is a win for clarity.
-->
<p>La fonction <code>aire</code> accède aux champs <code>largeur</code> et <code>hauteur</code> de l'instance de
<code>Rectangle</code>. Notre signature de fonction pour <code>aire</code> est enfin explicite :
calculer l'aire d'un <code>Rectangle</code> en utilisant ses champs <code>largeur</code> et <code>hauteur</code>.
Cela explique que la largeur et la hauteur sont liées entre elles, et cela donne
des noms descriptifs aux valeurs plutôt que d'utiliser les valeurs du tuple avec
les indices <code>0</code> et <code>1</code>. On gagne en clarté.</p>
<!--
### Adding Useful Functionality with Derived Traits
-->
<h3><a class="header" href="#ajouter-des-fonctionnalités-utiles-avec-les-traits-dérivés" id="ajouter-des-fonctionnalités-utiles-avec-les-traits-dérivés">Ajouter des fonctionnalités utiles avec les traits dérivés</a></h3>
<!--
It’d be nice to be able to print an instance of `Rectangle` while we’re
debugging our program and see the values for all its fields. Listing 5-11 tries
using the `println!` macro as we have used in previous chapters. This won’t
work, however.
-->
<p>Cela serait bien de pouvoir afficher une instance de <code>Rectangle</code> pendant qu'on
débogue notre programme et de voir la valeur de chacun de ses champs. L'encart
5-11 essaye de le faire en utilisant la macro <code>println!</code> comme on l'a fait
dans les chapitres précédents. Cependant, cela ne fonctionne pas.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore,does_not_compile
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {}", rect1);
}
```
-->
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(&quot;rect1 est {}&quot;, rect1);
}
</code></pre>
<!--
<span class="caption">Listing 5-11: Attempting to print a `Rectangle`
instance</span>
-->
<p><span class="caption">Encart 5-11 : Tentative d'afficher une instance de
<code>Rectangle</code></span></p>
<!--
When we run this code, we get an error with this core message:
-->
<p>Lorsqu'on exécute ce code, on obtient ce message d'erreur qui nous informe que
<code>Rectangle</code> n'implémente pas le trait <code>std::fmt::Display</code> :</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<!--
The `println!` macro can do many kinds of formatting, and by default, the curly
brackets tell `println!` to use formatting known as `Display`: output intended
for direct end user consumption. The primitive types we’ve seen so far
implement `Display` by default, because there’s only one way you’d want to show
a `1` or any other primitive type to a user. But with structs, the way
`println!` should format the output is less clear because there are more
display possibilities: Do you want commas or not? Do you want to print the
curly brackets? Should all the fields be shown? Due to this ambiguity, Rust
doesn’t try to guess what we want, and structs don’t have a provided
implementation of `Display`.
-->
<p>La macro <code>println!</code> peut faire toutes sortes de formatages textuels, et par
défaut, les accolades demandent à <code>println!</code> d'utiliser le formatage appelé
<code>Display</code>, pour convertir en texte destiné à être vu par l'utilisateur final.
Les types primitifs qu'on a vus jusqu'ici implémentent <code>Display</code> par défaut
puisqu'il n'existe qu'une seule façon d'afficher un <code>1</code> ou tout autre type
primitif à l'utilisateur. Mais pour les structures, la façon dont <code>println!</code>
devrait formater son résultat est moins claire car il y a plus de possibilités
d'affichage : Voulez-vous des virgules ? Voulez-vous afficher les accolades ?
Est-ce que tous les champs devraient être affichés ? À cause de ces ambiguïtés,
Rust n'essaye pas de deviner ce qu'on veut, et les structures n'implémentent pas
<code>Display</code> par défaut.</p>
<!--
If we continue reading the errors, we’ll find this helpful note:
-->
<p>Si nous continuons de lire les erreurs, nous trouvons cette remarque utile :</p>
<pre><code class="language-text">= help: the trait `std::fmt::Display` is not implemented for `Rectangle`
= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Le compilateur nous informe que dans notre chaîne de formatage, on est peut-être
en mesure d'utiliser <code>{:?}</code> (ou <code>{:#?}</code> pour un affichage plus élégant).</p>
<!--
Let’s try it! The `println!` macro call will now look like `println!("rect1 is
{:?}", rect1);`. Putting the specifier `:?` inside the curly brackets tells
`println!` we want to use an output format called `Debug`. The `Debug` trait
enables us to print our struct in a way that is useful for developers so we can
see its value while we’re debugging our code.
-->
<p>Essayons cela ! L'appel de la macro <code>println!</code> ressemble maintenant à
<code>println!(&quot;rect1 est {:?}&quot;, rect1);</code>. Insérer le sélecteur <code>:?</code> entre les
accolades permet d'indiquer à <code>println!</code> que nous voulons utiliser le formatage
appelé <code>Debug</code>. Le trait <code>Debug</code> nous permet d'afficher notre structure d'une
manière utile aux développeurs pour qu'on puisse voir sa valeur pendant qu'on
débogue le code.</p>
<!--
Run the code with this change. Drat! We still get an error:
-->
<p>Exécutez le code avec ce changement. Zut ! On a encore une erreur, nous
informant cette fois-ci que <code>Rectangle</code> n'implémente pas <code>std::fmt::Debug</code> :</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
</code></pre>
<!--
But again, the compiler gives us a helpful note:
-->
<p>Mais une nouvelle fois, le compilateur nous fait une remarque utile :</p>
<pre><code class="language-text">= help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
</code></pre>
<p>Il nous conseille d'ajouter <code>#[derive(Debug)]</code> ou d'implémenter manuellement
<code>std::fmt::Debug</code>.</p>
<!--
Rust *does* include functionality to print out debugging information, but we
have to explicitly opt in to make that functionality available for our struct.
To do that, we add the annotation `#[derive(Debug)]` just before the struct
definition, as shown in Listing 5-12.
-->
<p>Rust <em>inclut</em> bel et bien une fonctionnalité pour afficher des informations de
débogage, mais nous devons l'activer explicitement pour la rendre disponible sur
notre structure. Pour ce faire, on ajoute l'annotation <code>#[derive(Debug)]</code> juste
avant la définition de la structure, comme le montre l'encart 5-12.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {:?}", rect1);
}
```
-->
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(&quot;rect1 est {:?}&quot;, rect1);
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-12: Adding the annotation to derive the `Debug`
trait and printing the `Rectangle` instance using debug formatting</span>
-->
<p><span class="caption">Encart 5-12 : L'ajout de l'annotation pour dériver le
trait <code>Debug</code> et afficher l'instance de <code>Rectangle</code> en utilisant le formatage
de débogage</span></p>
<!--
Now when we run the program, we won’t get any errors, and we’ll see the
following output:
-->
<p>Maintenant, quand on exécute le programme, nous n'avons plus d'erreurs et ce
texte s'affiche à l'écran :</p>
<!--
```text
rect1 is Rectangle { width: 30, height: 50 }
```
-->
<pre><code class="language-text">rect1 est Rectangle { largeur: 30, hauteur: 50 }
</code></pre>
<!--
Nice! It’s not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, it’s useful to have output that’s a bit easier to read; in
those cases, we can use `{:#?}` instead of `{:?}` in the `println!` string.
When we use the `{:#?}` style in the example, the output will look like this:
-->
<p>Super ! Ce n'est pas le plus beau des affichages, mais cela montre les
valeurs de tous les champs de cette instance, ce qui serait assurément utile
lors du débogage. Quand on a des structures plus grandes, il serait bien d'avoir
un affichage un peu plus lisible ; dans ces cas-là, on pourra utiliser <code>{:#?}</code>
au lieu de <code>{:?}</code> dans la chaîne de formatage. Quand on utilise <code>{:#?}</code> dans cet
exemple, l'affichage donnera plutôt ceci :</p>
<!--
```text
rect1 is Rectangle {
    width: 30,
    height: 50
}
```
-->
<pre><code class="language-text">rect1 est Rectangle {
    largeur: 30,
    hauteur: 50,
}
</code></pre>
<!--
Rust has provided a number of traits for us to use with the `derive` annotation
that can add useful behavior to our custom types. Those traits and their
behaviors are listed in Appendix C. We’ll cover how to implement these traits
with custom behavior as well as how to create your own traits in Chapter 10.
-->
<p>Rust nous fournit un certain nombre de traits qu'on peut utiliser avec
l'annotation <code>derive</code> qui peuvent ajouter des comportements utiles à nos propres
types. Ces traits et leurs comportements sont listés à l'annexe C. Nous
expliquerons comment implémenter ces traits avec des comportements personnalisés
et comment créer vos propres traits au chapitre 10.</p>
<!--
Our `area` function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our `Rectangle`
struct, because it won’t work with any other type. Let’s look at how we can
continue to refactor this code by turning the `area` function into an `area`
*method* defined on our `Rectangle` type.
-->
<p>Notre fonction <code>aire</code> est très spécifique : elle ne fait que calculer l'aire
d'un rectangle. Il serait utile de lier un peu plus ce comportement à notre
structure <code>Rectangle</code>, puisque cela ne fonctionnera pas avec un autre type.
Voyons comment on peut continuer de remanier ce code en transformant la fonction
<code>aire</code> en <em>méthode</em> <code>aire</code> définie sur notre type <code>Rectangle</code>.</p>
<!-- [the-tuple-type]: ch03-02-data-types.html#the-tuple-type -->
<!--
## Method Syntax
-->
<h2><a class="header" href="#la-syntaxe-des-méthodes" id="la-syntaxe-des-méthodes">La syntaxe des méthodes</a></h2>
<!--
*Methods* are similar to functions: they’re declared with the `fn` keyword and
their name, they can have parameters and a return value, and they contain some
code that is run when they’re called from somewhere else. However, methods are
different from functions in that they’re defined within the context of a struct
(or an enum or a trait object, which we cover in Chapters 6 and 17,
respectively), and their first parameter is always `self`, which represents the
instance of the struct the method is being called on.
-->
<p>Les <em>méthodes</em> sont similaires aux fonctions : on les déclare avec le mot-clé
<code>fn</code> et leur nom, elles peuvent avoir des paramètres et une valeur de retour, et
elles contiennent du code qui est exécuté quand on les appelle depuis un autre
endroit. Cependant, les méthodes diffèrent des fonctions parce qu'elles sont
définies dans le contexte d'une structure (ou d'une énumération ou d'un objet de
trait, que nous aborderons respectivement aux chapitres 6 et 17) et que leur
premier paramètre est toujours <code>self</code>, un mot-clé qui représente l'instance de
la structure sur laquelle on appelle la méthode.</p>
<!--
### Defining Methods
-->
<h3><a class="header" href="#définir-des-méthodes" id="définir-des-méthodes">Définir des méthodes</a></h3>
<!--
Let’s change the `area` function that has a `Rectangle` instance as a parameter
and instead make an `area` method defined on the `Rectangle` struct, as shown
in Listing 5-13.
-->
<p>Remplaçons la fonction <code>aire</code> qui prend une instance de <code>Rectangle</code> en paramètre
par une méthode <code>aire</code> définie sur la structure <code>Rectangle</code>, comme dans
l'encart 5-13.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```
-->
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    largeur: u32,
    hauteur: u32,
}

impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };

    println!(
        &quot;L'aire du rectangle est de {} pixels carrés.&quot;,
        rect1.aire()
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-13: Defining an `area` method on the
`Rectangle` struct</span>
-->
<p><span class="caption">Encart 5-13 : Définition d'une méthode <code>aire</code> sur la
structure <code>Rectangle</code></span></p>
<!--
To define the function within the context of `Rectangle`, we start an `impl`
(implementation) block. Then we move the `area` function within the `impl`
curly brackets and change the first (and in this case, only) parameter to be
`self` in the signature and everywhere within the body. In `main`, where we
called the `area` function and passed `rect1` as an argument, we can instead
use *method syntax* to call the `area` method on our `Rectangle` instance.
The method syntax goes after an instance: we add a dot followed by the method
name, parentheses, and any arguments.
-->
<p>Pour définir la fonction dans le contexte de <code>Rectangle</code>, nous démarrons un bloc
<code>impl</code> (<em>implémentation</em>). Puis nous déplaçons la fonction <code>aire</code> entre les
accolades du <code>impl</code> et nous remplaçons le premier paramètre (et dans notre cas,
le seul) par <code>self</code> dans la signature et dans tout le corps. Dans <code>main</code>, où
nous avons appelé la fonction <code>aire</code> et passé <code>rect1</code> en argument, nous pouvons
utiliser à la place la <em>syntaxe des méthodes</em> pour appeler la méthode <code>aire</code> sur
notre instance de <code>Rectangle</code>. La syntaxe des méthodes se place après
l'instance : on ajoute un point suivi du nom de la méthode et des parenthèses
contenant les arguments s'il y en a.</p>
<!--
In the signature for `area`, we use `&self` instead of `rectangle: &Rectangle`
because Rust knows the type of `self` is `Rectangle` due to this method’s being
inside the `impl Rectangle` context. Note that we still need to use the `&`
before `self`, just as we did in `&Rectangle`. Methods can take ownership of
`self`, borrow `self` immutably as we’ve done here, or borrow `self` mutably,
just as they can any other parameter.
-->
<p>Dans la signature de <code>aire</code>, nous utilisons <code>&amp;self</code> à la place de
<code>rectangle: &amp;Rectangle</code> parce que Rust sait que le type de <code>self</code> est
<code>Rectangle</code> puisque la méthode se trouve au sein du contexte <code>impl Rectangle</code>.
Veuillez noter qu'il nous faut quand même utiliser le <code>&amp;</code> avant le <code>self</code>, comme
nous l'avions fait pour <code>&amp;Rectangle</code>. Les méthodes peuvent prendre possession de
<code>self</code>, emprunter <code>self</code> de façon immuable comme nous l'avons fait ici, ou
emprunter <code>self</code> de façon mutable, comme pour n'importe quel autre paramètre.</p>
<!--
We’ve chosen `&self` here for the same reason we used `&Rectangle` in the
function version: we don’t want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
we’ve called the method on as part of what the method does, we’d use `&mut
self` as the first parameter. Having a method that takes ownership of the
instance by using just `self` as the first parameter is rare; this technique is
usually used when the method transforms `self` into something else and you want
to prevent the caller from using the original instance after the transformation.
-->
<p>Nous avons choisi <code>&amp;self</code> ici pour la même raison que nous avions utilisé
<code>&amp;Rectangle</code> quand il s'agissait d'une fonction ; nous ne voulons pas en prendre
possession, et nous voulons seulement lire les données de la structure, pas les
modifier. Si nous voulions que la méthode modifie l'instance sur laquelle on
l'appelle, on utiliserait <code>&amp;mut self</code> comme premier paramètre. Il est rare
d'avoir une méthode qui prend possession de l'instance en utilisant uniquement
<code>self</code> comme premier argument ; cette technique est généralement utilisée
lorsque la méthode transforme <code>self</code> en quelque chose d'autre et que vous voulez
empêcher le code appelant d'utiliser l'instance d'origine après la
transformation.</p>
<!--
The main benefit of using methods instead of functions, in addition to using
method syntax and not having to repeat the type of `self` in every method’s
signature, is for organization. We’ve put all the things we can do with an
instance of a type in one `impl` block rather than making future users of our
code search for capabilities of `Rectangle` in various places in the library we
provide.
-->
<p>Outre l'utilisation de la syntaxe des méthodes et le fait de ne pas être obligé
de répéter le type de <code>self</code> dans la signature de chaque méthode, le principal
avantage de l'utilisation de méthodes plutôt que de fonctions est pour
l'organisation. Nous avons mis tout ce qu'on pouvait faire avec une instance de
notre type dans un bloc <code>impl</code> plutôt que d'imposer aux futurs utilisateurs de
notre code à rechercher les fonctionnalités de <code>Rectangle</code> à divers endroits de
la bibliothèque que nous fournissons.</p>
<!--
> ### Where’s the `->` Operator?
>
> In C and C++, two different operators are used for calling methods: you use
> `.` if you’re calling a method on the object directly and `->` if you’re
> calling the method on a pointer to the object and need to dereference the
> pointer first. In other words, if `object` is a pointer,
> `object->something()` is similar to `(*object).something()`.
>
> Rust doesn’t have an equivalent to the `->` operator; instead, Rust has a
> feature called *automatic referencing and dereferencing*. Calling methods is
> one of the few places in Rust that has this behavior.
>
> Here’s how it works: when you call a method with `object.something()`, Rust
> automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of
> the method. In other words, the following are the same:
>
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> The first one looks much cleaner. This automatic referencing behavior works
> because methods have a clear receiver—the type of `self`. Given the receiver
> and name of a method, Rust can figure out definitively whether the method is
> reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact
> that Rust makes borrowing implicit for method receivers is a big part of
> making ownership ergonomic in practice.
-->
<blockquote>
<h3><a class="header" href="#où-est-lopérateur---" id="où-est-lopérateur---">Où est l'opérateur <code>-&gt;</code> ?</a></h3>
<p>En C et en C++, deux opérateurs différents sont utilisés pour appeler les
méthodes : on utilise <code>.</code> si on appelle une méthode directement sur l'objet
et <code>-&gt;</code> si on appelle la méthode sur un pointeur vers l'objet et qu'il faut
d'abord déréférencer le pointeur. En d'autres termes, si <code>objet</code> est un
pointeur, <code>objet-&gt;methode()</code> est similaire à <code>(*objet).methode()</code>.</p>
<p>Rust n'a pas d'équivalent à l'opérateur <code>-&gt;</code> ; à la place, Rust a une
fonctionnalité appelée <em>référencement et déréférencement automatiques</em>.
L'appel de méthodes est l'un des rares endroits de Rust où on retrouve ce
comportement.</p>
<p>Voilà comment cela fonctionne : quand on appelle une méthode avec
<code>objet.methode()</code>, Rust ajoute automatiquement le <code>&amp;</code>, <code>&amp;mut</code> ou <code>*</code> pour que
<code>objet</code> corresponde à la signature de la méthode. Autrement dit, ces deux
lignes sont identiques :</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, autre: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_carre = f64::powi(autre.x - self.x, 2);
</span><span class="boring">       let y_carre = f64::powi(autre.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_carre + y_carre)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>La première ligne semble bien plus propre. Ce comportement du
(dé)référencement automatique fonctionne parce que les méthodes ont une
cible claire : le type de <code>self</code>. Compte tenu du nom de la méthode et
de l'instance sur laquelle elle s'applique, Rust peut déterminer de manière
irréfutable si la méthode lit (<code>&amp;self</code>), modifie (<code>&amp;mut self</code>) ou consomme
(<code>self</code>) l'instance. Le fait que Rust rend implicite l'emprunt pour les
instances sur lesquelles on appelle les méthodes améliore significativement
l'ergonomie de la possession.</p>
</blockquote>
<!--
### Methods with More Parameters
-->
<h3><a class="header" href="#les-méthodes-avec-davantage-de-paramètres" id="les-méthodes-avec-davantage-de-paramètres">Les méthodes avec davantage de paramètres</a></h3>
<!--
Let’s practice using methods by implementing a second method on the `Rectangle`
struct. This time, we want an instance of `Rectangle` to take another instance
of `Rectangle` and return `true` if the second `Rectangle` can fit completely
within `self`; otherwise it should return `false`. That is, we want to be able
to write the program shown in Listing 5-14, once we’ve defined the `can_hold`
method.
-->
<p>Entraînons-nous à utiliser des méthodes en implémentant une seconde méthode sur
la structure <code>Rectangle</code>. Cette fois-ci, nous voulons qu'une instance de
<code>Rectangle</code> prenne une autre instance de <code>Rectangle</code> et qu'on retourne <code>true</code> si
le second <code>Rectangle</code> peut se dessiner intégralement à l'intérieur de <code>self</code> ;
sinon, on renverra <code>false</code>. En d'autres termes, on veut pouvoir écrire le
programme de l'encart 5-14 une fois qu'on aura défini la méthode
<code>peut_contenir</code>.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust,ignore
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```
-->
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle { largeur: 30, hauteur: 50 };
    let rect2 = Rectangle { largeur: 10, hauteur: 40 };
    let rect3 = Rectangle { largeur: 60, hauteur: 45 };

    println!(&quot;rect1 peut-il contenir rect2 ? {}&quot;, rect1.peut_contenir(&amp;rect2));
    println!(&quot;rect1 peut-il contenir rect3 ? {}&quot;, rect1.peut_contenir(&amp;rect3));
}
</code></pre>
<!--
<span class="caption">Listing 5-14: Using the as-yet-unwritten `can_hold`
method</span>
-->
<p><span class="caption">Encart 5-14 : Utilisation de la méthode <code>peut_contenir</code>
qui reste à écrire</span></p>
<!--
And the expected output would look like the following, because both dimensions
of `rect2` are smaller than the dimensions of `rect1` but `rect3` is wider than
`rect1`:
-->
<p>Et on s'attend à ce que le texte suivant s'affiche, puisque les deux dimensions
de <code>rect2</code> sont plus petites que les dimensions de <code>rect1</code>, mais <code>rect3</code> est
plus large que <code>rect1</code> :</p>
<!--
```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```
-->
<pre><code class="language-text">rect1 peut-il contenir rect2 ? true
rect1 peut-il contenir rect3 ? false
</code></pre>
<!--
We know we want to define a method, so it will be within the `impl Rectangle`
block. The method name will be `can_hold`, and it will take an immutable borrow
of another `Rectangle` as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
`rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to
`rect2`, an instance of `Rectangle`. This makes sense because we only need to
read `rect2` (rather than write, which would mean we’d need a mutable borrow),
and we want `main` to retain ownership of `rect2` so we can use it again after
calling the `can_hold` method. The return value of `can_hold` will be a
Boolean, and the implementation will check whether the width and height of
`self` are both greater than the width and height of the other `Rectangle`,
respectively. Let’s add the new `can_hold` method to the `impl` block from
Listing 5-13, shown in Listing 5-15.
-->
<p>Nous voulons définir une méthode, donc elle doit se trouver dans le bloc
<code>impl Rectangle</code>. Le nom de la méthode sera <code>peut_contenir</code> et elle prendra une
référence immuable vers un autre <code>Rectangle</code> en paramètre. On peut déterminer le
type du paramètre en regardant le code qui appelle la méthode :
<code>rect1.peut_contenir(&amp;rect2)</code> prend en argument <code>&amp;rect2</code>, une référence immuable
vers <code>rect2</code>, une instance de <code>Rectangle</code>. Cela est logique puisque nous voulons
uniquement lire <code>rect2</code> (plutôt que de la modifier, ce qui aurait nécessité une
référence mutable) et nous souhaitons que <code>main</code> garde possession de <code>rect2</code>
pour qu'on puisse le réutiliser après avoir appelé la méthode <code>peut_contenir</code>.
La valeur de retour de <code>peut_contenir</code> sera un booléen et l'implémentation de la
méthode vérifiera si la largeur et la hauteur de <code>self</code> sont respectivement plus
grandes que la largeur et la hauteur de l'autre <code>Rectangle</code>. Ajoutons la
nouvelle méthode <code>peut_contenir</code> dans le bloc <code>impl</code> de l'encart 5-13, comme le
montre l'encart 5-15.</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }

    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-15: Implementing the `can_hold` method on
`Rectangle` that takes another `Rectangle` instance as a parameter</span>
-->
<p><span class="caption">Encart 5-15 : Implémentation de la méthode <code>peut_contenir</code>
sur <code>Rectangle</code> qui prend une autre instance de <code>Rectangle</code> en paramètre</span></p>
<!--
When we run this code with the `main` function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the `self` parameter, and those parameters work just like
parameters in functions.
-->
<p>Lorsque nous exécutons ce code avec la fonction <code>main</code> de l'encart 5-14, nous
obtenons l'affichage attendu. Les méthodes peuvent prendre plusieurs paramètres
qu'on peut ajouter à la signature après le paramètre <code>self</code>, et ces paramètres
fonctionnent de la même manière que les paramètres des fonctions.</p>
<!--
### Associated Functions
-->
<h3><a class="header" href="#les-fonctions-associées" id="les-fonctions-associées">Les fonctions associées</a></h3>
<!--
Another useful feature of `impl` blocks is that we’re allowed to define
functions within `impl` blocks that *don’t* take `self` as a parameter. These
are called *associated functions* because they’re associated with the struct.
They’re still functions, not methods, because they don’t have an instance of
the struct to work with. You’ve already used the `String::from` associated
function.
-->
<p>Une autre fonctionnalité utile des blocs <code>impl</code> est qu'on peut définir des
fonctions dans des blocs <code>impl</code> qui ne prennent <em>pas</em> <code>self</code> en paramètre. Cela
s'appelle des <em>fonctions associées</em> parce qu'elles sont associées à la
structure. Cela reste des fonctions, pas des méthodes, parce qu'elles ne
s'appliquent pas à une instance de structure. Vous avez déjà utilisé la fonction
associée <code>String::from</code>.</p>
<!--
Associated functions are often used for constructors that will return a new
instance of the struct. For example, we could provide an associated function
that would have one dimension parameter and use that as both width and height,
thus making it easier to create a square `Rectangle` rather than having to
specify the same value twice:
-->
<p>Les fonctions associées sont souvent utilisées comme constructeurs qui vont
retourner une nouvelle instance de la structure. Par exemple, on pourrait écrire
une fonction associée qui prend une unique dimension en paramètre et l'utilise
à la fois pour la largeur et pour la hauteur, ce qui rend plus aisé la création
d'un <code>Rectangle</code> carré plutôt que d'avoir à indiquer la même valeur deux fois :</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">Fichier : src/main.rs</span></p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn carre(cote: u32) -&gt; Rectangle {
        Rectangle { largeur: cote, hauteur: cote }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
To call this associated function, we use the `::` syntax with the struct name;
`let sq = Rectangle::square(3);` is an example. This function is namespaced by
the struct: the `::` syntax is used for both associated functions and
namespaces created by modules. We’ll discuss modules in Chapter 7.
-->
<p>Pour appeler cette fonction associée, on utilise la syntaxe <code>::</code> avec le nom de
la structure ; <code>let mon_carre = Rectangle::carre(3);</code> en est un exemple. Cette
fonction est cloisonnée dans l'espace de noms de la structure : la syntaxe <code>::</code>
s'utilise aussi bien pour les fonctions associées que pour les espaces de noms
créés par des modules. Nous aborderons les modules au chapitre 7.</p>
<!--
### Multiple `impl` Blocks
-->
<h3><a class="header" href="#plusieurs-blocs-impl" id="plusieurs-blocs-impl">Plusieurs blocs <code>impl</code></a></h3>
<!--
Each struct is allowed to have multiple `impl` blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own `impl` block.
-->
<p>Chaque structure peut avoir plusieurs blocs <code>impl</code>. Par exemple, l'encart 5-15
est équivalent au code de l'encart 5-16, où chaque méthode est dans son propre
bloc <code>impl</code>.</p>
<!--
```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    largeur: u32,
</span><span class="boring">    hauteur: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn aire(&amp;self) -&gt; u32 {
        self.largeur * self.hauteur
    }
}

impl Rectangle {
    fn peut_contenir(&amp;self, autre: &amp;Rectangle) -&gt; bool {
        self.largeur &gt; autre.largeur &amp;&amp; self.hauteur &gt; autre.hauteur
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple `impl`
blocks</span>
-->
<p><span class="caption">Encart 5-16 : Réécriture de l'encart 5-15 en utilisant
plusieurs blocs <code>impl</code></span></p>
<!--
There’s no reason to separate these methods into multiple `impl` blocks here,
but this is valid syntax. We’ll see a case in which multiple `impl` blocks are
useful in Chapter 10, where we discuss generic types and traits.
-->
<p>Il n'y a aucune raison de séparer ces méthodes dans plusieurs blocs <code>impl</code> dans
notre exemple, mais c'est une syntaxe valide. Nous verrons un exemple de
l'utilité d'avoir plusieurs blocs <code>impl</code> au chapitre 10, où nous aborderons les
types génériques et les traits.</p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé-4" id="résumé-4">Résumé</a></h2>
<!--
Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. Methods let you specify the
behavior that instances of your structs have, and associated functions let you
namespace functionality that is particular to your struct without having an
instance available.
-->
<p>Les structures vous permettent de créer des types personnalisés significatifs
pour votre domaine. En utilisant des structures, on peut relier entre elles
des données associées et nommer chaque donnée pour rendre le code plus clair.
Les méthodes vous permettent de définir le comportement des instances de vos
structures, et les fonctions associées vous permettent de cloisonner dans un
espace de noms des fonctionnalités qui sont spécifiques à votre structure sans
avoir besoin d'une instance disponible.</p>
<!--
But structs aren’t the only way you can create custom types: let’s turn to
Rust’s enum feature to add another tool to your toolbox.
-->
<p>Mais les structures ne sont pas le seul moyen de créer des types personnalisés :
nous allons maintenant voir les énumérations de Rust, une fonctionnalité que
vous pourrez bientôt ajouter à votre boîte à outils.</p>
<!--
# Enums and Pattern Matching
-->
<h1><a class="header" href="#les-énumérations-et-le-filtrage-par-motif" id="les-énumérations-et-le-filtrage-par-motif">Les énumérations et le filtrage par motif</a></h1>
<!--
In this chapter we’ll look at *enumerations*, also referred to as *enums*.
Enums allow you to define a type by enumerating its possible *variants*. First,
we’ll define and use an enum to show how an enum can encode meaning along with
data. Next, we’ll explore a particularly useful enum, called `Option`, which
expresses that a value can be either something or nothing. Then we’ll look at
how pattern matching in the `match` expression makes it easy to run different
code for different values of an enum. Finally, we’ll cover how the `if let`
construct is another convenient and concise idiom available to you to handle
enums in your code.
-->
<p>Dans ce chapitre, nous allons aborder les <em>énumérations</em>, aussi appelées
<em>enums</em>. Les énumérations vous permettent de définir un type en énumérant ses
<em>variantes</em> possibles. Pour commencer, nous allons définir et utiliser une
énumération pour voir comment une énumération peut donner du sens aux données.
Ensuite, nous examinerons une énumération particulièrement utile qui s'appelle
<code>Option</code> et qui permet de décrire des situations où la valeur peut être soit
quelque chose, soit rien. Ensuite, nous regarderons comment le filtrage par
motif avec l'expression <code>match</code> peut faciliter l'exécution de codes différents
pour chaque valeur d'une énumération. Enfin, nous analyserons pourquoi la
construction <code>if let</code> est un autre outil commode et concis à votre disposition
pour traiter les énumérations dans votre code.</p>
<!--
Enums are a feature in many languages, but their capabilities differ in each
language. Rust’s enums are most similar to *algebraic data types* in functional
languages, such as F#, OCaml, and Haskell.
-->
<p>Les énumérations sont des fonctionnalités présentes dans de nombreux langages,
mais leurs aptitudes varient d'un langage à l'autre. Les énumérations de Rust
sont plus proches des <em>types de données algébriques</em> des langages fonctionnels,
comme F#, OCaml et Haskell.</p>
<!--
## Defining an Enum
-->
<h2><a class="header" href="#définir-une-énumération" id="définir-une-énumération">Définir une énumération</a></h2>
<!--
Let’s look at a situation we might want to express in code and see why enums
are useful and more appropriate than structs in this case. Say we need to work
with IP addresses. Currently, two major standards are used for IP addresses:
version four and version six. These are the only possibilities for an IP
address that our program will come across: we can *enumerate* all possible
variants, which is where enumeration gets its name.
-->
<p>Imaginons une situation que nous voudrions exprimer avec du code et regardons
pourquoi les énumérations sont utiles et plus appropriées que les structures
dans ce cas. Disons que nous avons besoin de travailler avec des adresses IP.
Pour le moment, il existe deux normes principales pour les adresses IP : la
version quatre et la version six. Ce seront les seules possibilités d'adresse
IP que notre programme va rencontrer : nous pouvons <em>énumérer</em> toutes les
variantes possibles, d'où vient le nom de l'énumération.</p>
<!--
Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate, because enum values can only be one of its variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.
-->
<p>N'importe quelle adresse IP peut être soit une adresse en version quatre, soit
en version six, mais pas les deux en même temps. Cette propriété des adresses IP
est appropriée à la structure de données d'énumérations, car les valeurs de
l'énumération ne peuvent être qu'une de ses variantes. Les adresses en version
quatre et six sont toujours fondamentalement des adresses IP, donc elles doivent
être traitées comme étant du même type lorsque le code travaille avec des
situations qui s'appliquent à n'importe quelle sorte d'adresse IP.</p>
<!--
We can express this concept in code by defining an `IpAddrKind` enumeration and
listing the possible kinds an IP address can be, `V4` and `V6`. These are the
variants of the enum:
-->
<p>Nous pouvons exprimer ce concept dans le code en définissant une énumération
<code>SorteAdresseIp</code> et en listant les différentes sortes possibles d'adresses IP
qu'elle peut avoir, <code>V4</code> et <code>V6</code>. Ce sont les variantes de l'énumération :</p>
<!--
```rust
enum IpAddrKind {
    V4,
    V6,
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum SorteAdresseIp {
    V4,
    V6,
}
<span class="boring">}
</span></code></pre></pre>
<!--
`IpAddrKind` is now a custom data type that we can use elsewhere in our code.
-->
<p><code>SorteAdresseIp</code> est maintenant un type de données personnalisé que nous pouvons
utiliser n'importe où dans notre code.</p>
<!--
### Enum Values
-->
<h3><a class="header" href="#les-valeurs-dénumérations" id="les-valeurs-dénumérations">Les valeurs d'énumérations</a></h3>
<!--
We can create instances of each of the two variants of `IpAddrKind` like this:
-->
<p>Nous pouvons créer des instances de chacune des deux variantes de
<code>SorteAdresseIp</code> de cette manière :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span>let quatre = SorteAdresseIp::V4;
let six = SorteAdresseIp::V6;
<span class="boring">}
</span></code></pre></pre>
<!--
Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. The reason this is useful is that now
both values `IpAddrKind::V4` and `IpAddrKind::V6` are of the same type:
`IpAddrKind`. We can then, for instance, define a function that takes any
`IpAddrKind`:
-->
<p>Remarquez que les variantes de l'énumération sont dans un espace de nom qui se
situe avant leur nom, et nous utilisons un double deux-points pour les séparer
tous les deux. C'est utile car maintenant les deux valeurs <code>SorteAdresseIp::V4</code>
et <code>SorteAdresseIp::V6</code> sont du même type : <code>SorteAdresseIp</code>. Ensuite, nous
pouvons, par exemple, définir une fonction qui accepte n'importe quelle
<code>SorteAdresseIp</code> :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
fn route(ip_kind: IpAddrKind) { }
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span>fn router(sorte_ip: SorteAdresseIp) { }
<span class="boring">}
</span></code></pre></pre>
<!--
And we can call this function with either variant:
-->
<p>Et nous pouvons appeler cette fonction avec chacune des variantes :</p>
<!--
```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
# fn route(ip_kind: IpAddrKind) { }
#
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum SorteAdresseIp {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn router(sorte_ip: SorteAdresseIp) { }
</span><span class="boring">
</span>router(SorteAdresseIp::V4);
router(SorteAdresseIp::V6);
<span class="boring">}
</span></code></pre></pre>
<!--
Using enums has even more advantages. Thinking more about our IP address type,
at the moment we don’t have a way to store the actual IP address *data*; we
only know what *kind* it is. Given that you just learned about structs in
Chapter 5, you might tackle this problem as shown in Listing 6-1.
-->
<p>L'utilisation des énumérations a encore plus d'avantages. En étudiant un peu
plus notre type d'adresse IP, nous constatons que pour le moment, nous ne
pouvons pas stocker <em>la donnée</em> de l'adresse IP ; nous savons seulement de
quelle sorte elle est. Avec ce que vous avez appris au chapitre 5, vous pouvez
résoudre ce problème comme dans l'encart 6-1.</p>
<!--
```rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum SorteAdresseIp {
    V4,
    V6,
}

struct AdresseIp {
    sorte: SorteAdresseIp,
    adresse: String,
}

let local = AdresseIp {
    sorte: SorteAdresseIp::V4,
    adresse: String::from(&quot;127.0.0.1&quot;),
};

let rebouclage = AdresseIp {
    sorte: SorteAdresseIp::V6,
    adresse: String::from(&quot;::1&quot;),
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-1: Storing the data and `IpAddrKind` variant of
an IP address using a `struct`</span>
-->
<p><span class="caption">Encart 6-1 : Stockage de la donnée et de la variante de
<code>SorteAdresseIp</code> d'une adresse IP en utilisant une <code>struct</code></span></p>
<!--
Here, we’ve defined a struct `IpAddr` that has two fields: a `kind` field that
is of type `IpAddrKind` (the enum we defined previously) and an `address` field
of type `String`. We have two instances of this struct. The first, `home`, has
the value `IpAddrKind::V4` as its `kind` with associated address data of
`127.0.0.1`. The second instance, `loopback`, has the other variant of
`IpAddrKind` as its `kind` value, `V6`, and has address `::1` associated with
it. We’ve used a struct to bundle the `kind` and `address` values together, so
now the variant is associated with the value.
-->
<p>Ainsi, nous avons défini une structure <code>AdresseIp</code> qui a deux champs : un champ
<code>sorte</code> qui est du type <code>SorteAdresseIp</code> (l'énumération que nous avons définie
précédemment) et un champ <code>adresse</code> qui est du type <code>String</code>. Nous avons deux
instances de cette structure. La première, <code>local</code>, a la valeur
<code>SorteAdresseIp::V4</code> pour son champ <code>sorte</code>, associé à la donnée d'adresse qui
est <code>127.0.0.1</code>. La seconde instance, <code>rebouclage</code>, a comme valeur de champ
<code>sorte</code> l'autre variante de <code>SorteAdresseIp</code>, <code>V6</code>, et a l'adresse<code>::1</code> qui lui
est associée. Nous avons utilisé une structure pour relier ensemble la <code>sorte</code>
et l'<code>adresse</code>, donc maintenant la variante est liée à la valeur.</p>
<!--
We can represent the same concept in a more concise way using just an enum,
rather than an enum inside a struct, by putting data directly into each enum
variant. This new definition of the `IpAddr` enum says that both `V4` and `V6`
variants will have associated `String` values:
-->
<p>Nous pouvons appliquer le même principe de manière plus concise en utilisant
uniquement une énumération, plutôt que d'utiliser une énumération dans une
structure, en insérant directement la donnée dans chaque variante de
l'énumération. Cette nouvelle définition de l'énumération <code>AdresseIp</code> indique
que chacune des variantes <code>V4</code> et <code>V6</code> auront des valeurs associées de type
<code>String</code> :</p>
<!--
```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum AdresseIp {
    V4(String),
    V6(String),
}

let local = AdresseIp::V4(String::from(&quot;127.0.0.1&quot;));

let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We attach data to each variant of the enum directly, so there is no need for an
extra struct.
-->
<p>Nous relions les données de chaque variante directement à l'énumération, donc il
n'est pas nécessaire d'avoir une structure en plus.</p>
<!--
There’s another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four type IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store `V4` addresses as four `u8` values but
still express `V6` addresses as one `String` value, we wouldn’t be able to with
a struct. Enums handle this case with ease:
-->
<p>Il y a un autre avantage à utiliser une énumération plutôt qu'une structure :
chaque variante peut stocker des types différents, et aussi avoir une quantité
différente de données associées. Les adresses IP version quatre vont toujours
avoir quatre composantes numériques qui auront une valeur entre 0 et 255. Si
nous voulions stocker les adresses <code>V4</code> avec quatre valeurs de type <code>u8</code> mais
continuer à stocker les adresses <code>V6</code> dans une <code>String</code>, nous ne pourrions pas
le faire avec une structure. Les énumérations permettent de faire cela
facilement :</p>
<!--
```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum AdresseIp {
    V4(u8, u8, u8, u8),
    V6(String),
}

let local = AdresseIp::V4(127, 0, 0, 1);

let rebouclage = AdresseIp::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We’ve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that [the standard
library has a definition we can use!][IpAddr]<!-- ignore -- > Let’s look at how
the standard library defines `IpAddr`: it has the exact enum and variants that
we’ve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:
-->
<p>Nous avons vu différentes manières de définir des structures de données pour
enregistrer des adresses IP en version quatre et version six. Cependant, il
s'avère que vouloir stocker des adresses IP et identifier de quelle sorte elles
sont est si fréquent que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la bibliothèque standard a une définition que nous
pouvons utiliser !</a><!-- ignore --> Analysons comment la bibliothèque
standard a défini <code>IpAddr</code> (l'équivalent de notre <code>AdresseIp</code>) : nous retrouvons
la même énumération et les variantes que nous avons définies et utilisées, mais
stocke les données d'adresse dans des variantes dans deux structures
différentes, qui sont définies chacune pour chaque variante :</p>
<!--
[IpAddr]: ../std/net/enum.IpAddr.html
-->
<!--
```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // -- code masqué ici --
}

struct Ipv6Addr {
    // -- code masqué ici --
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.
-->
<p>Ce code montre comment vous pouvez insérer n'importe quel type de données dans
une variante d'énumération : des chaînes de caractères, des nombres ou des
structures, par exemple. Vous pouvez même y intégrer d'autres énumérations ! Par
ailleurs, les types de la bibliothèque standard ne sont parfois pas plus
compliqués que ce que vous pourriez inventer.</p>
<!--
Note that even though the standard library contains a definition for `IpAddr`,
we can still create and use our own definition without conflict because we
haven’t brought the standard library’s definition into our scope. We’ll talk
more about bringing types into scope in Chapter 7.
-->
<p>Notez aussi que même si la bibliothèque standard embarque une définition de
<code>IpAddr</code>, nous pouvons quand même créer et utiliser notre propre définition de
ce type sans avoir de conflit de nom car nous n'avons pas importé cette
définition de la bibliothèque standard dans la portée. Nous verrons plus en
détail comment importer les types dans la portée au chapitre 7.</p>
<!--
Let’s look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.
-->
<p>Analysons un autre exemple d'une énumération dans l'encart 6-2 : celle-ci a une
grande diversité de types dans ses variantes.</p>
<!--
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quitter,
    Deplacer { x: i32, y: i32 },
    Ecrire(String),
    ChangerCouleur(i32, i32, i32),
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-2: A `Message` enum whose variants each store
different amounts and types of values</span>
-->
<p><span class="caption">Encart 6-2 : Une énumération <code>Message</code> dont chaque
variante stocke des valeurs de différents types et en différentes
quantités</span></p>
<!--
This enum has four variants with different types:
-->
<p>Cette énumération a quatre variantes avec des types différents :</p>
<!--
* `Quit` has no data associated with it at all.
* `Move` includes an anonymous struct inside it.
* `Write` includes a single `String`.
* `ChangeColor` includes three `i32` values.
-->
<ul>
<li><code>Quitter</code> n'a pas du tout de donnée associée.</li>
<li><code>Deplacer</code> intègre une structure anonyme.</li>
<li><code>Ecrire</code> intègre une seule <code>String</code>.</li>
<li><code>ChangerCouleur</code> intègre trois valeurs de type <code>i32</code>.</li>
</ul>
<!--
Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesn’t use the
`struct` keyword and all the variants are grouped together under the `Message`
type. The following structs could hold the same data that the preceding enum
variants hold:
-->
<p>Définir une énumération avec des variantes comme celles dans l'encart 6-2
ressemble à la définition de différentes sortes de structures, sauf que
l'énumération n'utilise pas le mot-clé <code>struct</code> et que toutes les variantes sont
regroupées ensemble sous le type <code>Message</code>. Les structures suivantes peuvent
stocker les mêmes données que celles stockées par les variantes précédentes :</p>
<!--
```rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct MessageQuitter; // une structure unité
struct MessageDeplacer {
    x: i32,
    y: i32,
}
struct MessageEcrire(String); // une structure tuple
struct MessageChangerCouleur(i32, i32, i32); // une structure tuple
<span class="boring">}
</span></code></pre></pre>
<!--
But if we used the different structs, which each have their own type, we
couldn’t as easily define a function to take any of these kinds of messages as
we could with the `Message` enum defined in Listing 6-2, which is a single type.
-->
<p>Mais si nous utilisions les différentes structures, qui ont chacune leur propre
type, nous ne pourrions pas définir facilement une fonction qui prend en
paramètre toutes les sortes de messages, tel que nous pourrions le faire avec
l'énumération <code>Message</code> que nous avons définie dans l'encart 6-2, qui est un
seul type.</p>
<!--
There is one more similarity between enums and structs: just as we’re able to
define methods on structs using `impl`, we’re also able to define methods on
enums. Here’s a method named `call` that we could define on our `Message` enum:
-->
<p>Il y a un autre point commun entre les énumérations et les structures : tout
comme on peut définir des méthodes sur les structures en utilisant <code>impl</code>, on
peut aussi définir des méthodes sur des énumérations. Voici une méthode appelée
<code>appeler</code> que nous pouvons définir sur notre énumération <code>Message</code> :</p>
<!--
```rust
# enum Message {
#     Quit,
#     Move { x: i32, y: i32 },
#     Write(String),
#     ChangeColor(i32, i32, i32),
# }
#
impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quitter,
</span><span class="boring">    Deplacer { x: i32, y: i32 },
</span><span class="boring">    Ecrire(String),
</span><span class="boring">    ChangerCouleur(i32, i32, i32),
</span><span class="boring">}
</span><span class="boring">
</span>impl Message {
    fn appeler(&amp;self) {
        // le corps de la méthode sera défini ici
    }
}

let m = Message::Ecrire(String::from(&quot;hello&quot;));
m.appeler();
<span class="boring">}
</span></code></pre></pre>
<!--
The body of the method would use `self` to get the value that we called the
method on. In this example, we’ve created a variable `m` that has the value
`Message::Write(String::from("hello"))`, and that is what `self` will be in the
body of the `call` method when `m.call()` runs.
-->
<p>Le corps de la méthode va utiliser <code>self</code> pour obtenir la valeur sur laquelle
nous avons utilisé la méthode. Dans cet exemple, nous avons créé une variable
<code>m</code> qui a la valeur <code>Message::Ecrire(String::from(&quot;hello&quot;))</code>, et cela sera ce
que <code>self</code> aura comme valeur dans le corps de la méthode <code>appeler</code> quand nous
lancerons <code>m.appeler()</code>.</p>
<!--
Let’s look at another enum in the standard library that is very common and
useful: `Option`.
-->
<p>Regardons maintenant une autre énumération de la bibliothèque standard qui est
très utilisée et utile : <code>Option</code>.</p>
<!--
### The `Option` Enum and Its Advantages Over Null Values
-->
<h3><a class="header" href="#lénumération-option-et-ses-avantages-par-rapport-à-la-valeur-null" id="lénumération-option-et-ses-avantages-par-rapport-à-la-valeur-null">L'énumération <code>Option</code> et ses avantages par rapport à la valeur null</a></h3>
<!--
In the previous section, we looked at how the `IpAddr` enum let us use Rust’s
type system to encode more information than just the data into our program.
This section explores a case study of `Option`, which is another enum defined
by the standard library. The `Option` type is used in many places because it
encodes the very common scenario in which a value could be something or it
could be nothing. Expressing this concept in terms of the type system means the
compiler can check whether you’ve handled all the cases you should be handling;
this functionality can prevent bugs that are extremely common in other
programming languages.
-->
<p>Dans la section précédente, nous avons découvert comment l'énumération
<code>AdresseIp</code> nous permet d'utiliser le système de types de Rust pour enregistrer
dans nos programmes encore plus d'informations qu'uniquement la donnée. Cette
section étudie le cas de <code>Option</code>, qui est une autre énumération définie dans la
bibliothèque standard. Le type <code>Option</code> est utilisé dans de nombreux endroits
car il décrit un scénario très courant où une valeur peut être soit quelque
chose, soit rien du tout. Exprimer ce concept avec le système de types implique
que le compilateur peut vérifier si vous avez géré tous les cas que vous
pourriez rencontrer ; cette fonctionnalité peut éviter des bogues qui sont très
courants dans d'autres langages de programmation.</p>
<!--
Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesn’t have the
null feature that many other languages have. *Null* is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.
-->
<p>La conception d'un langage de programmation est souvent pensée en fonction des
fonctionnalités qu'on inclut, mais les fonctionnalités qu'on refuse sont elles
aussi importantes. Rust n'a pas de fonctionnalité <em>null</em> qu'ont de nombreux
langages. <em>Null</em> est une valeur qui signifie qu'il n'y a pas de valeur à cet
endroit. Avec les langages qui utilisent null, les variables peuvent toujours
être dans deux états : null ou non null.</p>
<!--
In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony
Hoare, the inventor of null, has this to say:
-->
<p>Dans sa thèse de 2009 “Null References: The Billion Dollar Mistake” (les
références nulles : l'erreur à un milliard de dollars), Tony Hoare, l'inventeur
de null, a écrit ceci :</p>
<!--
> I call it my billion-dollar mistake. At that time, I was designing the first
> comprehensive type system for references in an object-oriented language. My
> goal was to ensure that all use of references should be absolutely safe, with
> checking performed automatically by the compiler. But I couldn’t resist the
> temptation to put in a null reference, simply because it was so easy to
> implement. This has led to innumerable errors, vulnerabilities, and system
> crashes, which have probably caused a billion dollars of pain and damage in
> the last forty years.
-->
<blockquote>
<p>Je l'appelle mon erreur à un milliard de dollars. À cette époque, je concevais
le premier système de type complet pour des références dans un langage orienté
objet. Mon objectif était de garantir que toutes les utilisations des
références soient totalement sûres, et soient vérifiées automatiquement par le
compilateur. Mais je n'ai pas pu résister à la tentation d'inclure la
référence nulle, simplement parce que c'était si simple à implémenter. Cela a
conduit à d'innombrables erreurs, vulnérabilités, et pannes systèmes, qui ont
probablement causé un milliard de dollars de dommages au cours des quarante
dernières années.</p>
</blockquote>
<!--
The problem with null values is that if you try to use a null value as a
not-null value, you’ll get an error of some kind. Because this null or not-null
property is pervasive, it’s extremely easy to make this kind of error.
-->
<p>Le problème avec les valeurs nulles, c'est que si vous essayez d'utiliser une
valeur nulle comme si elle n'était pas nulle, vous obtiendrez une erreur d'une
façon ou d'une autre. Comme cette propriété nulle ou non nulle est omniprésente,
il est très facile de faire cette erreur.</p>
<!--
However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.
-->
<p>Cependant, le concept que null essaye d'exprimer reste utile : une valeur nulle
est une valeur qui est actuellement invalide ou absente pour une raison ou une
autre.</p>
<!--
The problem isn’t really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
`Option<T>`, and it is [defined by the standard library][option]<!-- ignore -- >
as follows:
-->
<p>Le problème ne vient pas vraiment du concept, mais de son implémentation. C'est
pourquoi Rust n'a pas de valeurs nulles, mais il a une énumération qui décrit le
concept d'une valeur qui peut être soit présente, soit absente. Cette
énumération est <code>Option&lt;T&gt;</code>, et elle est <a href="https://doc.rust-lang.org/std/option/enum.Option.html">définie dans la bibliothèque
standard</a><!-- ignore --> comme ci-dessous :</p>
<!--
[option]: ../std/option/enum.Option.html
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Option<T>` enum is so useful that it’s even included in the prelude; you
don’t need to bring it into scope explicitly. In addition, so are its variants:
you can use `Some` and `None` directly without the `Option::` prefix. The
`Option<T>` enum is still just a regular enum, and `Some(T)` and `None` are
still variants of type `Option<T>`.
-->
<p>L'énumération <code>Option&lt;T&gt;</code> est tellement utile qu'elle est intégrée dans l'étape
préliminaire ; vous n'avez pas besoin de l'importer explicitement dans la
portée. De plus, voici ses variantes : vous pouvez utiliser directement <code>Some</code>
(<em>quelque chose</em>) et <code>None</code> (<em>rien</em>) sans les préfixer par <code>Option::</code>.
L'énumération <code>Option&lt;T&gt;</code> reste une énumération normale, et <code>Some(T)</code> ainsi que
<code>None</code> sont toujours des variantes de type <code>Option&lt;T&gt;</code>.</p>
<!--
The `<T>` syntax is a feature of Rust we haven’t talked about yet. It’s a
generic type parameter, and we’ll cover generics in more detail in Chapter 10.
For now, all you need to know is that `<T>` means the `Some` variant of the
`Option` enum can hold one piece of data of any type. Here are some examples of
using `Option` values to hold number types and string types
-->
<p>La syntaxe <code>&lt;T&gt;</code> est une fonctionnalité de Rust que nous n'avons pas encore
abordée. Il s'agit d'un paramètre de type générique, et nous verrons la
généricité plus en détail au chapitre 10. Pour le moment, dites-vous que ce
<code>&lt;T&gt;</code> signifie que la variante <code>Some</code> de l'énumération <code>Option</code> peut stocker un
élément de donnée de n'importe quel type. Voici quelques exemples d'utilisation
de valeurs de <code>Option</code> pour stocker des types de nombres et des types de chaînes
de caractères :</p>
<!--
```rust
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let un_nombre = Some(5);
let une_chaine = Some(&quot;une chaîne&quot;);

let nombre_absent: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<!--
If we use `None` rather than `Some`, we need to tell Rust what type of
`Option<T>` we have, because the compiler can’t infer the type that the `Some`
variant will hold by looking only at a `None` value.
-->
<p>Si nous utilisons <code>None</code> plutôt que <code>Some</code>, nous devons indiquer à Rust quel
type de <code>Option&lt;T&gt;</code> nous avons, car le compilateur ne peut pas déduire le type
que cette variante <code>Some</code> va stocker en considérant uniquement une valeur
<code>None</code>.</p>
<!--
When we have a `Some` value, we know that a value is present and the value is
held within the `Some`. When we have a `None` value, in some sense, it means
the same thing as null: we don’t have a valid value. So why is having
`Option<T>` any better than having null?
-->
<p>Lorsque nous avons une valeur <code>Some</code>, nous savons que la valeur est présente et
que la valeur est stockée dans le <code>Some</code>. Lorsque nous avons une valeur <code>None</code>,
en quelque sorte, cela veut dire la même chose que null : nous n'avons pas une
valeur valide. Donc pourquoi obtenir <code>Option&lt;T&gt;</code> est meilleur que d'avoir null ?</p>
<!--
In short, because `Option<T>` and `T` (where `T` can be any type) are different
types, the compiler won’t let us use an `Option<T>` value as if it were
definitely a valid value. For example, this code won’t compile because it’s
trying to add an `i8` to an `Option<i8>`:
-->
<p>En bref, comme <code>Option&lt;T&gt;</code> et <code>T</code> (où <code>T</code> représente n'importe quel type) sont
de types différents, le compilateur ne va pas nous autoriser à utiliser une
valeur <code>Option&lt;T&gt;</code> comme si cela était bien une valeur valide. Par exemple, le
code suivant ne se compile pas car il essaye d'additionner un <code>i8</code> et une
<code>Option&lt;i8&gt;</code> :</p>
<!--
```rust,ignore,does_not_compile
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```
-->
<pre><code class="language-rust ignore does_not_compile">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let somme = x + y;
</code></pre>
<!--
If we run this code, we get an error message like this:
-->
<p>Si nous lançons ce code, nous aurons un message d'erreur comme celui-ci :</p>
<!--
```text
error[E0277]: the trait bound `i8: std::ops::Add<std::option::Option<i8>>` is
not satisfied
 -- >
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option<i8>`
  |
```
-->
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 -- &gt;
  |
5 |     let somme = x + y;
  |                   ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<!--
Intense! In effect, this error message means that Rust doesn’t understand how
to add an `i8` and an `Option<i8>`, because they’re different types. When we
have a value of a type like `i8` in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an `Option<i8>` (or
whatever type of value we’re working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.
-->
<p>Intense ! Effectivement, ce message d'erreur signifie que Rust ne comprend pas
comment additionner un <code>i8</code> et une <code>Option&lt;i8&gt;</code>, car ils sont de types
différents. Quand nous avons une valeur d'un type comme <code>i8</code> avec Rust, le
compilateur va s'assurer que nous avons toujours une valeur valide. Nous pouvons
continuer en toute confiance sans avoir à vérifier que cette valeur n'est pas
nulle avant de l'utiliser. Ce n'est que lorsque nous avons une <code>Option&lt;i8&gt;</code> (ou
tout autre type de valeur avec lequel nous travaillons) que nous devons nous
inquiéter de ne pas avoir de valeur, et le compilateur va s'assurer que nous
gérons ce cas avant d'utiliser la valeur.</p>
<!--
In other words, you have to convert an `Option<T>` to a `T` before you can
perform `T` operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isn’t null when it actually
is.
-->
<p>Autrement dit, vous devez convertir une <code>Option&lt;T&gt;</code> en <code>T</code> pour pouvoir faire
avec elle des opérations du type <code>T</code>. Généralement, cela permet de résoudre l'un
des problèmes les plus courants avec null : supposer qu'une valeur n'est pas
nulle alors qu'en réalité, elle l'est.</p>
<!--
Not having to worry about incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value `Option<T>`.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isn’t an
`Option<T>`, you *can* safely assume that the value isn’t null. This was a
deliberate design decision for Rust to limit null’s pervasiveness and increase
the safety of Rust code.
-->
<p>Ne pas avoir à s'inquiéter que des valeurs nulles puissent être mal gérées vous
aide à être plus confiant en votre code. Pour avoir une valeur qui peut
potentiellement être nulle, vous devez l'indiquer explicitement en déclarant que
le type de cette valeur est <code>Option&lt;T&gt;</code>. Ensuite, quand vous utiliserez cette
valeur, il vous faudra gérer explicitement le cas où cette valeur est nulle. Si
vous utilisez une valeur qui n'est pas une <code>Option&lt;T&gt;</code>, alors vous <em>pouvez</em>
considérer que cette valeur ne sera jamais nulle sans prendre de risques. Il
s'agit d'un choix de conception délibéré de Rust pour limiter l'omniprésence de
null et augmenter la sécurité du code en Rust.</p>
<!--
So, how do you get the `T` value out of a `Some` variant when you have a value
of type `Option<T>` so you can use that value? The `Option<T>` enum has a large
number of methods that are useful in a variety of situations; you can check
them out in [its documentation][docs]<!-- ignore -- >. Becoming familiar with
the methods on `Option<T>` will be extremely useful in your journey with Rust.
-->
<p>Donc, comment récupérer la valeur de type <code>T</code> d'une variante <code>Some</code> quand vous
avez une valeur de type <code>Option&lt;T&gt;</code> afin de l'utiliser ? L'énumération
<code>Option&lt;T&gt;</code> a un large choix de méthodes qui sont plus ou moins utiles selon les
cas ; vous pouvez les découvrir dans <a href="https://doc.rust-lang.org/std/option/enum.Option.html">sa documentation</a><!-- ignore -->. Se
familiariser avec les méthodes de <code>Option&lt;T&gt;</code> peut être très utile dans votre
aventure avec Rust.</p>
<!--
[docs]: ../std/option/enum.Option.html
-->
<!--
In general, in order to use an `Option<T>` value, you want to have code that
will handle each variant. You want some code that will run only when you have a
`Some(T)` value, and this code is allowed to use the inner `T`. You want some
other code to run if you have a `None` value, and that code doesn’t have a `T`
value available. The `match` expression is a control flow construct that does
just this when used with enums: it will run different code depending on which
variant of the enum it has, and that code can use the data inside the matching
value.
-->
<p>De manière générale, pour pouvoir utiliser une valeur de <code>Option&lt;T&gt;</code>, votre code
doit gérer chaque variante. On veut que du code soit exécuté uniquement quand on
a une valeur <code>Some(T)</code>, et que ce code soit autorisé à utiliser la valeur de
type <code>T</code> à l'intérieur. On veut aussi qu'un autre code soit exécuté si on a une
valeur <code>None</code>, et ce code n'aura pas de valeur de type <code>T</code> de disponible.
L'expression <code>match</code> est une structure de contrôle qui fait bien ceci
lorsqu'elle est utilisée avec les énumérations : elle va exécuter du code
différent en fonction de quelle variante de l'énumération elle obtient, et ce
code pourra utiliser la donnée présente dans la valeur correspondante.</p>
<!--
## The `match` Control Flow Operator
-->
<h2><a class="header" href="#la-structure-de-contrôle-match" id="la-structure-de-contrôle-match">La structure de contrôle <code>match</code></a></h2>
<!--
Rust has an extremely powerful control flow operator called `match` that allows
you to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 covers all the different
kinds of patterns and what they do. The power of `match` comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.
-->
<p>Rust a un opérateur de contrôle très puissant appelé <code>match</code>, qui
vous permet de comparer une valeur avec une série de motifs et d'exécuter du
code en fonction du motif qui correspond. Les motifs peuvent être constitués de
valeurs pures, de noms de variables, de jokers, parmi tant d'autres ; le
chapitre 18 va couvrir tous les différents types de motifs et ce qu'ils font. Ce
qui fait la puissance de <code>match</code> est l'expressivité des motifs et le fait que le
compilateur vérifie que tous les cas possibles sont bien gérés.</p>
<!--
Think of a `match` expression as being like a coin-sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a `match`, and at the first pattern the value “fits,”
the value falls into the associated code block to be used during execution.
-->
<p>Considérez l'expression <code>match</code> comme une machine à trier les pièces de
monnaie : les pièces descendent le long d'une piste avec des trous de taille
différente, et chaque pièce tombe dans le premier trou qu'elle
rencontre à sa taille. De manière similaire, les valeurs parcourent tous les
motifs dans un <code>match</code>, et au premier motif auquel la valeur “correspond”, la
valeur va descendre dans le bloc de code correspondant afin d'être utilisée
pendant son exécution.</p>
<!--
Because we just mentioned coins, let’s use them as an example using `match`! We
can write a function that can take an unknown United States coin and, in a
similar way as the counting machine, determine which coin it is and return its
value in cents, as shown here in Listing 6-3.
-->
<p>Comme nous venons de mentionner des pièces, utilisons-les avec un exemple qui
utilise <code>match</code> ! Nous pouvons écrire une fonction qui prend en paramètre une
pièce inconnue des Etats Unis d'Amérique (USA) et, de la même manière qu'une
machine à trier, déterminer quelle pièce c'est et retourner sa valeur en
centimes, comme ci-dessous dans l'encart 6-3.</p>
<!--
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum USACoin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valeur_en_centimes(piece: USACoin) -&gt; u8 {
    match piece {
        USACoin::Penny =&gt; 1,
        USACoin::Nickel =&gt; 5,
        USACoin::Dime =&gt; 10,
        USACoin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-3: An enum and a `match` expression that has
the variants of the enum as its patterns</span>
-->
<p><span class="caption">Encart 6-3 : Une énumération et une expression <code>match</code> qui
trie les variantes de l'énumération dans ses motifs</span></p>
<!--
Let’s break down the `match` in the `value_in_cents` function. First, we list
the `match` keyword followed by an expression, which in this case is the value
`coin`. This seems very similar to an expression used with `if`, but there’s a
big difference: with `if`, the expression needs to return a Boolean value, but
here, it can be any type. The type of `coin` in this example is the `Coin` enum
that we defined on line 1.
-->
<p>Décomposons le <code>match</code> dans la fonction <code>valeur_en_centimes</code>. En premier lieu,
nous utilisons le mot-clé <code>match</code> suivi par une expression, qui dans notre cas
est la valeur de <code>piece</code>. Cela ressemble beaucoup à une expression utilisée avec
<code>if</code>, mais il y a une grosse différence : avec <code>if</code>, l'expression doit retourner
un valeur booléenne, mais ici, elle peut retourner n'importe quel type. Dans cet
exemple, <code>piece</code> est de type <code>USACoin</code>, qui est l'énumération que nous avons
définie à la ligne 1.</p>
<!--
Next are the `match` arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value `Coin::Penny` and then the `=>`
operator that separates the pattern and the code to run. The code in this case
is just the value `1`. Each arm is separated from the next with a comma.
-->
<p>Ensuite, nous avons les branches du <code>match</code>. Une branche a deux parties : un
motif et du code. La première branche a ici pour motif la valeur
<code>USACoin::Penny</code> et ensuite l'opérateur <code>=&gt;</code> qui sépare le motif et le code à
exécuter. Le code dans ce cas est uniquement la valeur <code>1</code>. Chaque branche est
séparée de la suivante par une virgule.</p>
<!--
When the `match` expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn’t match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our `match` has four arms.
-->
<p>Lorsqu'une expression <code>match</code> est exécutée, elle compare la valeur de <code>piece</code>
avec le motif de chaque branche, dans l'ordre. Si un motif correspond à la
valeur, le code correspondant à ce motif est alors exécuté. Si ce motif ne
correspond pas à la valeur, l'exécution passe à la prochaine branche, un peu
comme dans une machine de tri de pièces. Nous pouvons avoir autant de branches
que nous avons besoin : dans l'encart 6-3, notre <code>match</code> a quatre branches.</p>
<!--
The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire `match` expression.
-->
<p>Le code correspondant à chaque branche est une expression, et la valeur qui
résulte de l'expresssion dans la branche correspondante est la valeur qui sera
retournée par l'expression <code>match</code>.</p>
<!--
Curly brackets typically aren’t used if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you can use curly brackets. For example, the
following code would print “Lucky penny!” every time the method was called with
a `Coin::Penny` but would still return the last value of the block, `1`:
-->
<p>Les accolades ne sont généralement pas utilisées si le code de la branche
correspondante est court, comme est le cas dans l'encart 6-3 où chaque branche
retourne simplement une valeur. Si vous voulez exécuter plusieures lignes de
code dans une branche d'un <code>match</code>, vous devez utiliser les accolades. Par
exemple, le code suivant va afficher “Un centime porte-bonheur !” à chaque fois
que la méthode est appellée avec une valeur <code>USACoin::Penny</code> mais va continuer
à retourner la dernière valeur du bloc, <code>1</code> :</p>
<!--
```rust
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum USACoin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: USACoin) -&gt; u8 {
    match piece {
        USACoin::Penny =&gt; {
            println!(&quot;Un centime porte-bonheur !&quot;);
            1
        },
        USACoin::Nickel =&gt; 5,
        USACoin::Dime =&gt; 10,
        USACoin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
### Patterns that Bind to Values
-->
<h3><a class="header" href="#des-motifs-reliés-à-des-valeurs" id="des-motifs-reliés-à-des-valeurs">Des motifs reliés à des valeurs</a></h3>
<!--
Another useful feature of match arms is that they can bind to the parts of the
values that match the pattern. This is how we can extract values out of enum
variants.
-->
<p>Une autre fonctionnalité intéressante des branches de <code>match</code> est qu'elles
peuvent se lier aux valeurs qui correspondent au motif. C'est ainsi que nous
pouvons extraire les valeurs d'une variante d'énumération.</p>
<!--
As an example, let’s change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our `enum` by changing the `Quarter` variant to include a `UsState` value stored
inside it, which we’ve done here in Listing 6-4.
-->
<p>En guise d'exemple, changeons une de nos variantes d'énumération pour stocker
une donnée à l'intérieur. Entre 1999 et 2008, les Etats-Unis d'Amérique ont
frappé un côté des pièces de monnaie &quot;Quarter&quot; avec des décors différents pour
chacun des 50 états. Les autres pièces n'ont pas eu de décors d'états, donc
seul le &quot;Quarter&quot; a cette valeur en plus. Nous pouvons ajouter cette information
à notre <code>enum</code> en changeant la variante <code>Quarter</code> pour y ajouter une valeur
<code>USAState</code> qui y sera stockée à l'intérieur, comme nous l'avons fait dans
l'encart 6-4.</p>
<!--
```rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)] // pour pouvoir afficher l'État
enum USAState {
    Alabama,
    Alaska,
    // -- code masqué ici --
}

enum USACoin {
    Penny,
    Nickel,
    Dime,
    Quarter(USAState),
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-4: A `Coin` enum in which the `Quarter` variant
also holds a `UsState` value</span>
-->
<p><span class="caption">Encart 6-4 : Une énumération <code>USACoin</code> dans laquelle la
variante <code>Quarter</code> stocke en plus une valeur de type <code>USAState</code></span></p>
<!--
Let’s imagine that a friend of ours is trying to collect all 50 state quarters.
While we sort our loose change by coin type, we’ll also call out the name of
the state associated with each quarter so if it’s one our friend doesn’t have,
they can add it to their collection.
-->
<p>Imaginons qu'un de vos amis essaye de récupérer tous les &quot;Quarter&quot; des 50 états.
Pendant que nous trions notre monnaie en vrac par type de pièce, nous
mentionnerons aussi le nom de l'état correspondant à chaque &quot;Quarter&quot; de sorte
que si notre ami ne l'a pas, il puisse l'ajouter à sa collection.</p>
<!--
In the match expression for this code, we add a variable called `state` to the
pattern that matches values of the variant `Coin::Quarter`. When a
`Coin::Quarter` matches, the `state` variable will bind to the value of that
quarter’s state. Then we can use `state` in the code for that arm, like so:
-->
<p>Dans l'expression <code>match</code> de ce code, nous avons ajouté une variable <code>etat</code> au
motif qui correspond à la variante <code>USACoin::Quarter</code>. Quand on aura une
correspondance <code>USACoin::Quarter</code>, la variable <code>etat</code> sera liée à la valeur de
l'état de cette pièce. Ensuite, nous pourrons utiliser <code>etat</code> dans le code de
cette branche, comme ceci :</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
#
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum USAState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum USACoin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(USAState),
</span><span class="boring">}
</span><span class="boring">
</span>fn valeur_en_centimes(piece: USACoin) -&gt; u8 {
    match piece {
        USACoin::Penny =&gt; 1,
        USACoin::Nickel =&gt; 5,
        USACoin::Dime =&gt; 10,
        USACoin::Quarter(etat) =&gt; {
            println!(&quot;Il s'agit d'un Quarter de l'état de {:?} !&quot;, etat);
            25
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin`
would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each
of the match arms, none of them match until we reach `Coin::Quarter(state)`. At
that point, the binding for `state` will be the value `UsState::Alaska`. We can
then use that binding in the `println!` expression, thus getting the inner
state value out of the `Coin` enum variant for `Quarter`.
-->
<p>Si nous appelons <code>valeur_en_centimes(USACoin::Quarter(USAState::Alaska))</code>,
<code>piece</code> vaudra <code>USACoin::Quarter(USAState::Alaska)</code>. Quand nous comparons cette
valeur avec toutes les branches du <code>match</code>, aucune d'entre elles ne
correspondront jusqu'à ce qu'on arrive à <code>USACoin::Quarter(etat)</code>. A partir de
ce moment, la variable <code>etat</code> aura la valeur <code>USAState::Alaska</code>. Nous pouvons
alors utiliser cette variable dans l'expression <code>println!</code>, ce qui nous permet
d'afficher la valeur de l'état à l'intérieur de la variante <code>Quarter</code> de la
l'énumération <code>USACoin</code>.</p>
<!--
### Matching with `Option<T>`
-->
<h3><a class="header" href="#utiliser-match-avec-optiont" id="utiliser-match-avec-optiont">Utiliser <code>match</code> avec <code>Option&lt;T&gt;</code></a></h3>
<!--
In the previous section, we wanted to get the inner `T` value out of the `Some`
case when using `Option<T>`; we can also handle `Option<T>` using `match` as we
did with the `Coin` enum! Instead of comparing coins, we’ll compare the
variants of `Option<T>`, but the way that the `match` expression works remains
the same.
-->
<p>Dans la section précédente, nous voulions obtenir la valeur interne <code>T</code> dans le
cas de <code>Some</code> lorsqu'on utilisait <code>Option&lt;T&gt;</code> ; nous pouvons aussi gérer les
<code>Option&lt;T&gt;</code> en utilisant <code>match</code> comme nous l'avons fait avec l'énumération
<code>USACoin</code> ! Au lieu de comparer des pièces, nous allons comparer les variantes
de <code>Option&lt;T&gt;</code>, mais la façon d'utiliser l'expression <code>match</code> reste la même.</p>
<!--
Let’s say we want to write a function that takes an `Option<i32>` and, if
there’s a value inside, adds 1 to that value. If there isn’t a value inside,
the function should return the `None` value and not attempt to perform any
operations.
-->
<p>Disons que nous voulons écrire une fonction qui prend une <code>Option&lt;i32&gt;</code> et, si
il y a une valeur à l'intérieur, ajouter 1 à cette valeur. S'il n'y pas de
valeur à l'intérieur, la fonction retournera la valeur <code>None</code> et ne va rien
faire de plus.</p>
<!--
This function is very easy to write, thanks to `match`, and will look like
Listing 6-5.
-->
<p>Cette fonction est très facile à écrire, grâce à <code>match</code>, et ressemblera à
l'encart 6-5.</p>
<!--
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let cinq = Some(5);
let six = plus_un(cinq);
let none = plus_un(None);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-5: A function that uses a `match` expression on
an `Option<i32>`</span>
-->
<p><span class="caption">Encart 6-5 : Une fonction qui utilise une expression
<code>match</code> sur une <code>Option&lt;i32&gt;</code></span></p>
<!--
Let’s examine the first execution of `plus_one` in more detail. When we call
`plus_one(five)`, the variable `x` in the body of `plus_one` will have the
value `Some(5)`. We then compare that against each match arm.
-->
<p>Examinons la première exécution de <code>plus_un</code> en détail. Lorsque nous appellons
<code>plus_un(cinq)</code>, la variable <code>x</code> dans le corps de <code>plus_un</code> aura la valeur
<code>Some(5)</code>. Ensuite, nous comparons cela à chaque branche du <code>match</code>.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<!--
The `Some(5)` value doesn’t match the pattern `None`, so we continue to the
next arm.
-->
<p>La valeur <code>Some(5)</code> ne correspond pas au motif <code>None</code>, donc nous continuons à la
prochaine branche.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<!--
Does `Some(5)` match `Some(i)`? Why yes it does! We have the same variant. The
`i` binds to the value contained in `Some`, so `i` takes the value `5`. The
code in the match arm is then executed, so we add 1 to the value of `i` and
create a new `Some` value with our total `6` inside.
-->
<p>Est-ce que <code>Some(5)</code> correspond au <code>Some(i)</code> ? Bien sûr ! Nous avons la
même variante. Le <code>i</code> va prendre la valeur contenue dans le <code>Some</code>, donc <code>i</code>
prend la valeur <code>5</code>. La code dans la branche du <code>match</code> est exécuté, donc nous
ajoutons 1 à la valeur de <code>i</code> et nous créons une nouvelle valeur <code>Some</code> avec
notre résultat <code>6</code> à l'intérieur.</p>
<!--
Now let’s consider the second call of `plus_one` in Listing 6-5, where `x` is
`None`. We enter the `match` and compare to the first arm.
-->
<p>Maintenant, regardons le second appel à <code>plus_un</code> dans l'encart 6-5, où <code>x</code> vaut
<code>None</code>. Nous entrons dans le <code>match</code> et nous le comparons à la première branche.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<!--
It matches! There’s no value to add to, so the program stops and returns the
`None` value on the right side of `=>`. Because the first arm matched, no other
arms are compared.
-->
<p>Cela correspond ! Il n'y a pas de valeur à additionner, donc le programmme
s'arrête et retourne la valeur <code>None</code> qui est dans le côté droit du <code>=&gt;</code>. Comme
la première branche correspond, les autres branches ne sont pas comparées.</p>
<!--
Combining `match` and enums is useful in many situations. You’ll see this
pattern a lot in Rust code: `match` against an enum, bind a variable to the
data inside, and then execute code based on it. It’s a bit tricky at first, but
once you get used to it, you’ll wish you had it in all languages. It’s
consistently a user favorite.
-->
<p>La combinaison de <code>match</code> et des énumérations est utile dans de nombreuses
situations. Vous allez revoir de nombreuses fois ce schéma dans du code Rust :
utiliser <code>match</code> sur une énumération, récupérer la valeur qu'elle renferme, et
exécuter du code en fonction de sa valeur. C'est un peu délicat au début, mais
une fois que vous vous y êtes habitué, vous regretterez de ne pas l'avoir dans
les autres langages. Cela devient toujours l'outil préféré de ses utilisateurs.</p>
<!--
### Matches Are Exhaustive
-->
<h3><a class="header" href="#les-match-sont-toujours-exhaustifs" id="les-match-sont-toujours-exhaustifs">Les <code>match</code> sont toujours exhaustifs</a></h3>
<!--
There’s one other aspect of `match` we need to discuss. Consider this version
of our `plus_one` function that has a bug and won’t compile:
-->
<p>Il y a un autre point de <code>match</code> que nous devons aborder. Admettons que cette
version de notre fonction <code>plus_un</code> a un bogue et ne va pas se compiler :</p>
<!--
```rust,ignore,does_not_compile
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```
-->
<pre><code class="language-rust ignore does_not_compile">fn plus_un(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<!--
We didn’t handle the `None` case, so this code will cause a bug. Luckily, it’s
a bug Rust knows how to catch. If we try to compile this code, we’ll get this
error:
-->
<p>Nous n'avons pas géré le cas du <code>None</code>, donc ce code va générer un bogue.
Heureusement, c'est un bogue que Rust sait gérer. Si nous essayons de compiler
ce code, nous allons obtenir cette erreur :</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 -- &gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<!--
Rust knows that we didn’t cover every possible case and even knows which
pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
`Option<T>`, when Rust prevents us from forgetting to explicitly handle the
`None` case, it protects us from assuming that we have a value when we might
have null, thus making the billion-dollar mistake discussed earlier.
-->
<p>Rust sait que nous n'avons pas couvert toutes les possibilités et sait même quel
motif nous avons oublié ! Les <code>match</code> de Rust sont <em>exhaustifs</em> : nous devons
traiter toutes les possibilités afin que le code soit valide. Dans notre cas de
<code>Option&lt;T&gt;</code>, quand Rust nous empêche d'oublier de gérer explicitement le cas de
<code>None</code>, il nous protège d'une situation où nous supposons que nous avons une
valeur alors que nous pourrions avoir null, comme l'erreur au milliards de
dollars que nous avons vu précédemment.</p>
<!--
### The `_` Placeholder
-->
<h3><a class="header" href="#le-caractère-réservé-_" id="le-caractère-réservé-_">Le caractère réservé <code>_</code></a></h3>
<!--
Rust also has a pattern we can use when we don’t want to list all possible
values. For example, a `u8` can have valid values of 0 through 255. If we only
care about the values 1, 3, 5, and 7, we don’t want to have to list out 0, 2,
4, 6, 8, 9 all the way up to 255. Fortunately, we don’t have to: we can use the
special pattern `_` instead:
-->
<p>Rust a aussi un motif que nous pouvons utliser quand nous ne voulons pas traiter
toutes les valeurs possibles. Par exemple, un <code>u8</code> peut être valide entre 0
et 255. Si nous n'avons besoin que des valeurs 1, 3, 5 et 7, nous ne voulons pas
traiter 0, 2, 4, 6, 7, 8, 9 et ainsi de suite jusqu'à 255. Heureusement, nous
n'avons pas à le faire : nous pouvons utiliser le motif spécial <code>_</code> :</p>
<!--
```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let une_valeur_u8 = 0u8;
match une_valeur_u8 {
    1 =&gt; println!(&quot;un&quot;),
    3 =&gt; println!(&quot;trois&quot;),
    5 =&gt; println!(&quot;cinq&quot;),
    7 =&gt; println!(&quot;sept&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `_` pattern will match any value. By putting it after our other arms, the
`_` will match all the possible cases that aren’t specified before it. The `()`
is just the unit value, so nothing will happen in the `_` case. As a result, we
can say that we want to do nothing for all the possible values that we don’t
list before the `_` placeholder.
-->
<p>Le motif <code>_</code> va correspondre à toutes les valeurs. En l'ajoutant à la fin de nos
branches, le <code>_</code> va correspondre à tous les autres cas qui ne sont pas listés
avant. Au final, nous avons pu dire que nous ne voulons rien faire pour les
valeurs possibles que nous ne traitons pas avant le caractère réservé <code>_</code>.</p>
<!--
However, the `match` expression can be a bit wordy in a situation in which we
care about only *one* of the cases. For this situation, Rust provides `if let`.
-->
<p>Cependant, l'expression <code>match</code> peut être un peu lourde dans une situation où
nous nous préoccupons uniquement <em>d'un seul</em> cas. Pour ce cas, Rust nous propose
d'utiliser une autre structure, <code>if let</code>.</p>
<!--
## Concise Control Flow with `if let`
-->
<h2><a class="header" href="#une-structure-de-contrôle-concise--if-let" id="une-structure-de-contrôle-concise--if-let">Une structure de contrôle concise : <code>if let</code></a></h2>
<!--
The `if let` syntax lets you combine `if` and `let` into a less verbose way to
handle values that match one pattern while ignoring the rest. Consider the
program in Listing 6-6 that matches on an `Option<u8>` value but only wants to
execute code if the value is 3.
-->
<p>La syntaxe <code>if let</code> vous permet de combiner <code>if</code> et <code>let</code> afin de gérer une
valeur qui correspond à un motif tout en ignorant les autres possibilités.
Imaginons le programme dans l'encart 6-6 qui fait un <code>match</code> sur une valeur
<code>Option&lt;u8&gt;</code> mais n'a besoin d'exécuter du code que si la valeur est 3.</p>
<!--
```rust
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) => println!("three"),
    _ => (),
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let une_valeur_u8 = Some(0u8);
match une_valeur_u8 {
    Some(3) =&gt; println!(&quot;trois&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-6: A `match` that only cares about executing
code when the value is `Some(3)`</span>
-->
<p><span class="caption">Encart 6-6 : Un <code>match</code> qui n'exécute du code que si la
valeur est <code>Some(3)</code></span></p>
<!--
We want to do something with the `Some(3)` match but do nothing with any other
`Some<u8>` value or the `None` value. To satisfy the `match` expression, we
have to add `_ => ()` after processing just one variant, which is a lot of
boilerplate code to add.
-->
<p>Nous voulons faire quelque chose avec la valeur <code>Some(3)</code> mais ignorer
les autres valeurs de type <code>Some&lt;u8&gt;</code> ou la valeur <code>None</code>. Pour satisfaire
l'expression <code>match</code>, nous devons ajouter <code>_ =&gt; ()</code> après avoir géré une seule
variante, ce qui fait beaucoup de code inutile.</p>
<!--
Instead, we could write this in a shorter way using `if let`. The following
code behaves the same as the `match` in Listing 6-6:
-->
<p>A la place, nous pourrions écrire le même programme de manière plus concise en
utilisant <code>if let</code>. Le code suivant se comporte comme le <code>match</code> de l'encart
6-6 :</p>
<!--
```rust
# let some_u8_value = Some(0u8);
if let Some(3) = some_u8_value {
    println!("three");
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let une_valeur_u8 = Some(0u8);
</span>if let Some(3) = une_valeur_u8 {
    println!(&quot;trois&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
The syntax `if let` takes a pattern and an expression separated by an equal
sign. It works the same way as a `match`, where the expression is given to the
`match` and the pattern is its first arm.
-->
<p>La syntaxe <code>if let</code> prend un motif et une expression séparés par un signe égal.
Elle fonctionne de la même manière qu'un <code>match</code> où l'expression est donnée au
<code>match</code> et que le motif est sa première branche.</p>
<!--
Using `if let` means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that `match` enforces. Choosing
between `match` and `if let` depends on what you’re doing in your particular
situation and whether gaining conciseness is an appropriate trade-off for
losing exhaustive checking.
-->
<p>Utiliser <code>if let</code> permet d'écrire moins de code, et de moins l'indenter.
Cependant, vous perdez la vérification de l'exhaustivité qu'assure le <code>match</code>.
Choisir entre <code>match</code> et <code>if let</code> dépend de la situation : à vous de choisir
un équilibre entre être concis et appliquer une vérification exhaustive.</p>
<!--
In other words, you can think of `if let` as syntax sugar for a `match` that
runs code when the value matches one pattern and then ignores all other values.
-->
<p>Autrement dit, vous pouvez considérer le <code>if let</code> comme du sucre syntaxique pour
un <code>match</code> qui exécute du code uniquement quand la valeur correspond à un motif
et ignore tous autres valeurs.</p>
<!--
We can include an `else` with an `if let`. The block of code that goes with the
`else` is the same as the block of code that would go with the `_` case in the
`match` expression that is equivalent to the `if let` and `else`. Recall the
`Coin` enum definition in Listing 6-4, where the `Quarter` variant also held a
`UsState` value. If we wanted to count all non-quarter coins we see while also
announcing the state of the quarters, we could do that with a `match`
expression like this:
-->
<p>Nous pouvons joindre un <code>else</code> à un <code>if let</code>. Le bloc de code qui va dans le
<code>else</code> est le même que le bloc de code qui va dans le cas <code>_</code> avec l'expression
<code>match</code>. Souvenez-vous de la définition de l'énumération <code>USACoin</code> de l'encart
6-4, où la variante <code>Quarter</code> avait aussi une valeur <code>USAState</code>. Si nous
voulions compter toutes les pièces qui ne sont pas des <code>Quarter</code> que nous voyons
passer, tout en affichant l'état des <code>Quarter</code>, nous pourrions le faire avec
une expression <code>match</code> comme ceci :</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum USAState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum USACoin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(USAState),
</span><span class="boring">}
</span><span class="boring">let piece = USACoin::Penny;
</span>let mut compteur = 0;
match piece {
    USACoin::Quarter(etat) =&gt; println!(&quot;Il s'agit d'un Quarter de l'état de {:?} !&quot;, etat),
    _ =&gt; compteur += 1,
}
<span class="boring">}
</span></code></pre></pre>
<!--
Or we could use an `if let` and `else` expression like this:
-->
<p>Ou nous pourrions utiliser une expression <code>if let</code>/<code>else</code> comme ceci :</p>
<!--
```rust
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum USAState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum USACoin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(USAState),
</span><span class="boring">}
</span><span class="boring">let piece = USACoin::Penny;
</span>let mut compteur = 0;
if let USACoin::Quarter(etat) = piece {
    println!(&quot;Il s'agit d'un Quarter de l'état de {:?}!&quot;, etat);
} else {
    compteur += 1;
}
<span class="boring">}
</span></code></pre></pre>
<!--
If you have a situation in which your program has logic that is too verbose to
express using a `match`, remember that `if let` is in your Rust toolbox as well.
-->
<p>Si vous trouvez que votre programme est alourdi par l'utilisation d'un <code>match</code>,
souvenez-vous que <code>if let</code> est aussi présent dans votre boite à outils Rust.</p>
<!--
## Summary
-->
<h2><a class="header" href="#résumé-5" id="résumé-5">Résumé</a></h2>
<!--
We’ve now covered how to use enums to create custom types that can be one of a
set of enumerated values. We’ve shown how the standard library’s `Option<T>`
type helps you use the type system to prevent errors. When enum values have
data inside them, you can use `match` or `if let` to extract and use those
values, depending on how many cases you need to handle.
-->
<p>Nous avons désormais appris comment utiliser les énumérations pour créer des
types personnalisés qui peuvent faire partie d'un jeu de valeurs recensées. Nous
avons montré comment le type <code>Option&lt;T&gt;</code> de la bibliothèque standard vous aide
à utiliser le système de types pour éviter les erreurs. Lorsque les valeurs
d'énumération contiennent des données, vous pouvez utiliser <code>match</code>
ou <code>if let</code> pour extraire et utiliser ces valeurs, à choisir en fonction du
nombre de cas que vous voulez gérer.</p>
<!--
Your Rust programs can now express concepts in your domain using structs and
enums. Creating custom types to use in your API ensures type safety: the
compiler will make certain your functions get only values of the type each
function expects.
-->
<p>Vos programmes Rust peuvent maintenant décrire des concepts métier à l'aide de
structures et d'énumérations. Créer des types personnalisés à utiliser dans
votre API assure la sécurité des types : le compilateur s'assurera que vos
fonctions ne reçoivent que des valeurs du type attendu.</p>
<!--
In order to provide a well-organized API to your users that is straightforward
to use and only exposes exactly what your users will need, let’s now turn to
Rust’s modules.
-->
<p>Afin de fournir une API bien organisée, simple à utiliser et qui n'expose que ce
dont vos utilisateurs auront besoin, découvrons maintenant les modules de Rust.</p>
<!--
# Managing Growing Projects with Packages, Crates, and Modules
-->
<h1><a class="header" href="#gérer-des-projets-grandissants-avec-les-paquets-crates-et-modules" id="gérer-des-projets-grandissants-avec-les-paquets-crates-et-modules">Gérer des projets grandissants avec les paquets, crates et modules</a></h1>
<!--
As you write large programs, organizing your code will be important because
keeping track of your entire program in your head will become impossible. By
grouping related functionality and separating code with distinct features,
you’ll clarify where to find code that implements a particular feature and
where to go to change how a feature works.
-->
<p>Lorsque vous commencez à écrire des gros programmes, organiser votre code va
devenir important car vous ne pourrez plus vous souvenir de l'intégralité de
votre programme. En regroupant des fonctionnalités qui ont des points
communs et en séparant des autres fonctionnalités, vous clarifiez l'endroit où
trouver le code qui implémente une fonctionnalité spécifique afin de pouvoir le
relire ou le modifier.</p>
<!--
The programs we’ve written so far have been in one module in one file. As a
project grows, you can organize code by splitting it into multiple modules and
then multiple files. A package can contain multiple binary crates and
optionally one library crate. As a package grows, you can extract parts into
separate crates that become external dependencies. This chapter covers all
these techniques. For very large projects of a set of interrelated packages
that evolve together, Cargo provides workspaces, which we’ll cover in the
[“Cargo Workspaces”][workspaces]<!-- ignore -- > section in Chapter 14.
-->
<p>Le programme que nous avons écrit précédemment était dans un module et dans un
seul fichier. Quand le projet grandit, vous pouvez organiser votre code en le
découpant en plusieurs modules et ensuite en plusieurs fichiers. Un paquet peut
contenir plusieurs crates binaires et accessoirement une crate de bibliothèque.
Lorsqu'un paquet grandit, vous pouvez en extraire des parties dans des crates
séparées qui deviennent des dépendances externes. Ce chapitre va aborder toutes
ces techniques. Pour un projet de très grande envergure qui a des paquets
interconnectés qui évoluent ensemble, Cargo propose les espaces de travail, que
nous allons découvrir dans une section du
<a href="ch14-03-cargo-workspaces.html">chapitre 14</a><!-- ignore -->.</p>
<!--
In addition to grouping functionality, encapsulating implementation details
lets you reuse code at a higher level: once you’ve implemented an operation,
other code can call that code via the code’s public interface without knowing
how the implementation works. The way you write code defines which parts are
public for other code to use and which parts are private implementation details
that you reserve the right to change. This is another way to limit the amount
of detail you have to keep in your head.
-->
<p>En plus de regrouper des fonctionnalités, les modules vous permettent
d'encapsuler les détails de l'implémentation d'une opération : vous pouvez
écrire du code puis l'utiliser comme une abstraction à travers l'interface de
programmation publique (API) du code sans se soucier de connaître les détails de
son implémentation. La façon dont vous écrivez le code définit quelles sont les
parties sont publiques pour qu'un autre code puisse l'utiliser et quelles
parties sont des détails d'implémentation privées dont vous vous réservez le
droit de modifier. C'est un autre moyen de limiter le nombre d'éléments de
l'API pour celui qui l'utilise.</p>
<!--
A related concept is scope: the nested context in which code is written has a
set of names that are defined as “in scope.” When reading, writing, and
compiling code, programmers and compilers need to know whether a particular
name at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You can’t have two items with the
same name in the same scope; tools are available to resolve name conflicts.
-->
<p>Un concept qui lui est associé est la portée : le contexte dans lequel le code
est écrit a un jeu de noms qui sont définis comme “dans la portée”. Quand ils
lisent, écrivent et compilent du code, les développeurs et les compilateurs ont
besoin de savoir précisément ce que désigne une entité, que cette entité soit
une variable, une fonction, une structure, une énumération, un module, une
constante ... Vous pouvez créer des portées et décider si les entités sont dans
la portée ou non. Vous ne pouvez pas avoir deux entités avec le même nom dans la
même portée ; cependant des outils existent pour résoudre les conflits de nom.</p>
<!--
Rust has a number of features that allow you to manage your code’s
organization, including which details are exposed, which details are private,
and what names are in each scope in your programs. These features, sometimes
collectively referred to as the *module system*, include:
-->
<p>Rust a de nombreuses fonctionnalités qui vous permettent de gérer l'organisation
de votre code, grâce à ce que la communauté Rust appelle le <em>système de
modules</em>.
Ce système définit quels sont les éléments qui sont accessibles depuis
l'extérieur de la bibliothèque (notion de privé ou public), ansi que leur
portée.
Ces fonctionnalités comprennent :</p>
<!--
* **Packages:** A Cargo feature that lets you build, test, and share crates
* **Crates:** A tree of modules that produces a library or executable
* **Modules** and **use:** Let you control the organization, scope, and
  privacy of paths
* **Paths:** A way of naming an item, such as a struct, function, or module
-->
<ul>
<li><strong>les paquets :</strong> une fonctionnalité de Cargo qui vous permet de compiler,
tester, et partager des crates.</li>
<li><strong>les <code>Crates</code> :</strong> une arborescence de modules qui fournit une bibliothèque ou
un exécutable</li>
<li><strong>les chemins :</strong> une façon de nommer un élément, comme une structure, une
fonction ou un module.</li>
</ul>
<!--
In this chapter, we’ll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!
-->
<p>Dans ce chapitre, nous allons découvrir ces fonctionnalités, voir comment elles
intéragissent, et expliquer comment les utiliser pour gérer les portées. À
l'issue de ce chapitre, vous aurez de solides connaissances sur le système de
modules et vous pourrez travailler avec les portées comme un pro !</p>
<!--
## Packages and Crates
-->
<h2><a class="header" href="#les-paquets-et-les-crates" id="les-paquets-et-les-crates">Les paquets et les crates</a></h2>
<!--
The first parts of the module system we’ll cover are packages and crates. A
crate is a binary or library. The *crate root* is a source file that the Rust
compiler starts from and makes up the root module of your crate (we’ll explain
modules in depth in the [“Defining Modules to Control Scope and
Privacy”][modules]<!-- ignore -- >) section. A *package* is one or more crates
that provide a set of functionality. A package contains a *Cargo.toml* file
that describes how to build those crates.
-->
<p>La première partie du système de modules que nous allons aborder concerne les
paquets et les <em>crates</em>. Une crate est un binaire ou une bibliothèque. Pour la
compiler, le compilateur Rust part d'un fichier source, la racine de la <em>crate</em>,
à partir duquel est alors créé le <em>module racine</em> de votre <em>crate</em> (nous verrons
les modules plus en détail dans la <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">section suivante</a><!-- ignore -->).</p>
<!--
Several rules determine what a package can contain. A package *must* contain
zero or one library crates, and no more. It can contain as many binary crates
as you’d like, but it must contain at least one crate (either library or
binary).
-->
<p>Il y a plusieurs règles qui déterminent ce qu'un paquet peut contenir. il doit
contenir une seule crate de bibliothèque, ou aucune. Il peut contenir autant de
crates binaires que vous le souhaitez, mais il doit contenir au moins une crate
(que ce soit une bibliothèque ou un binaire).</p>
<!--
Let’s walk through what happens when we create a package. First, we enter the
command `cargo new`:
-->
<p>Découvrons ce qui se passe quand nous créons un paquet. D'abord, nous utilisons
la commande <code>cargo new</code> :</p>
<!--
```text
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```
-->
<pre><code class="language-text">$ cargo new mon-projet
     Created binary (application) `mon-projet` package
$ ls mon-projet
Cargo.toml
src
$ ls mon-projet/src
main.rs
</code></pre>
<!--
When we entered the command, Cargo created a *Cargo.toml* file, giving us a
package. Looking at the contents of *Cargo.toml*, there’s no mention of
*src/main.rs* because Cargo follows a convention that *src/main.rs* is the
crate root of a binary crate with the same name as the package. Likewise, Cargo
knows that if the package directory contains *src/lib.rs*, the package contains
a library crate with the same name as the package, and *src/lib.rs* is its
crate root. Cargo passes the crate root files to `rustc` to build the library
or binary.
-->
<p>Lorsque nous avons saisi la commande, Cargo a créé un fichier <em>Cargo.toml</em>, qui
définit un paquet. Si on regarde le contenu de <em>Cargo.toml</em>, le fichier
<em>src/main.rs</em> n'est pas mentionné car Cargo obéit à une convention selon
laquelle <em>src/main.rs</em> est la racine de la crate binaire portant le même
nom que le paquet. De la même façon, Cargo sait que si le dossier du paquet
contient <em>src/lib.rs</em>, alors le paquet contient une crate de bibliothèque qui a
le même nom que le paquet, et que <em>src/lib.rs</em> est sa racine. Cargo transmet les
fichiers de la crate racine à <code>rustc</code> pour compiler la bibliothèque ou le
binaire.</p>
<!--
Here, we have a package that only contains *src/main.rs*, meaning it only
contains a binary crate named `my-project`. If a package contains *src/main.rs*
and *src/lib.rs*, it has two crates: a library and a binary, both with the same
name as the package. A package can have multiple binary crates by placing files
in the *src/bin* directory: each file will be a separate binary crate.
-->
<p>Dans notre cas, nous avons un paquet qui contient uniquement <em>src/main.rs</em>, ce
qui veut dire qu'il contient uniquement une crate binaire qui s'appelle
<code>mon-projet</code>. Si un paquet contient <em>src/main.rs</em> et <em>src/lib.rs</em>, il a deux
crates : une bibliothèque et une binaire, chacune avec le même nom que le
paquet. Un paquet peut avoir plusieurs crates binaires en ajoutant des fichiers
dans le répertoire <em>src/bin</em> : chaque fichier sera une crate séparée.</p>
<!--
A crate will group related functionality together in a scope so the
functionality is easy to share between multiple projects. For example, the
`rand` crate we used in [Chapter 2][rand]<!-- ignore -- > provides functionality
that generates random numbers. We can use that functionality in our own
projects by bringing the `rand` crate into our project’s scope. All the
functionality provided by the `rand` crate is accessible through the crate’s
name, `rand`.
-->
<p>Une crate regroupe plusieurs fonctionnalités associées ensemble dans une
portée afin que les fonctionnalités soient faciles à partager entre plusieurs
projets. Par exemple, la crate <code>rand</code> que nous avons utilisé dans
<a href="ch02-00-guessing-game-tutorial.html#g%C3%A9n%C3%A9rer-le-nombre-secret">le chapitre 2</a><!-- ignore --> nous permet de générer
des nombres aléatoires. Nous pouvons utiliser cette fonctionnalité dans notre
propre projet en important la crate <code>rand</code> dans la portée de notre projet.
Toutes les fonctionnalités fournies par la crate <code>rand</code> seront accessibles via
le nom de la crate, <code>rand</code>.</p>
<!--
Keeping a crate’s functionality in its own scope clarifies whether particular
functionality is defined in our crate or the `rand` crate and prevents
potential conflicts. For example, the `rand` crate provides a trait named
`Rng`. We can also define a `struct` named `Rng` in our own crate. Because a
crate’s functionality is namespaced in its own scope, when we add `rand` as a
dependency, the compiler isn’t confused about what the name `Rng` refers to. In
our crate, it refers to the `struct Rng` that we defined. We would access the
`Rng` trait from the `rand` crate as `rand::Rng`.
-->
<p>Ranger une fonctionnalité d'une crate dans sa propre portée clarifie si une
fonctionnalité précise est définie dans notre crate ou dans la crate <code>rand</code> et
évite ainsi de potentiels conflits. Par exemple, la crate <code>rand</code> fournit un
<em>trait</em> qui s'appelle <code>Rng</code>. Nous pouvons nous aussi définir une structure qui
s'appelle <code>Rng</code> dans notre propre crate. Comme les fonctionnalités des crates
sont dans la portée de leur propre espace de nom, quand nous ajoutons <code>rand</code> en
dépendance, il n'y a pas d'ambiguïté pour le compilateur sur le nom <code>Rng</code>. Dans
notre crate, il se réfère au <code>struct Rng</code> que nous avons défini. Nous accédons
au <em>trait</em> <code>Rng</code> de la crate <code>rand</code> via <code>rand::Rng</code>.</p>
<!--
Let’s move on and talk about the module system!
-->
<p>Continuons d'avancer et parlons maintenant du système de modules !</p>
<!--
[rand]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
